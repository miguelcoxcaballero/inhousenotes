<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>inhouse notes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=DM+Sans:wght@400;500;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-primary: #f5f5f0;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --accent-yellow: #ffde00;
            --accent-blue: #002FD9;
            --accent-red: #E81010;
            --accent-black: #4D4D4D;
            --accent-orange: #E07A3C;
            --accent-green: #34c759;
            --shadow-soft: 0 2px 20px rgba(0,0,0,0.08);
            --shadow-medium: 0 4px 30px rgba(0,0,0,0.12);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --tool-size: 52px;
            --toolbar-padding: 12px;
            --handle-width: 52px;
            --handle-height: 28px;
            --icon-size: 24px;
            --header-btn-size: 44px;
            --selection-handle-size: 14px;
            --selection-handle-offset: calc(-1px - (var(--selection-handle-size) / 2));
            --rotate-handle-size: 10px;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            touch-action: none;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid rgba(0,0,0,0.06);
            z-index: 100;
            flex-shrink: 0;
        }

        .logo {
            font-family: 'Comfortaa', cursive;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo svg {
            width: 32px;
            height: 24px;
        }

        .logo span {
            letter-spacing: -0.5px;
        }

        .header-actions {
            display: flex;
            gap: clamp(4px, 1.2vw, 8px);
            align-items: center;
        }

        .save-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
            box-shadow: 0 0 0 2px rgba(0,0,0,0.08);
        }

        .save-indicator.saving {
            background: var(--accent-orange);
        }

        .save-indicator.saved {
            background: var(--accent-green);
        }

        #status-bar {
            display: none;
        }

        #btn-add-page {
            display: none;
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            border: none;
            border-radius: var(--radius-md);
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
            flex: 0 0 auto;
        }

        .btn-icon {
            padding: 10px;
            min-width: 44px;
            min-height: 44px;
        }

        .btn-icon-square {
            width: var(--header-btn-size);
            height: var(--header-btn-size);
            padding: 0;
        }

        .btn-primary {
            background: var(--text-primary);
            color: white;
        }

        .btn-primary:hover {
            background: #333;
        }

        .btn-warning {
            background: var(--accent-orange);
            color: white;
        }

        .btn-warning:hover {
            background: #d36f33;
        }

        .btn-secondary {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: rgba(0,0,0,0.1);
        }

        .btn svg {
            width: 18px;
            height: 18px;
        }

        #canvas-viewport {
            flex: 1;
            overflow: hidden;
            background: #2c2c2c;
            position: relative;
            cursor: grab;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px;
            gap: 30px;
        }

        .page-wrapper {
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border-radius: 2px;
            overflow: hidden;
            flex-shrink: 0;
            background: white;
        }

        .page-wrapper.new-page {
            animation: pageFadeIn 0.5s ease;
        }

        @keyframes pageFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .page-canvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }

        .lasso-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .cursor-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed rgba(0, 47, 217, 0.55);
            border-radius: 8px;
            box-sizing: border-box;
            pointer-events: auto;
            touch-action: none;
            background: rgba(0, 47, 217, 0.03);
        }

        .selection-box.hidden {
            display: none;
        }

        .selection-box .selection-handle,
        .selection-box .rotate-handle {
            position: absolute;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0, 47, 217, 0.7);
            box-shadow: none;
            opacity: 0.9;
        }

        .selection-box .selection-handle {
            width: var(--selection-handle-size);
            height: var(--selection-handle-size);
        }

        .selection-box .rotate-handle {
            width: var(--rotate-handle-size);
            height: var(--rotate-handle-size);
        }

        .selection-box .selection-handle.edge {
            border-radius: 3px;
        }

        .selection-box .handle-n { top: var(--selection-handle-offset); left: 50%; transform: translate(-50%, -50%); cursor: ns-resize; }
        .selection-box .handle-s { bottom: var(--selection-handle-offset); left: 50%; transform: translate(-50%, 50%); cursor: ns-resize; }
        .selection-box .handle-e { right: var(--selection-handle-offset); top: 50%; transform: translate(50%, -50%); cursor: ew-resize; }
        .selection-box .handle-w { left: var(--selection-handle-offset); top: 50%; transform: translate(-50%, -50%); cursor: ew-resize; }
        .selection-box .handle-ne { right: var(--selection-handle-offset); top: var(--selection-handle-offset); transform: translate(50%, -50%); cursor: nesw-resize; }
        .selection-box .handle-nw { left: var(--selection-handle-offset); top: var(--selection-handle-offset); transform: translate(-50%, -50%); cursor: nwse-resize; }
        .selection-box .handle-se { right: var(--selection-handle-offset); bottom: var(--selection-handle-offset); transform: translate(50%, 50%); cursor: nwse-resize; }
        .selection-box .handle-sw { left: var(--selection-handle-offset); bottom: var(--selection-handle-offset); transform: translate(-50%, 50%); cursor: nesw-resize; }

        .selection-box .selection-rotate-line {
            position: absolute;
            width: 1px;
            height: 10px;
            background: rgba(0, 47, 217, 0.7);
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
        }

        .selection-box .rotate-handle {
            top: -28px;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }

        #add-page-indicator {
            position: absolute;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px dashed rgba(255, 222, 0, 0.95);
            color: rgba(255, 222, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            background: rgba(20,20,20,0.25);
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        }

        .page-number {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            pointer-events: none;
            opacity: 0.6;
        }

        #toolbar {
            position: fixed;
            left: 20px;
            top: 50%;
            --toolbar-scale: 1;
            --toolbar-translate: -50%;
            transform: translateY(var(--toolbar-translate)) scale(var(--toolbar-scale));
            transform-origin: top left;
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-medium);
            padding: var(--toolbar-padding);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
            transition: border-radius 0.2s ease;
            touch-action: none;
            user-select: none;
        }

        #toolbar.horizontal {
            flex-direction: row;
            flex-wrap: nowrap;
            justify-content: center;
            align-items: center;
        }

        #toolbar.snapping {
            transition: left 0.2s ease, top 0.2s ease, right 0.2s ease, bottom 0.2s ease;
        }

        #toolbar-handle {
            width: var(--handle-width);
            height: var(--handle-height);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            color: var(--text-secondary);
            border-radius: var(--radius-sm);
            transition: background 0.2s;
        }

        #toolbar-handle:hover {
            background: rgba(0,0,0,0.05);
        }

        #toolbar-handle:active {
            cursor: grabbing;
        }

        #toolbar-handle svg {
            width: var(--icon-size);
            height: var(--icon-size);
        }

        #toolbar.horizontal #toolbar-handle {
            width: var(--handle-height);
            height: var(--handle-width);
        }

        #toolbar.horizontal #toolbar-handle svg {
            transform: rotate(90deg);
        }

        .tool-btn {
            width: var(--tool-size);
            height: var(--tool-size);
            border: none;
            border-radius: var(--radius-md);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
            touch-action: manipulation;
            flex: 0 0 auto;
        }

        .tool-btn:hover {
            background: rgba(0,0,0,0.05);
        }

        .tool-btn.active {
            background: var(--accent-yellow);
        }

        .tool-btn svg {
            width: var(--icon-size);
            height: var(--icon-size);
        }

        .tool-btn.size-btn {
            width: calc(var(--tool-size) * 0.7);
            height: calc(var(--tool-size) * 0.7);
        }

        .size-dot {
            display: inline-block;
            border-radius: 50%;
            background: var(--text-primary);
            opacity: 0.7;
        }

        .size-dot.sm { width: 6px; height: 6px; }
        .size-dot.md { width: 10px; height: 10px; }
        .size-dot.lg { width: 14px; height: 14px; }

        .color-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid transparent;
        }

        .tool-btn.active .color-dot {
            border-color: var(--text-primary);
        }

        .tool-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tool-btn:disabled:hover {
            background: transparent;
        }

        .tool-divider {
            height: 1px;
            background: rgba(0,0,0,0.1);
            margin: 4px 0;
            width: calc(var(--tool-size) * 0.6);
            align-self: center;
        }

        #toolbar.horizontal .tool-divider {
            width: 1px;
            height: calc(var(--tool-size) * 0.6);
            margin: 0 4px;
        }

        .eraser-menu {
            position: fixed;
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-medium);
            z-index: 1500;
            min-width: 180px;
        }

        .eraser-menu.visible {
            display: flex;
        }

        .eraser-menu-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .eraser-menu-options {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .eraser-menu .tool-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
        }

        .eraser-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .eraser-toggle input {
            appearance: none;
            width: 38px;
            height: 20px;
            border-radius: 999px;
            background: rgba(0,0,0,0.15);
            position: relative;
            outline: none;
            transition: background 0.2s ease;
            cursor: pointer;
        }

        .eraser-toggle input::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }

        .eraser-toggle input:checked {
            background: var(--text-primary);
        }

        .eraser-toggle input:checked::after {
            transform: translateX(18px);
        }

        #status-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-medium);
            padding: 8px 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.2vw, 8px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #status-bar.visible {
            opacity: 1;
        }

        #status-bar .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-medium);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal h2 {
            font-size: 1.25rem;
            margin-bottom: 16px;
        }

        .modal-actions {
            display: flex;
            gap: clamp(4px, 1.2vw, 8px);
            margin-top: 20px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        #file-input, #pdf-input {
            display: none;
        }

        #pages-panel {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background: var(--bg-secondary);
            box-shadow: -4px 0 30px rgba(0,0,0,0.15);
            z-index: 1500;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        #pages-panel.visible {
            right: 0;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0,0,0,0.08);
        }

        .panel-header h2 {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .panel-close {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .panel-close:hover {
            background: rgba(0,0,0,0.05);
        }

        .panel-close svg {
            width: 20px;
            height: 20px;
        }

        .pages-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .page-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .page-item:hover {
            background: rgba(0,0,0,0.06);
        }

        .page-thumbnail {
            width: 50px;
            height: 70px;
            background: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .page-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .page-info {
            flex: 1;
            min-width: 0;
        }

        .page-info h3 {
            font-size: 0.9375rem;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .page-info p {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .page-actions {
            display: flex;
            gap: 4px;
        }

        .page-action-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            color: var(--text-secondary);
        }

        .page-action-btn:hover {
            background: rgba(0,0,0,0.08);
            color: var(--text-primary);
        }

        .page-action-btn.delete:hover {
            background: rgba(255,59,48,0.1);
            color: #ff3b30;
        }

        .page-action-btn svg {
            width: 18px;
            height: 18px;
        }

        .panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: 1400;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .panel-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-danger .btn-primary {
            background: #ff3b30;
        }

        .modal-danger .btn-primary:hover {
            background: #e6352b;
        }

        .modal-warning .btn-primary {
            background: var(--accent-orange);
        }

        .modal-warning .btn-primary:hover {
            background: #d36f33;
        }

        .saving .status-dot {
            animation: pulse 1s infinite;
            background: var(--accent-yellow);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 768px) {
            #toolbar {
                left: 10px;
            }

            #canvas-container {
                padding: 20px;
            }
        }

        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-text {
            color: white;
            margin-top: 16px;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <div class="logo">
                <svg viewBox="0 0 40 24" fill="none">
                    <path d="M4 22 L20 6 L36 22" stroke="#E07A3C" stroke-width="4.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                </svg>
                <span>inhouse notes</span>
            </div>
            <div class="header-actions">
                <div class="save-indicator saved" id="save-indicator" title="Saved" aria-label="Saved"></div>
                <button class="btn btn-warning btn-icon-square" id="btn-reset-document" title="Start new document" aria-label="Start new document">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="1 4 1 10 7 10"/>
                        <path d="M3.51 15a8.5 8.5 0 1 0 2.13-9.36L1 10"/>
                    </svg>
                </button>
                <button class="btn btn-secondary btn-icon-square" id="btn-fullscreen" title="Fullscreen" aria-label="Fullscreen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="4 9 4 4 9 4"/>
                        <polyline points="15 4 20 4 20 9"/>
                        <polyline points="20 15 20 20 15 20"/>
                        <polyline points="9 20 4 20 4 15"/>
                    </svg>
                </button>
                <button class="btn btn-secondary btn-icon-square" id="btn-edit-pages" title="Manage Pages" aria-label="Manage Pages">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                </button>
                <button class="btn btn-secondary btn-icon-square" id="btn-import-pdf" title="Import PDF" aria-label="Import PDF">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <polyline points="9 15 12 12 15 15"/>
                    </svg>
                </button>
                <button class="btn btn-primary btn-icon-square" id="btn-export-pdf" title="Export PDF" aria-label="Export PDF">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <polyline points="9 15 12 18 15 15"/>
                    </svg>
                </button>
            </div>
        </header>

        <div id="canvas-viewport">
            <div id="canvas-container"></div>
        </div>

        <div id="toolbar">
            <div id="toolbar-handle" title="Drag to move">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                    <circle cx="9" cy="6" r="1.5" fill="currentColor"/>
                    <circle cx="15" cy="6" r="1.5" fill="currentColor"/>
                    <circle cx="9" cy="12" r="1.5" fill="currentColor"/>
                    <circle cx="15" cy="12" r="1.5" fill="currentColor"/>
                    <circle cx="9" cy="18" r="1.5" fill="currentColor"/>
                    <circle cx="15" cy="18" r="1.5" fill="currentColor"/>
                </svg>
            </div>
            <div class="tool-divider"></div>
            <button class="tool-btn" data-tool="pen" data-color="#4D4D4D" data-width="2" title="Black Pen">
                <svg viewBox="0 0 24 24" fill="none">
                    <path d="M4 20h4l11-11a2 2 0 0 0 0-2.83l-1.17-1.17a2 2 0 0 0-2.83 0L4 16v4z" fill="#4D4D4D" stroke="#4D4D4D" stroke-width="1.5" stroke-linejoin="round"/>
                    <path d="M13.5 6.5l4 4" stroke="white" stroke-width="1" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="tool-btn active" data-tool="pen" data-color="#002FD9" data-width="2" title="Blue Pen">
                <svg viewBox="0 0 24 24" fill="none">
                    <path d="M4 20h4l11-11a2 2 0 0 0 0-2.83l-1.17-1.17a2 2 0 0 0-2.83 0L4 16v4z" fill="#002FD9" stroke="#002FD9" stroke-width="1.5" stroke-linejoin="round"/>
                    <path d="M13.5 6.5l4 4" stroke="white" stroke-width="1" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="pen" data-color="#E81010" data-width="2" title="Red Pen">
                <svg viewBox="0 0 24 24" fill="none">
                    <path d="M4 20h4l11-11a2 2 0 0 0 0-2.83l-1.17-1.17a2 2 0 0 0-2.83 0L4 16v4z" fill="#E81010" stroke="#E81010" stroke-width="1.5" stroke-linejoin="round"/>
                    <path d="M13.5 6.5l4 4" stroke="white" stroke-width="1" stroke-linecap="round"/>
                </svg>
            </button>
            <div class="tool-divider"></div>
            <button class="tool-btn" data-tool="highlighter" data-color="#ffde00" data-width="25" title="Highlighter">
                <svg viewBox="0 0 24 24" fill="none">
                    <rect x="6" y="3" width="6" height="14" rx="1" fill="#ffde00" stroke="#1a1a1a" stroke-width="1.2"/>
                    <path d="M6 17l3 4 3-4" fill="#ffde00" stroke="#1a1a1a" stroke-width="1.2" stroke-linejoin="round"/>
                    <rect x="7" y="5" width="4" height="3" fill="#fff" opacity="0.5" rx="0.5"/>
                </svg>
            </button>
            <div class="tool-divider"></div>
            <button class="tool-btn" data-tool="eraser" id="btn-eraser" title="Eraser">
                <svg viewBox="0 0 24 24" fill="none">
                    <rect x="3" y="10" width="18" height="8" rx="2" fill="#f5f5f5" stroke="currentColor" stroke-width="1.5"/>
                    <rect x="3" y="10" width="7" height="8" rx="2" fill="#ffb6c1" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M3 18h18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="lasso" title="Lasso Select">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M6 8c0-2.5 2.7-4 6-4s6 1.5 6 4-2.7 4-6 4-6-1.5-6-4z"/>
                    <path d="M12 12c0 3-2 5-5 6"/>
                </svg>
            </button>
            <div class="tool-divider"></div>
            <button class="tool-btn" id="btn-undo" title="Undo (Ctrl+Z)" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                    <path d="M7 6l-4 4 4 4"/>
                </svg>
            </button>
            <button class="tool-btn" id="btn-redo" title="Redo (Ctrl+Y)" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                    <path d="M17 6l4 4-4 4"/>
                </svg>
            </button>
        </div>

        <div id="eraser-menu" class="eraser-menu" aria-hidden="true">
            <div class="eraser-menu-title">Eraser size</div>
            <div class="eraser-menu-options">
                <button class="tool-btn size-btn" data-eraser-size="12" title="Small">
                    <span class="size-dot sm"></span>
                </button>
                <button class="tool-btn size-btn active" data-eraser-size="22" title="Medium">
                    <span class="size-dot md"></span>
                </button>
                <button class="tool-btn size-btn" data-eraser-size="32" title="Large">
                    <span class="size-dot lg"></span>
                </button>
            </div>
            <label class="eraser-toggle" for="eraser-stroke-toggle">
                <span>Stroke eraser</span>
                <input type="checkbox" id="eraser-stroke-toggle">
            </label>
        </div>

        <div id="status-bar">
            <div class="status-dot"></div>
            <span id="status-text">Saved</span>
        </div>
    </div>

    <div class="modal-overlay" id="modal-delete-page">
        <div class="modal modal-danger">
            <h2>Delete page?</h2>
            <p>This action will delete page <strong id="delete-page-number">1</strong> and all its strokes. This cannot be undone.</p>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="modal-delete-cancel">Cancel</button>
                <button class="btn btn-primary" id="modal-delete-confirm">Delete</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-reset-document">
        <div class="modal modal-warning">
            <h2>Start new document?</h2>
            <p>This action will clear all pages and strokes and start a fresh document. This cannot be undone.</p>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="modal-reset-cancel">Cancel</button>
                <button class="btn btn-primary" id="modal-reset-confirm">Start over</button>
            </div>
        </div>
    </div>

    <div class="panel-overlay" id="panel-overlay"></div>

    <div id="pages-panel">
        <div class="panel-header">
            <h2>Manage Pages</h2>
            <button class="panel-close" id="panel-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        <div class="pages-list" id="pages-list"></div>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Loading PDF...</div>
    </div>

    <input type="file" id="pdf-input" accept=".pdf">

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // SVG Background
        const svgString = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 29.7" width="21cm" height="29.7cm">
            <defs>
                <filter id="softBlur" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0.02" />
                </filter>
                <pattern id="dotGrid" x="1.75" y="1.68" width="0.5" height="0.5" patternUnits="userSpaceOnUse">
                    <circle cx="0.25" cy="0.25" r="0.035" fill="#a8a8a8" filter="url(#softBlur)" />
                </pattern>
            </defs>
            <!-- A4 Background -->
            <rect x="0" y="0" width="21" height="29.7" fill="white" />
            <!-- Main Yellow Frame -->
            <rect x="1.5" y="1.43" width="18" height="27" rx="0.03" ry="0.03" fill="none" stroke="#ffde00" stroke-width="0.06" />
            <!-- Dot Grid Area -->
            <rect x="1.75" y="1.68" width="17.5" height="25.5" fill="url(#dotGrid)" />
            <!-- Footer -->
            <g stroke="#ffde00" stroke-width="0.06" fill="none">
                <rect x="2.0" y="27.43" width="8.0" height="0.5" rx="0.03" ry="0.03" />
                <path d="M 2.5 27.43 v 0.5 M 3.0 27.43 v 0.5 M 3.5 27.43 v 0.5 M 4.0 27.43 v 0.5 M 4.5 27.43 v 0.5 M 5.0 27.43 v 0.5 M 5.5 27.43 v 0.5 M 6.0 27.43 v 0.5 M 6.5 27.43 v 0.5 M 7.0 27.43 v 0.5 M 7.5 27.43 v 0.5 M 8.0 27.43 v 0.5 M 8.5 27.43 v 0.5 M 9.0 27.43 v 0.5 M 9.5 27.43 v 0.5" />
                <rect x="11.0" y="27.43" width="8.0" height="0.5" rx="0.03" ry="0.03" />
                <path d="M 11.5 27.43 v 0.5 M 12.0 27.43 v 0.5 M 12.5 27.43 v 0.5 M 13.0 27.43 v 0.5 M 13.5 27.43 v 0.5 M 14.0 27.43 v 0.5 M 14.5 27.43 v 0.5 M 15.0 27.43 v 0.5 M 15.5 27.43 v 0.5 M 16.0 27.43 v 0.5 M 16.5 27.43 v 0.5 M 17.0 27.43 v 0.5 M 17.5 27.43 v 0.5 M 18.0 27.43 v 0.5 M 18.5 27.43 v 0.5" />
            </g>
            <!-- Footer Colors -->
            <g stroke="#ffde00" stroke-width="0.06">
                <circle cx="10.125" cy="27.68" r="0.125" fill="#ff0000" />
                <circle cx="10.375" cy="27.68" r="0.125" fill="#000000" />
                <circle cx="10.625" cy="27.68" r="0.125" fill="#0000ff" />
                <circle cx="10.875" cy="27.68" r="0.125" fill="#6eff12" />
            </g>
        </svg>`;
        const SVG_BACKGROUND = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgString)}`;

        // A4 dimensions - using 2x resolution for crisp drawing
        const A4_WIDTH = 794;
        const A4_HEIGHT = 1123;
        const CANVAS_SCALE = Math.min(4, Math.max(2, Math.round((window.devicePixelRatio || 2) * 2))); // High DPI
        const OVERSCROLL_THRESHOLD = 360;
        const OVERSCROLL_FRICTION = 0.24;
        const OVERSCROLL_MARGIN = 100;
        const CREATE_PAGE_MIN_BOTTOM_RATIO = 0.45;

        // App State
        const state = {
            pages: [],
            currentTool: 'pen',
            currentColor: '#002FD9',
            currentWidth: 2,
            eraserWidth: 22,
            eraserMode: 'area',
            zoom: 1,
            panX: 0,
            panY: 0,
            overscrollY: 0,
            pageCreateLocked: false,
            pendingPageCreate: false,
            isPanning: false,
            isScrolling: false,
            scrollLocked: false,
            lastPanX: 0,
            lastPanY: 0,
            panStartX: 0,
            panStartY: 0,
            initialPinchDist: 0,
            initialScale: 1,
            initialPanX: 0,
            initialPanY: 0,
            pinchCenterX: 0,
            pinchCenterY: 0,
            activePointers: new Map(),
            saveTimeout: null,
            selection: {
                pageIndex: null,
                strokeIndices: []
            },
            selectionTransform: null,
            // Undo/Redo history
            history: [],
            historyIndex: -1,
            maxHistory: 10
        };

        // DOM Elements
        const canvasContainer = document.getElementById('canvas-container');
        const canvasViewport = document.getElementById('canvas-viewport');
        const toolbar = document.getElementById('toolbar');
        const eraserMenu = document.getElementById('eraser-menu');
        const eraserToggle = document.getElementById('eraser-stroke-toggle');
        const eraserButton = document.getElementById('btn-eraser');
        const statusBar = document.getElementById('status-bar');
        const statusText = document.getElementById('status-text');
        const pdfInput = document.getElementById('pdf-input');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        let overscrollResetTimeout = null;
        let wheelReleaseTimeout = null;
        const addPageIndicator = document.createElement('div');
        addPageIndicator.id = 'add-page-indicator';
        addPageIndicator.textContent = '+';
        canvasContainer.appendChild(addPageIndicator);

        // Initialize
        function init() {
            loadFromStorage();
            bakeLegacyEraserAreaStrokes();
            if (state.pages.length === 0) {
                addPage();
            } else {
                renderAllPages();
            }
            setupEventListeners();
            syncEraserMenuState();
            
            // Center page after DOM is ready
            setTimeout(() => {
                centerViewOnTop();
            }, 100);
        }

        // Center view on top of first page
        function centerViewOnTop() {
            const viewportRect = canvasViewport.getBoundingClientRect();
            const pageWidth = A4_WIDTH * state.zoom;
            const padding = 30 * state.zoom;
            
            // Center horizontally
            state.panX = (viewportRect.width - pageWidth) / 2 - padding;
            // Show top with some margin
            state.panY = 20;
            state.overscrollY = 0;
            if (overscrollResetTimeout) {
                clearTimeout(overscrollResetTimeout);
                overscrollResetTimeout = null;
            }
            updateAddPageIndicator();
            
            updateTransform();
        }

        // Add a new blank page
        function addPage(backgroundImage = null, animate = false) {
            const pageIndex = state.pages.length;
            const pageData = {
                strokes: [],
                backgroundImage: backgroundImage // Base64 image for PDF pages
            };
            state.pages.push(pageData);
            createPageElement(pageIndex, animate);
            saveToStorage();
            showStatus('Page added');
        }

        // Create page DOM element
        function createPageElement(pageIndex, animate = false) {
            const wrapper = document.createElement('div');
            wrapper.className = 'page-wrapper';
            wrapper.dataset.page = pageIndex;
            wrapper.style.width = `${A4_WIDTH}px`;
            wrapper.style.height = `${A4_HEIGHT}px`;
            if (animate) {
                wrapper.classList.add('new-page');
                setTimeout(() => wrapper.classList.remove('new-page'), 600);
            }

            const canvas = document.createElement('canvas');
            canvas.className = 'page-canvas';
            canvas.width = A4_WIDTH * CANVAS_SCALE;
            canvas.height = A4_HEIGHT * CANVAS_SCALE;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.dataset.page = pageIndex;

            // Set background
            const page = state.pages[pageIndex];
            if (page.backgroundImage) {
                canvas.style.backgroundImage = `url("${page.backgroundImage}")`;
            } else {
                canvas.style.backgroundImage = `url("${SVG_BACKGROUND}")`;
            }
            canvas.style.backgroundSize = 'cover';

            const pageNumber = document.createElement('div');
            pageNumber.className = 'page-number';
            pageNumber.textContent = `${pageIndex + 1}`;

            wrapper.appendChild(canvas);
            const lassoOverlay = document.createElement('canvas');
            lassoOverlay.className = 'lasso-overlay';
            lassoOverlay.dataset.page = pageIndex;
            lassoOverlay.width = A4_WIDTH * CANVAS_SCALE;
            lassoOverlay.height = A4_HEIGHT * CANVAS_SCALE;
            lassoOverlay.style.width = '100%';
            lassoOverlay.style.height = '100%';
            wrapper.appendChild(lassoOverlay);

            const cursorOverlay = document.createElement('canvas');
            cursorOverlay.className = 'cursor-overlay';
            cursorOverlay.dataset.page = pageIndex;
            cursorOverlay.width = A4_WIDTH * CANVAS_SCALE;
            cursorOverlay.height = A4_HEIGHT * CANVAS_SCALE;
            cursorOverlay.style.width = '100%';
            cursorOverlay.style.height = '100%';
            wrapper.appendChild(cursorOverlay);

            const selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box hidden';
            selectionBox.dataset.page = pageIndex;
            selectionBox.innerHTML = `
                <div class="selection-rotate-line"></div>
                <div class="rotate-handle" data-handle="rotate"></div>
                <div class="selection-handle edge handle-n" data-handle="n"></div>
                <div class="selection-handle edge handle-s" data-handle="s"></div>
                <div class="selection-handle edge handle-e" data-handle="e"></div>
                <div class="selection-handle edge handle-w" data-handle="w"></div>
                <div class="selection-handle handle-ne" data-handle="ne"></div>
                <div class="selection-handle handle-nw" data-handle="nw"></div>
                <div class="selection-handle handle-se" data-handle="se"></div>
                <div class="selection-handle handle-sw" data-handle="sw"></div>
            `;
            wrapper.appendChild(selectionBox);
            wrapper.appendChild(pageNumber);
            canvasContainer.appendChild(wrapper);

            // Setup context with scale
            const ctx = canvas.getContext('2d');
            ctx.scale(CANVAS_SCALE, CANVAS_SCALE);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            setupCanvasEvents(canvas, pageIndex);
            setupSelectionBoxEvents(selectionBox, pageIndex);
            redrawPage(pageIndex);
        }

        // Setup canvas pointer events with improved drawing
        function setupCanvasEvents(canvas, pageIndex) {
            let isDrawing = false;
            let currentStroke = null;
            let erasedStrokes = []; // For eraser tools to track what was erased
            let areaEraseBefore = null;
            let areaEraseChanged = false;
            let isLassoing = false;
            let lassoPoints = [];
            const wrapper = canvas.closest('.page-wrapper');
            const lassoCanvas = wrapper ? wrapper.querySelector('.lasso-overlay') : null;

            canvas.addEventListener('pointerdown', (e) => {
                if (state.currentTool === 'lasso') {
                    if (e.pointerType !== 'pen') return;
                    if (!lassoCanvas) return;
                    isLassoing = true;
                    lassoPoints = [];
                    clearSelection();
                    const pos = getCanvasPos(canvas, e);
                    lassoPoints.push(pos);
                    drawLassoPath(lassoCanvas, lassoPoints);
                    canvas.setPointerCapture(e.pointerId);
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Only pen draws
                if (e.pointerType !== 'pen') return;
                clearSelection();

                e.preventDefault();
                canvas.setPointerCapture(e.pointerId);

                const pos = getCanvasPos(canvas, e);
                const pressure = e.pressure || 0.5;

                isDrawing = true;
                erasedStrokes = [];

                if (state.currentTool === 'eraser-stroke') {
                    // Check if we hit a stroke to erase
                    eraseStrokeAtPoint(pageIndex, pos.x, pos.y, erasedStrokes, state.eraserWidth / 2);
                    drawEraserPreview(pageIndex, pos);
                } else if (state.currentTool === 'eraser-area') {
                    areaEraseBefore = JSON.parse(JSON.stringify(state.pages[pageIndex].strokes));
                    areaEraseChanged = eraseAreaAtPoint(pageIndex, pos.x, pos.y, state.eraserWidth / 2) || areaEraseChanged;
                    drawEraserPreview(pageIndex, pos);
                } else {
                    currentStroke = {
                        tool: state.currentTool,
                        color: state.currentColor,
                        width: state.currentWidth,
                        points: [{ x: pos.x, y: pos.y, p: pressure }]
                    };

                    const ctx = canvas.getContext('2d');
                    setupContext(ctx, state.currentTool, state.currentColor, state.currentWidth);
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                }
            });

            canvas.addEventListener('pointermove', (e) => {
                if (isLassoing) {
                    const pos = getCanvasPos(canvas, e);
                    lassoPoints.push(pos);
                    drawLassoPath(lassoCanvas, lassoPoints);
                    return;
                }

                if (!isDrawing || e.pointerType !== 'pen') return;

                const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
                const ctx = canvas.getContext('2d');

                events.forEach(ev => {
                    const pos = getCanvasPos(canvas, ev);
                    const pressure = ev.pressure || 0.5;

                    if (state.currentTool === 'eraser-stroke') {
                        eraseStrokeAtPoint(pageIndex, pos.x, pos.y, erasedStrokes, state.eraserWidth / 2);
                        drawEraserPreview(pageIndex, pos);
                    } else if (state.currentTool === 'eraser-area') {
                        areaEraseChanged = eraseAreaAtPoint(pageIndex, pos.x, pos.y, state.eraserWidth / 2) || areaEraseChanged;
                        drawEraserPreview(pageIndex, pos);
                    } else {
                        if (state.currentTool === 'pen') {
                            ctx.lineWidth = state.currentWidth * (0.5 + pressure);
                        }

                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);

                        currentStroke.points.push({ x: pos.x, y: pos.y, p: pressure });
                    }
                });
            });

            const endDrawing = (e) => {
                if (isLassoing) {
                    isLassoing = false;
                    if (lassoPoints.length > 2) {
                        selectStrokesWithLasso(pageIndex, lassoPoints);
                    } else {
                        clearSelection();
                    }
                    clearLassoCanvas(pageIndex);
                    lassoPoints = [];
                    if (canvas.hasPointerCapture && canvas.hasPointerCapture(e.pointerId)) {
                        canvas.releasePointerCapture(e.pointerId);
                    }
                    return;
                }

                if (!isDrawing) return;
                isDrawing = false;

                if (state.currentTool === 'eraser-stroke') {
                    // Save erased strokes to history
                    if (erasedStrokes.length > 0) {
                        saveToHistory({
                            type: 'erase-strokes',
                            pageIndex: pageIndex,
                            strokes: erasedStrokes
                        });
                        scheduleSave();
                    }
                    clearEraserPreview(pageIndex);
                } else if (state.currentTool === 'eraser-area') {
                    if (areaEraseChanged && areaEraseBefore) {
                        const after = JSON.parse(JSON.stringify(state.pages[pageIndex].strokes));
                        saveToHistory({
                            type: 'erase-area',
                            pageIndex: pageIndex,
                            before: areaEraseBefore,
                            after
                        });
                        scheduleSave();
                    }
                    clearEraserPreview(pageIndex);
                } else if (currentStroke && currentStroke.points.length > 0) {
                    state.pages[pageIndex].strokes.push(currentStroke);
                    saveToHistory({
                        type: 'add-stroke',
                        pageIndex: pageIndex,
                        stroke: JSON.parse(JSON.stringify(currentStroke))
                    });
                    scheduleSave();
                    redrawPage(pageIndex);
                }
                clearEraserPreview(pageIndex);

                currentStroke = null;
                erasedStrokes = [];
                areaEraseBefore = null;
                areaEraseChanged = false;
            };

            canvas.addEventListener('pointerup', endDrawing);
            canvas.addEventListener('pointercancel', endDrawing);
            canvas.addEventListener('pointerleave', endDrawing);
        }

        function clearLassoCanvas(pageIndex) {
            const lassoCanvas = document.querySelector(`.lasso-overlay[data-page="${pageIndex}"]`);
            if (!lassoCanvas) return;
            const ctx = lassoCanvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
        }

        function drawLassoPath(lassoCanvas, points) {
            if (!lassoCanvas || points.length === 0) return;
            const ctx = lassoCanvas.getContext('2d');
            ctx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);
            ctx.strokeStyle = '#002FD9';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawEraserPreview(pageIndex, pos) {
            const previewCanvas = document.querySelector(`.cursor-overlay[data-page="${pageIndex}"]`);
            if (!previewCanvas) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);
            const radius = state.eraserWidth / 2;
            ctx.strokeStyle = 'rgba(0,0,0,0.45)';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fill();
        }

        function clearEraserPreview(pageIndex) {
            const previewCanvas = document.querySelector(`.cursor-overlay[data-page="${pageIndex}"]`);
            if (!previewCanvas) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }

        function clearSelection() {
            if (state.selection.pageIndex !== null) {
                const box = document.querySelector(`.selection-box[data-page="${state.selection.pageIndex}"]`);
                if (box) {
                    box.classList.add('hidden');
                }
            }
            document.querySelectorAll('.lasso-overlay').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
            state.selection.pageIndex = null;
            state.selection.strokeIndices = [];
        }

        function selectStrokesWithLasso(pageIndex, polygon) {
            const page = state.pages[pageIndex];
            if (!page) return;
            const selected = [];
            for (let i = 0; i < page.strokes.length; i++) {
                const stroke = page.strokes[i];
                if (stroke.tool && stroke.tool.startsWith('eraser')) continue;
                if (strokeIntersectsPolygon(stroke, polygon)) {
                    selected.push(i);
                }
            }
            if (selected.length === 0) {
                clearSelection();
                return;
            }
            state.selection.pageIndex = pageIndex;
            state.selection.strokeIndices = selected;
            updateSelectionBox();
        }

        function strokeIntersectsPolygon(stroke, polygon) {
            for (const point of stroke.points) {
                if (pointInPolygon(point, polygon)) {
                    return true;
                }
            }
            return false;
        }

        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 0.00001) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getSelectionBounds(pageIndex, indices) {
            const page = state.pages[pageIndex];
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            indices.forEach(index => {
                const stroke = page.strokes[index];
                if (!stroke) return;
                stroke.points.forEach(pt => {
                    minX = Math.min(minX, pt.x);
                    minY = Math.min(minY, pt.y);
                    maxX = Math.max(maxX, pt.x);
                    maxY = Math.max(maxY, pt.y);
                });
            });
            if (!isFinite(minX)) return null;
            return {
                minX,
                minY,
                maxX,
                maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        function updateSelectionBox() {
            if (state.selection.pageIndex === null) return;
            const bounds = getSelectionBounds(state.selection.pageIndex, state.selection.strokeIndices);
            const box = document.querySelector(`.selection-box[data-page="${state.selection.pageIndex}"]`);
            if (!box || !bounds) return;
            box.classList.remove('hidden');
            box.style.left = bounds.minX + 'px';
            box.style.top = bounds.minY + 'px';
            box.style.width = bounds.width + 'px';
            box.style.height = bounds.height + 'px';
        }

        function getPagePosFromEvent(pageIndex, e) {
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (!wrapper) return { x: 0, y: 0 };
            const rect = wrapper.getBoundingClientRect();
            const scaleX = A4_WIDTH / rect.width;
            const scaleY = A4_HEIGHT / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function captureStrokes(pageIndex, indices) {
            const page = state.pages[pageIndex];
            return indices.map(index => ({
                index,
                stroke: JSON.parse(JSON.stringify(page.strokes[index]))
            }));
        }

        function applyTransformToSelection(originalStrokes, transform, center, pageIndex) {
            const page = state.pages[pageIndex];
            const cos = Math.cos(transform.rotation);
            const sin = Math.sin(transform.rotation);
            originalStrokes.forEach(item => {
                const stroke = item.stroke;
                const updated = {
                    tool: stroke.tool,
                    color: stroke.color,
                    width: stroke.width,
                    points: stroke.points.map(pt => {
                        let x = pt.x - center.x;
                        let y = pt.y - center.y;
                        x *= transform.scaleX;
                        y *= transform.scaleY;
                        const rx = x * cos - y * sin;
                        const ry = x * sin + y * cos;
                        return {
                            x: center.x + rx + transform.translateX,
                            y: center.y + ry + transform.translateY,
                            p: pt.p
                        };
                    })
                };
                page.strokes[item.index] = updated;
            });
            redrawPage(pageIndex);
        }

        function setupSelectionBoxEvents(selectionBox, pageIndex) {
            selectionBox.addEventListener('pointerdown', (e) => {
                if (state.currentTool !== 'lasso') return;
                if (state.selection.pageIndex !== pageIndex) return;
                const target = e.target;
                if (target.classList.contains('rotate-handle')) {
                    startSelectionTransform(pageIndex, 'rotate', 'rotate', e);
                } else if (target.classList.contains('selection-handle')) {
                    startSelectionTransform(pageIndex, 'scale', target.dataset.handle, e);
                } else {
                    startSelectionTransform(pageIndex, 'move', 'move', e);
                }
                e.preventDefault();
                e.stopPropagation();
            });
        }

        function startSelectionTransform(pageIndex, mode, handle, e) {
            const bounds = getSelectionBounds(pageIndex, state.selection.strokeIndices);
            if (!bounds) return;
            const center = {
                x: bounds.minX + bounds.width / 2,
                y: bounds.minY + bounds.height / 2
            };
            const startPos = getPagePosFromEvent(pageIndex, e);
            const originalStrokes = captureStrokes(pageIndex, state.selection.strokeIndices);
            const startAngle = Math.atan2(startPos.y - center.y, startPos.x - center.x);
            state.selectionTransform = {
                pageIndex,
                mode,
                handle,
                bounds,
                center,
                startPos,
                startAngle,
                originalStrokes,
                pointerId: e.pointerId
            };
        }

        function onSelectionPointerMove(e) {
            if (!state.selectionTransform) return;
            if (e.pointerId !== state.selectionTransform.pointerId) return;
            const { pageIndex, mode, handle, bounds, center, startPos, startAngle, originalStrokes } = state.selectionTransform;
            const pos = getPagePosFromEvent(pageIndex, e);
            const transform = {
                translateX: 0,
                translateY: 0,
                scaleX: 1,
                scaleY: 1,
                rotation: 0
            };

            if (mode === 'move') {
                transform.translateX = pos.x - startPos.x;
                transform.translateY = pos.y - startPos.y;
            } else if (mode === 'scale') {
                const halfW = Math.max(10, bounds.width / 2);
                const halfH = Math.max(10, bounds.height / 2);
                const dx = (pos.x - center.x) / halfW;
                const dy = (pos.y - center.y) / halfH;
                const isCorner = ['ne', 'nw', 'se', 'sw'].includes(handle);
                if (isCorner) {
                    const currentDist = Math.hypot(pos.x - center.x, pos.y - center.y);
                    const baseDist = Math.hypot(halfW, halfH);
                    const uniform = Math.max(0.2, currentDist / baseDist);
                    transform.scaleX = uniform;
                    transform.scaleY = uniform;
                } else {
                    if (['e', 'w'].includes(handle)) {
                        transform.scaleX = Math.max(0.2, Math.abs(dx));
                    }
                    if (['n', 's'].includes(handle)) {
                        transform.scaleY = Math.max(0.2, Math.abs(dy));
                    }
                }
            } else if (mode === 'rotate') {
                const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                transform.rotation = angle - startAngle;
            }

            applyTransformToSelection(originalStrokes, transform, center, pageIndex);
            updateSelectionBox();
            e.preventDefault();
        }

        function onSelectionPointerUp(e) {
            if (!state.selectionTransform) return;
            if (e.pointerId !== state.selectionTransform.pointerId) return;
            const { pageIndex, originalStrokes } = state.selectionTransform;
            const afterStrokes = captureStrokes(pageIndex, state.selection.strokeIndices);
            const beforeJSON = JSON.stringify(originalStrokes);
            const afterJSON = JSON.stringify(afterStrokes);
            if (beforeJSON !== afterJSON) {
                saveToHistory({
                    type: 'transform-strokes',
                    pageIndex: pageIndex,
                    before: originalStrokes,
                    after: afterStrokes
                });
                scheduleSave();
            }
            state.selectionTransform = null;
        }

        function splitStrokeByEraser(stroke, x, y, radius) {
            const segments = [];
            let current = [];
            const r = radius;
            const pts = stroke.points;
            for (let i = 0; i < pts.length; i++) {
                const pt = pts[i];
                const dist = Math.hypot(pt.x - x, pt.y - y);
                const inside = dist <= r;
                if (i > 0) {
                    const prev = pts[i - 1];
                    const crosses = !inside && distancePointToSegment(x, y, prev.x, prev.y, pt.x, pt.y) <= r;
                    if (crosses) {
                        if (current.length > 1) {
                            segments.push({
                                tool: stroke.tool,
                                color: stroke.color,
                                width: stroke.width,
                                points: current
                            });
                        }
                        current = [{ x: pt.x, y: pt.y, p: pt.p }];
                        continue;
                    }
                }

                if (!inside) {
                    current.push({ x: pt.x, y: pt.y, p: pt.p });
                } else {
                    if (current.length > 1) {
                        segments.push({
                            tool: stroke.tool,
                            color: stroke.color,
                            width: stroke.width,
                            points: current
                        });
                    }
                    current = [];
                }
            }
            if (current.length > 1) {
                segments.push({
                    tool: stroke.tool,
                    color: stroke.color,
                    width: stroke.width,
                    points: current
                });
            }
            return segments;
        }

        function distancePointToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            if (dx === 0 && dy === 0) {
                return Math.hypot(px - x1, py - y1);
            }
            const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
            const clamped = Math.max(0, Math.min(1, t));
            const cx = x1 + clamped * dx;
            const cy = y1 + clamped * dy;
            return Math.hypot(px - cx, py - cy);
        }

        function eraseAreaAtPoint(pageIndex, x, y, radius, options = {}) {
            const page = state.pages[pageIndex];
            if (!page) return false;
            let changed = false;
            const newStrokes = [];

            for (const stroke of page.strokes) {
                if (!stroke) continue;
                if (stroke.points.length < 2) {
                    newStrokes.push(stroke);
                    continue;
                }
                if (stroke.tool && stroke.tool.startsWith('eraser')) {
                    newStrokes.push(stroke);
                    continue;
                }

                const segments = splitStrokeByEraser(stroke, x, y, radius);
                if (segments.length === 1 && segments[0].points.length === stroke.points.length) {
                    newStrokes.push(stroke);
                } else {
                    changed = true;
                    segments.forEach(seg => newStrokes.push(seg));
                }
            }

            if (changed) {
                page.strokes = newStrokes;
                if (!options.deferRedraw) {
                    redrawPage(pageIndex);
                }
            }

            return changed;
        }

        // Erase entire stroke that intersects with point
        function eraseStrokeAtPoint(pageIndex, x, y, erasedList, hitRadius = 15) {
            const page = state.pages[pageIndex];
            
            for (let i = page.strokes.length - 1; i >= 0; i--) {
                const stroke = page.strokes[i];
                if (stroke.tool && stroke.tool.startsWith('eraser')) continue; // Don't erase eraser strokes
                
                for (const point of stroke.points) {
                    const dist = Math.hypot(point.x - x, point.y - y);
                    if (dist < hitRadius) {
                        // Remove stroke and add to erased list
                        const removed = page.strokes.splice(i, 1)[0];
                        erasedList.push({ index: i, stroke: JSON.parse(JSON.stringify(removed)) });
                        redrawPage(pageIndex);
                        break;
                    }
                }
            }
        }

        // Get canvas position accounting for scale
        function getCanvasPos(canvas, e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width / CANVAS_SCALE),
                y: (e.clientY - rect.top) * (canvas.height / rect.height / CANVAS_SCALE)
            };
        }

        // Setup context for different tools
        function setupContext(ctx, tool, color, width) {
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;

            if (tool === 'eraser-area') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = width;
                ctx.strokeStyle = 'rgba(0,0,0,1)';
            } else if (tool === 'highlighter') {
                ctx.globalCompositeOperation = 'multiply';
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
            } else {
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
            }
        }

        // Redraw page with smooth quadratic curves
        function redrawPage(pageIndex) {
            const canvas = document.querySelector(`canvas[data-page="${pageIndex}"]`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.save();
            ctx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const page = state.pages[pageIndex];
            if (!page) return;

              for (const stroke of page.strokes) {
                  if (stroke.points.length < 2) continue;
                if (stroke.tool === 'eraser-stroke') continue;

                setupContext(ctx, stroke.tool, stroke.color, stroke.width);

                ctx.beginPath();
                let p1 = stroke.points[0];
                ctx.moveTo(p1.x, p1.y);

                // Draw smooth curves using quadratic bezier
                for (let i = 1; i < stroke.points.length; i++) {
                    const p2 = stroke.points[i];
                    const midPoint = {
                        x: p1.x + (p2.x - p1.x) / 2,
                        y: p1.y + (p2.y - p1.y) / 2
                    };
                    ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
                    p1 = p2;
                }
                ctx.lineTo(p1.x, p1.y);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Render all pages
        function renderAllPages() {
            clearSelection();
            canvasContainer.innerHTML = '';
            canvasContainer.appendChild(addPageIndicator);
            state.pages.forEach((_, index) => {
                createPageElement(index, false);
            });
            updateAddPageIndicator();
        }

        function bakeLegacyEraserAreaStrokes() {
            let changed = false;
            state.pages.forEach((page, pageIndex) => {
                if (!page || !Array.isArray(page.strokes)) return;
                const erasers = page.strokes.filter(stroke => stroke.tool === 'eraser-area' && stroke.points && stroke.points.length);
                if (erasers.length === 0) return;
                changed = true;

                page.strokes = page.strokes.filter(stroke => !(stroke.tool && stroke.tool.startsWith('eraser')));
                erasers.forEach(stroke => {
                    const radius = (stroke.width || state.eraserWidth) / 2;
                    stroke.points.forEach(pt => {
                        eraseAreaAtPoint(pageIndex, pt.x, pt.y, radius, { deferRedraw: true });
                    });
                });
            });
            if (changed) {
                saveToStorage();
            }
        }

        function syncEraserMenuState() {
            if (!eraserToggle) return;
            eraserToggle.checked = state.eraserMode === 'stroke';
            document.querySelectorAll('#eraser-menu .size-btn[data-eraser-size]').forEach(btn => {
                const size = parseFloat(btn.dataset.eraserSize);
                btn.classList.toggle('active', size === state.eraserWidth);
            });
        }

        function positionEraserMenu() {
            if (!eraserMenu || !eraserButton) return;
            const btnRect = eraserButton.getBoundingClientRect();
            const menuRect = eraserMenu.getBoundingClientRect();
            const margin = 12;
            const header = document.querySelector('header');
            const headerHeight = header ? header.getBoundingClientRect().height : 60;
            let left = btnRect.right + 12;
            let top = btnRect.top + (btnRect.height - menuRect.height) / 2;

            if (toolbar.classList.contains('horizontal')) {
                left = btnRect.left + (btnRect.width - menuRect.width) / 2;
                top = btnRect.top - menuRect.height - 12;
            }

            left = Math.max(margin, Math.min(left, window.innerWidth - menuRect.width - margin));
            top = Math.max(headerHeight + margin, Math.min(top, window.innerHeight - menuRect.height - margin));

            eraserMenu.style.left = `${left}px`;
            eraserMenu.style.top = `${top}px`;
        }

        function openEraserMenu() {
            if (!eraserMenu) return;
            syncEraserMenuState();
            eraserMenu.classList.add('visible');
            eraserMenu.setAttribute('aria-hidden', 'false');
            requestAnimationFrame(positionEraserMenu);
        }

        function closeEraserMenu() {
            if (!eraserMenu) return;
            eraserMenu.classList.remove('visible');
            eraserMenu.setAttribute('aria-hidden', 'true');
        }

        function toggleEraserMenu() {
            if (!eraserMenu) return;
            if (eraserMenu.classList.contains('visible')) {
                closeEraserMenu();
            } else {
                openEraserMenu();
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Tool buttons
            toolbar.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    toolbar.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const nextTool = btn.dataset.tool;
                    if (nextTool === 'eraser') {
                        const isEraserActive = state.currentTool === 'eraser-area' || state.currentTool === 'eraser-stroke';
                        if (isEraserActive) {
                            toggleEraserMenu();
                            return;
                        }
                    }

                    if (nextTool !== 'lasso') {
                        clearSelection();
                    }
                    if (nextTool === 'eraser') {
                        state.currentTool = state.eraserMode === 'stroke' ? 'eraser-stroke' : 'eraser-area';
                    } else {
                        state.currentTool = nextTool;
                        if (btn.dataset.color) state.currentColor = btn.dataset.color;
                        if (btn.dataset.width) state.currentWidth = parseFloat(btn.dataset.width);
                    }
                    if (nextTool !== 'eraser') {
                        closeEraserMenu();
                    }
                });
            });

            document.querySelectorAll('#eraser-menu .size-btn[data-eraser-size]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#eraser-menu .size-btn[data-eraser-size]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.eraserWidth = parseFloat(btn.dataset.eraserSize);
                });
            });

            if (eraserToggle) {
                eraserToggle.addEventListener('change', () => {
                    state.eraserMode = eraserToggle.checked ? 'stroke' : 'area';
                    if (state.currentTool === 'eraser-area' || state.currentTool === 'eraser-stroke') {
                        state.currentTool = state.eraserMode === 'stroke' ? 'eraser-stroke' : 'eraser-area';
                    }
                });
            }


            document.addEventListener('pointerdown', (e) => {
                if (!eraserMenu || !eraserMenu.classList.contains('visible')) return;
                if (eraserMenu.contains(e.target)) return;
                if (eraserButton && (e.target === eraserButton || eraserButton.contains(e.target))) return;
                closeEraserMenu();
            });

            window.addEventListener('resize', () => {
                if (eraserMenu && eraserMenu.classList.contains('visible')) {
                    positionEraserMenu();
                }
            });

            // Export/Import PDF
            document.getElementById('btn-export-pdf').addEventListener('click', exportPDF);
            document.getElementById('btn-import-pdf').addEventListener('click', () => pdfInput.click());
            pdfInput.addEventListener('change', importPDF);
            document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
            document.getElementById('btn-reset-document').addEventListener('click', openResetModal);

            // Undo/Redo buttons
            document.getElementById('btn-undo').addEventListener('click', undo);
            document.getElementById('btn-redo').addEventListener('click', redo);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                } else if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    redo();
                }
            });

            // Pages panel
            document.getElementById('btn-edit-pages').addEventListener('click', openPagesPanel);
            document.getElementById('panel-close').addEventListener('click', closePagesPanel);
            document.getElementById('panel-overlay').addEventListener('click', closePagesPanel);

            // Delete modal
            document.getElementById('modal-delete-cancel').addEventListener('click', closeDeleteModal);
            document.getElementById('modal-delete-confirm').addEventListener('click', confirmDeletePage);
            document.getElementById('modal-reset-cancel').addEventListener('click', closeResetModal);
            document.getElementById('modal-reset-confirm').addEventListener('click', confirmResetDocument);

            // Viewport pan/zoom with touch and mouse
            canvasViewport.addEventListener('pointerdown', handleViewportPointerDown);
            canvasViewport.addEventListener('pointermove', handleViewportPointerMove);
            canvasViewport.addEventListener('pointerup', handleViewportPointerUp);
            canvasViewport.addEventListener('pointercancel', handleViewportPointerUp);
            canvasViewport.addEventListener('pointerleave', handleViewportPointerUp);
            document.addEventListener('pointermove', onSelectionPointerMove);
            document.addEventListener('pointerup', onSelectionPointerUp);

            // Mouse wheel for scroll and zoom
            canvasViewport.addEventListener('wheel', handleWheel, { passive: false });

            // Setup toolbar dragging
            setupToolbarDrag();

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);
            handleFullscreenChange();
        }

        function isFullscreenActive() {
            return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
        }

        function updateFullscreenButton() {
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            if (!fullscreenBtn) return;
            const isActive = !!isFullscreenActive();
            const label = isActive ? 'Exit fullscreen' : 'Fullscreen';
            fullscreenBtn.title = label;
            fullscreenBtn.setAttribute('aria-label', label);
            fullscreenBtn.classList.toggle('active', isActive);
        }

        function handleFullscreenChange() {
            updateFullscreenButton();
            // Allow layout to settle before re-centering and clamping toolbar
            setTimeout(() => {
                centerViewOnTop();
                window.dispatchEvent(new Event('resize'));
            }, 50);
        }

        function toggleFullscreen() {
            const root = document.documentElement;
            if (isFullscreenActive()) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                return;
            }
            if (root.requestFullscreen) {
                root.requestFullscreen();
            } else if (root.webkitRequestFullscreen) {
                root.webkitRequestFullscreen();
            } else if (root.msRequestFullscreen) {
                root.msRequestFullscreen();
            }
        }

        function getContentHeight() {
            const pageCount = state.pages.length;
            const gap = 30;
            const padding = 30;
            if (pageCount === 0) return 0;
            return padding * 2 + pageCount * A4_HEIGHT + Math.max(0, pageCount - 1) * gap;
        }

        function getBottomLimit() {
            const viewportHeight = canvasViewport.getBoundingClientRect().height;
            const totalHeight = getContentHeight() * state.zoom;
            const minPanY = viewportHeight - OVERSCROLL_MARGIN - totalHeight;
            return { minPanY };
        }

        function updateAddPageIndicator() {
            if (!addPageIndicator) return;
            const pageCount = state.pages.length;
            if (pageCount === 0) {
                addPageIndicator.style.opacity = 0;
                return;
            }
            const gap = 30;
            const padding = 30;
            const bottom = padding + pageCount * A4_HEIGHT + Math.max(0, pageCount - 1) * gap;
            addPageIndicator.style.left = '50%';
            addPageIndicator.style.top = (bottom + 20) + 'px';
            addPageIndicator.style.transform = 'translateX(-50%)';
            const viewportHeight = canvasViewport.getBoundingClientRect().height;
            const bottomInView = state.panY + getContentHeight() * state.zoom;
            const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;
            const progress = Math.min(1, state.overscrollY / OVERSCROLL_THRESHOLD);
            let opacity = 0;
            if (state.overscrollY > 0) {
                opacity = Math.min(1, 0.2 + progress * 0.8);
                if (!canCreate) {
                    opacity *= 0.6;
                }
            }
            addPageIndicator.style.opacity = opacity.toString();
        }

        function animatePanTo(targetY) {
            canvasContainer.style.transition = 'transform 0.35s ease';
            state.panY = targetY;
            updateTransform();
            setTimeout(() => {
                canvasContainer.style.transition = '';
            }, 360);
        }

        function applyVerticalPan(dy) {
            if (dy === 0) return;
            const { minPanY } = getBottomLimit();
            const nextPanY = state.panY + dy;

            if (dy < 0 && nextPanY < minPanY) {
                const excess = minPanY - nextPanY;
                const viewportHeight = canvasViewport.getBoundingClientRect().height;
                const requiredOverscroll = Math.max(0, (viewportHeight * (1 - CREATE_PAGE_MIN_BOTTOM_RATIO) - OVERSCROLL_MARGIN) / OVERSCROLL_FRICTION);
                const maxOverscroll = Math.max(OVERSCROLL_THRESHOLD * 3, requiredOverscroll * 1.1);
                state.overscrollY = Math.min(maxOverscroll, state.overscrollY + excess);
                state.panY = minPanY - state.overscrollY * OVERSCROLL_FRICTION;

                const bottomInView = state.panY + getContentHeight() * state.zoom;
                const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;

                state.pendingPageCreate = state.overscrollY >= OVERSCROLL_THRESHOLD && canCreate;
                state.pageCreateLocked = state.pendingPageCreate;
                updateAddPageIndicator();
                if (overscrollResetTimeout) {
                    clearTimeout(overscrollResetTimeout);
                }
                overscrollResetTimeout = setTimeout(() => {
                    if (state.overscrollY > 0) {
                        const reset = getBottomLimit();
                        state.overscrollY = 0;
                        state.panY = Math.max(state.panY, reset.minPanY);
                        state.pendingPageCreate = false;
                        state.pageCreateLocked = false;
                        updateAddPageIndicator();
                        updateTransform();
                    }
                }, 600);
                return;
            }

            if (dy > 0 && state.overscrollY > 0) {
                const remaining = Math.max(0, dy - state.overscrollY);
                state.overscrollY = Math.max(0, state.overscrollY - dy);
                state.panY = minPanY - state.overscrollY * OVERSCROLL_FRICTION;
                if (remaining > 0) {
                    state.panY += remaining;
                }
                const viewportHeight = canvasViewport.getBoundingClientRect().height;
                const bottomInView = state.panY + getContentHeight() * state.zoom;
                const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;
                state.pendingPageCreate = state.overscrollY >= OVERSCROLL_THRESHOLD && canCreate;
                state.pageCreateLocked = state.pendingPageCreate;
                updateAddPageIndicator();
                return;
            }

            state.panY = nextPanY;
            state.pendingPageCreate = false;
            state.pageCreateLocked = false;
            updateAddPageIndicator();
        }

        // Toolbar dragging functionality
        function setupToolbarDrag() {
            const toolbarHandle = document.getElementById('toolbar-handle');
            let isDragging = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let snapTimeout = null;

            function getHeaderHeight() {
                const header = document.querySelector('header');
                return header ? header.getBoundingClientRect().height : 60;
            }

            function getToolbarSize() {
                const rect = toolbar.getBoundingClientRect();
                return { width: rect.width, height: rect.height };
            }

            function getToolbarLimits(toolbarSize, margin) {
                const headerHeight = getHeaderHeight();
                const minTop = headerHeight + margin;
                const maxTop = Math.max(minTop, window.innerHeight - toolbarSize.height - margin);
                const minLeft = margin;
                const maxLeft = Math.max(minLeft, window.innerWidth - toolbarSize.width - margin);
                return { minTop, maxTop, minLeft, maxLeft };
            }

            function updateToolbarScale(margin) {
                const headerHeight = getHeaderHeight();
                const availableHeight = window.innerHeight - headerHeight - margin;
                const availableWidth = window.innerWidth - margin * 2;
                const baseWidth = toolbar.offsetWidth;
                const baseHeight = toolbar.offsetHeight;
                if (!baseWidth || !baseHeight) return;
                const scale = Math.min(1, availableHeight / baseHeight, availableWidth / baseWidth);
                const safeScale = Number.isFinite(scale) ? Math.max(0.1, scale) : 1;
                toolbar.style.setProperty('--toolbar-scale', safeScale.toString());
            }

            function snapToolbar() {
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const rect = toolbar.getBoundingClientRect();

                const margin = 15;
                const snapThreshold = 80;

                // Calculate distances to edges (within editing zone)
                const distLeft = rect.left;
                const distRight = viewportWidth - rect.right;
                const distBottom = viewportHeight - rect.bottom;

                // Find the closest edge
                const minDist = Math.min(distLeft, distRight, distBottom);

                toolbar.classList.add('snapping');
                toolbar.style.setProperty('--toolbar-translate', '0px');

                if (minDist === distBottom && distBottom < snapThreshold) {
                    // Snap to bottom (horizontal)
                    toolbar.classList.add('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    const desiredLeft = (viewportWidth - toolbarSize.width) / 2;
                    const clampedLeft = Math.max(limits.minLeft, Math.min(desiredLeft, limits.maxLeft));
                    const desiredTop = viewportHeight - toolbarSize.height - margin;
                    const clampedTop = Math.max(limits.minTop, Math.min(desiredTop, limits.maxTop));
                    toolbar.style.left = clampedLeft + 'px';
                    toolbar.style.top = clampedTop + 'px';
                    toolbar.style.right = 'auto';
                    toolbar.style.bottom = 'auto';
                } else if (minDist === distLeft && distLeft < snapThreshold) {
                    // Snap to left (vertical)
                    toolbar.classList.remove('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    toolbar.style.left = limits.minLeft + 'px';
                    toolbar.style.top = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop)) + 'px';
                    toolbar.style.bottom = 'auto';
                    toolbar.style.right = 'auto';
                } else if (minDist === distRight && distRight < snapThreshold) {
                    // Snap to right (vertical)
                    toolbar.classList.remove('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    toolbar.style.left = 'auto';
                    toolbar.style.right = limits.minLeft + 'px';
                    toolbar.style.top = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop)) + 'px';
                    toolbar.style.bottom = 'auto';
                } else {
                    // No snap, just constrain to editing area
                    toolbar.classList.remove('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    toolbar.style.left = Math.max(limits.minLeft, Math.min(rect.left, limits.maxLeft)) + 'px';
                    toolbar.style.top = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop)) + 'px';
                    toolbar.style.bottom = 'auto';
                    toolbar.style.right = 'auto';
                }

                if (snapTimeout) {
                    clearTimeout(snapTimeout);
                }
                snapTimeout = setTimeout(() => {
                    toolbar.classList.remove('snapping');
                    snapTimeout = null;
                }, 200);
            }

            function onPointerDown(e) {
                if (e.target !== toolbarHandle && !toolbarHandle.contains(e.target)) return;

                if (snapTimeout) {
                    clearTimeout(snapTimeout);
                    snapTimeout = null;
                }
                toolbar.classList.remove('snapping');
                toolbar.style.transition = 'none';

                isDragging = true;
                updateToolbarScale(10);
                const rect = toolbar.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;

                // Reset any transform after reading current position to avoid jumps
                toolbar.style.setProperty('--toolbar-translate', '0px');

                // Set explicit positioning
                toolbar.style.bottom = 'auto';
                toolbar.style.left = rect.left + 'px';
                toolbar.style.top = rect.top + 'px';
                toolbar.style.right = 'auto';

                toolbarHandle.style.cursor = 'grabbing';
                if (toolbarHandle.setPointerCapture) {
                    toolbarHandle.setPointerCapture(e.pointerId);
                }
                e.preventDefault();
            }

            function onPointerMove(e) {
                if (!isDragging) return;

                const margin = 10;
                const toolbarSize = getToolbarSize();
                const limits = getToolbarLimits(toolbarSize, margin);

                const rawLeft = e.clientX - dragOffsetX;
                const rawTop = e.clientY - dragOffsetY;

                // Constrain to editing area (below header)
                const newLeft = Math.max(limits.minLeft, Math.min(rawLeft, limits.maxLeft));
                const newTop = Math.max(limits.minTop, Math.min(rawTop, limits.maxTop));

                toolbar.style.left = newLeft + 'px';
                toolbar.style.top = newTop + 'px';
                toolbar.style.right = 'auto';
                toolbar.style.bottom = 'auto';
            }

            function onPointerUp(e) {
                if (!isDragging) return;
                isDragging = false;
                toolbarHandle.style.cursor = 'grab';
                if (toolbarHandle.releasePointerCapture) {
                    toolbarHandle.releasePointerCapture(e.pointerId);
                }
                toolbar.style.transition = '';
                snapToolbar();
            }

            toolbarHandle.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);

            // Handle window resize
            window.addEventListener('resize', () => {
                const margin = 10;
                updateToolbarScale(margin);
                const rect = toolbar.getBoundingClientRect();
                const toolbarSize = getToolbarSize();
                const limits = getToolbarLimits(toolbarSize, margin);
                const nextLeft = Math.max(limits.minLeft, Math.min(rect.left, limits.maxLeft));
                const nextTop = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop));
                toolbar.style.left = nextLeft + 'px';
                toolbar.style.top = nextTop + 'px';
                toolbar.style.right = 'auto';
                toolbar.style.bottom = 'auto';
                toolbar.style.setProperty('--toolbar-translate', '0px');
            });

            // Normalize initial position to avoid transform jumps on first drag
            requestAnimationFrame(() => {
                updateToolbarScale(10);
                const rect = toolbar.getBoundingClientRect();
                toolbar.style.left = rect.left + 'px';
                toolbar.style.top = rect.top + 'px';
                toolbar.style.right = 'auto';
                toolbar.style.bottom = 'auto';
                toolbar.style.setProperty('--toolbar-translate', '0px');
            });
        }

        // Wheel handler for PC - scroll and zoom
        function handleWheel(e) {
            e.preventDefault();
            
            if (e.ctrlKey || e.metaKey) {
                // Zoom with Ctrl+wheel or pinch on trackpad
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.min(Math.max(0.5, state.zoom * zoomFactor), 3);
                
                // Zoom centered on mouse position
                const rect = canvasViewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate point in content coordinates
                const contentX = (mouseX - state.panX) / state.zoom;
                const contentY = (mouseY - state.panY) / state.zoom;
                
                // Update zoom
                state.zoom = newZoom;
                
                // Adjust pan to keep the point under the mouse
                state.panX = mouseX - contentX * state.zoom;
                state.panY = mouseY - contentY * state.zoom;
                
                updateTransform();
            } else {
                // Scroll with wheel
                state.panX -= e.deltaX;
                applyVerticalPan(-e.deltaY);
                updateTransform();
            }
            if (wheelReleaseTimeout) {
                clearTimeout(wheelReleaseTimeout);
            }
            wheelReleaseTimeout = setTimeout(() => {
                state.pageCreateLocked = false;
            }, 300);
        }

        // Viewport pointer handlers for pan/zoom
        function handleViewportPointerDown(e) {
            // Pen is handled by canvas
            if (e.pointerType === 'pen') return;
            if (state.currentTool === 'lasso' && state.selection.pageIndex !== null) {
                const selectionBox = document.querySelector(`.selection-box[data-page="${state.selection.pageIndex}"]`);
                if (selectionBox && !selectionBox.classList.contains('hidden')) {
                    if (!selectionBox.contains(e.target)) {
                        clearSelection();
                    }
                }
            }
            
            // For mouse, only start pan on middle button or when not on canvas
            if (e.pointerType === 'mouse') {
                // Left click drag to pan
                state.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
                state.isPanning = true;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                canvasViewport.style.cursor = 'grabbing';
                return;
            }
            
            // Touch handling
            state.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

            if (state.activePointers.size === 2) {
                // Store pinch center for zoom
                const points = Array.from(state.activePointers.values());
                state.pinchCenterX = (points[0].clientX + points[1].clientX) / 2;
                state.pinchCenterY = (points[0].clientY + points[1].clientY) / 2;
                state.initialPinchDist = getPointerDistance();
                state.initialScale = state.zoom;
                state.initialPanX = state.panX;
                state.initialPanY = state.panY;
                state.scrollLocked = false;
            } else if (state.activePointers.size === 1) {
                state.isPanning = true;
                state.scrollLocked = false;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                state.panStartX = e.clientX;
                state.panStartY = e.clientY;
            }
        }

        function handleViewportPointerMove(e) {
            // Pen is handled by canvas
            if (e.pointerType === 'pen') return;
            if (!state.activePointers.has(e.pointerId)) return;
            
            state.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

            // Mouse drag
            if (e.pointerType === 'mouse' && state.isPanning) {
                const dx = e.clientX - state.lastPanX;
                const dy = e.clientY - state.lastPanY;
                state.panX += dx;
                applyVerticalPan(dy);
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                updateTransform();
                return;
            }

            // Touch pinch zoom
            if (state.activePointers.size === 2) {
                const currentDist = getPointerDistance();
                if (state.initialPinchDist > 0) {
                    const scaleFactor = currentDist / state.initialPinchDist;
                    const newZoom = Math.min(Math.max(0.5, state.initialScale * scaleFactor), 3);
                    
                    // Get current pinch center
                    const points = Array.from(state.activePointers.values());
                    const currentCenterX = (points[0].clientX + points[1].clientX) / 2;
                    const currentCenterY = (points[0].clientY + points[1].clientY) / 2;
                    
                    // Calculate the point in content space at the original pinch center
                    const rect = canvasViewport.getBoundingClientRect();
                    const contentX = (state.pinchCenterX - rect.left - state.initialPanX) / state.initialScale;
                    const contentY = (state.pinchCenterY - rect.top - state.initialPanY) / state.initialScale;
                    
                    // Update zoom
                    state.zoom = newZoom;
                    
                    // Adjust pan to keep the content point under the current pinch center
                    state.panX = currentCenterX - rect.left - contentX * state.zoom;
                    state.panY = currentCenterY - rect.top - contentY * state.zoom;
                    
                    updateTransform();
                }
            } else if (state.activePointers.size === 1 && state.isPanning) {
                // Single finger pan
                const dx = e.clientX - state.lastPanX;
                const dy = e.clientY - state.lastPanY;
                
                // Check if we should lock to vertical scroll
                if (!state.scrollLocked) {
                    const totalDx = Math.abs(e.clientX - state.panStartX);
                    const totalDy = Math.abs(e.clientY - state.panStartY);
                    
                    if (totalDx > 10 || totalDy > 10) {
                        if (totalDy > totalDx * 2) {
                            state.scrollLocked = 'vertical';
                        } else if (totalDx > totalDy * 2) {
                            state.scrollLocked = 'horizontal';
                        } else {
                            state.scrollLocked = 'free';
                        }
                    }
                }

                // Apply movement based on lock
                if (state.scrollLocked === 'vertical') {
                    applyVerticalPan(dy);
                } else if (state.scrollLocked === 'horizontal') {
                    state.panX += dx;
                } else {
                    state.panX += dx;
                    applyVerticalPan(dy);
                }

                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                updateTransform();
            }
        }

        function handleViewportPointerUp(e) {
            if (e.pointerType === 'pen') return;
            state.activePointers.delete(e.pointerId);
            const finalizePageCreation = () => {
                const viewportHeight = canvasViewport.getBoundingClientRect().height;
                const bottomInView = state.panY + getContentHeight() * state.zoom;
                const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;
                if (state.pendingPageCreate && state.overscrollY >= OVERSCROLL_THRESHOLD && canCreate) {
                    const prevLimit = getBottomLimit();
                    addPage(null, true);
                    state.overscrollY = 0;
                    updateAddPageIndicator();
                    animatePanTo(prevLimit.minPanY);
                }
                state.pendingPageCreate = false;
            };

            if (e.pointerType === 'mouse') {
                state.isPanning = false;
                canvasViewport.style.cursor = '';
                finalizePageCreation();
                state.pageCreateLocked = false;
                if (state.overscrollY > 0) {
                    const reset = getBottomLimit();
                    state.overscrollY = 0;
                    state.panY = Math.max(state.panY, reset.minPanY);
                    updateTransform();
                }
                return;
            }

            if (state.activePointers.size < 2) {
                state.initialPinchDist = 0;
            }
            if (state.activePointers.size === 1) {
                const remaining = Array.from(state.activePointers.values())[0];
                if (remaining) {
                    state.isPanning = true;
                    state.scrollLocked = false;
                    state.lastPanX = remaining.clientX;
                    state.lastPanY = remaining.clientY;
                    state.panStartX = remaining.clientX;
                    state.panStartY = remaining.clientY;
                }
            }
            if (state.activePointers.size === 0) {
                state.isPanning = false;
                state.scrollLocked = false;
                finalizePageCreation();
                state.pageCreateLocked = false;
            }
            if (state.overscrollY > 0) {
                const reset = getBottomLimit();
                state.overscrollY = 0;
                state.panY = Math.max(state.panY, reset.minPanY);
                updateTransform();
            }
        }

        function getPointerDistance() {
            const points = Array.from(state.activePointers.values());
            if (points.length < 2) return 0;
            const dx = points[0].clientX - points[1].clientX;
            const dy = points[0].clientY - points[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function updateTransform() {
            canvasContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
        }

        function setZoom(newZoom) {
            state.zoom = Math.max(0.5, Math.min(3, newZoom));
            updateTransform();
        }

        // Pages Panel
        function openPagesPanel() {
            renderPagesList();
            document.getElementById('pages-panel').classList.add('visible');
            document.getElementById('panel-overlay').classList.add('visible');
        }

        function closePagesPanel() {
            document.getElementById('pages-panel').classList.remove('visible');
            document.getElementById('panel-overlay').classList.remove('visible');
        }

        function renderPagesList() {
            const pagesList = document.getElementById('pages-list');
            pagesList.innerHTML = '';

            state.pages.forEach((page, index) => {
                const item = document.createElement('div');
                item.className = 'page-item';
                const strokeCount = getVisibleStrokeCount(page);
                item.innerHTML = `
                    <div class="page-thumbnail">
                        <canvas id="thumb-${index}" width="50" height="70"></canvas>
                    </div>
                    <div class="page-info">
                        <h3>Page ${index + 1}</h3>
                        <p>${strokeCount} stroke${strokeCount !== 1 ? 's' : ''}${page.backgroundImage ? '  PDF' : ''}</p>
                    </div>
                    <div class="page-actions">
                        <button class="page-action-btn" data-action="goto" data-page="${index}" title="Go to page">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                            </svg>
                        </button>
                        <button class="page-action-btn delete" data-action="delete" data-page="${index}" title="Delete" ${state.pages.length === 1 ? 'disabled style="opacity:0.3;pointer-events:none;"' : ''}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                `;
                pagesList.appendChild(item);

                generateThumbnail(index);

                item.querySelector('[data-action="goto"]').addEventListener('click', () => {
                    goToPage(index);
                    closePagesPanel();
                });

                const deleteBtn = item.querySelector('[data-action="delete"]');
                if (state.pages.length > 1) {
                    deleteBtn.addEventListener('click', () => openDeleteModal(index));
                }
            });
        }

        function generateThumbnail(pageIndex) {
            const thumbCanvas = document.getElementById(`thumb-${pageIndex}`);
            if (!thumbCanvas) return;

            const ctx = thumbCanvas.getContext('2d');
            const page = state.pages[pageIndex];

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 50, 70);

            // Draw background image if exists
            if (page.backgroundImage) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 50, 70);
                    drawThumbnailStrokes(ctx, page, pageIndex);
                };
                img.src = page.backgroundImage;
            } else {
                ctx.strokeStyle = '#ffde00';
                ctx.lineWidth = 1;
                ctx.strokeRect(2, 2, 46, 66);
                drawThumbnailStrokes(ctx, page, pageIndex);
            }
        }

        function drawThumbnailStrokes(ctx, page, pageIndex) {
            const scaleX = 50 / A4_WIDTH;
            const scaleY = 70 / A4_HEIGHT;

            ctx.save();
            ctx.scale(scaleX, scaleY);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (const stroke of page.strokes) {
                if (stroke.points.length < 2) continue;
                if (stroke.tool === 'eraser-stroke') continue;

                setupContext(ctx, stroke.tool, stroke.color, stroke.width);

                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                ctx.stroke();
            }

            ctx.restore();
        }

        function getVisibleStrokeCount(page) {
            return page.strokes.filter(stroke => !(stroke.tool && stroke.tool.startsWith('eraser'))).length;
        }

        function goToPage(pageIndex) {
            const pageWrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (pageWrapper) {
                const rect = pageWrapper.getBoundingClientRect();
                const viewportRect = canvasViewport.getBoundingClientRect();
                state.panY = -(pageIndex * (A4_HEIGHT + 30) * state.zoom) + viewportRect.height / 2 - (A4_HEIGHT * state.zoom) / 2;
                state.panX = viewportRect.width / 2 - (A4_WIDTH * state.zoom) / 2 - 30;
                updateTransform();
            }
        }

        // Delete page
        let pageToDelete = null;

        function openDeleteModal(pageIndex) {
            pageToDelete = pageIndex;
            document.getElementById('delete-page-number').textContent = pageIndex + 1;
            document.getElementById('modal-delete-page').classList.add('visible');
        }

        function closeDeleteModal() {
            pageToDelete = null;
            document.getElementById('modal-delete-page').classList.remove('visible');
        }

        function confirmDeletePage() {
            if (pageToDelete === null || state.pages.length <= 1) {
                closeDeleteModal();
                return;
            }

            state.pages.splice(pageToDelete, 1);
            renderAllPages();
            const lastIndex = state.pages.length - 1;
            if (lastIndex >= 0) {
                goToPage(lastIndex);
            }
            saveToStorage();
            renderPagesList();
            closeDeleteModal();
            showStatus('Page deleted');
        }

        // Reset document
        function openResetModal() {
            document.getElementById('modal-reset-document').classList.add('visible');
        }

        function closeResetModal() {
            document.getElementById('modal-reset-document').classList.remove('visible');
        }

        function confirmResetDocument() {
            closeResetModal();
            clearSelection();
            state.selectionTransform = null;
            state.pages = [{
                strokes: [],
                backgroundImage: null
            }];
            state.history = [];
            state.historyIndex = -1;
            updateHistoryButtons();
            renderAllPages();
            saveToStorage();
            renderPagesList();
            centerViewOnTop();
            showStatus('New document');
        }

        // Storage
        function saveToStorage() {
            try {
                const data = JSON.stringify({
                    pages: state.pages,
                    version: 2
                });
                localStorage.setItem('notebook-data-v2', data);
            } catch (e) {
                console.error('Failed to save:', e);
            }
        }

        function loadFromStorage() {
            try {
                const data = localStorage.getItem('notebook-data-v2');
                if (data) {
                    const parsed = JSON.parse(data);
                    state.pages = parsed.pages || [];
                }
            } catch (e) {
                console.error('Failed to load:', e);
                state.pages = [];
            }
        }

        function scheduleSave() {
            showStatus('Saving...', true);
            clearTimeout(state.saveTimeout);
            state.saveTimeout = setTimeout(() => {
                saveToStorage();
                showStatus('Saved');
            }, 500);
        }

        // History functions for undo/redo
        function saveToHistory(action) {
            // Remove any future history if we're not at the end
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }

            // Add new action
            state.history.push(action);

            // Limit history size
            if (state.history.length > state.maxHistory) {
                state.history.shift();
            } else {
                state.historyIndex++;
            }

            updateHistoryButtons();
        }

        function undo() {
            if (state.historyIndex < 0) return;

            const action = state.history[state.historyIndex];
            state.historyIndex--;

            if (action.type === 'add-stroke') {
                // Remove the stroke
                const page = state.pages[action.pageIndex];
                page.strokes.pop();
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-strokes') {
                // Restore erased strokes
                const page = state.pages[action.pageIndex];
                // Restore in reverse order to maintain indices
                for (let i = action.strokes.length - 1; i >= 0; i--) {
                    const item = action.strokes[i];
                    page.strokes.splice(item.index, 0, item.stroke);
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'transform-strokes') {
                const page = state.pages[action.pageIndex];
                for (const item of action.before) {
                    page.strokes[item.index] = JSON.parse(JSON.stringify(item.stroke));
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-area') {
                const page = state.pages[action.pageIndex];
                page.strokes = JSON.parse(JSON.stringify(action.before));
                redrawPage(action.pageIndex);
            }

            updateHistoryButtons();
            scheduleSave();
        }

        function redo() {
            if (state.historyIndex >= state.history.length - 1) return;

            state.historyIndex++;
            const action = state.history[state.historyIndex];

            if (action.type === 'add-stroke') {
                // Re-add the stroke
                const page = state.pages[action.pageIndex];
                page.strokes.push(JSON.parse(JSON.stringify(action.stroke)));
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-strokes') {
                // Re-erase the strokes
                const page = state.pages[action.pageIndex];
                // Remove in order (highest index first to maintain indices)
                const sorted = [...action.strokes].sort((a, b) => b.index - a.index);
                for (const item of sorted) {
                    page.strokes.splice(item.index, 1);
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'transform-strokes') {
                const page = state.pages[action.pageIndex];
                for (const item of action.after) {
                    page.strokes[item.index] = JSON.parse(JSON.stringify(item.stroke));
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-area') {
                const page = state.pages[action.pageIndex];
                page.strokes = JSON.parse(JSON.stringify(action.after));
                redrawPage(action.pageIndex);
            }

            updateHistoryButtons();
            scheduleSave();
        }

        function updateHistoryButtons() {
            document.getElementById('btn-undo').disabled = state.historyIndex < 0;
            document.getElementById('btn-redo').disabled = state.historyIndex >= state.history.length - 1;
        }

        function showStatus(text, saving = false) {
            const indicator = document.getElementById('save-indicator');
            if (!indicator) return;
            indicator.classList.toggle('saving', saving);
            indicator.classList.toggle('saved', !saving);
            indicator.title = text;
            indicator.setAttribute('aria-label', text);
        }

        function showLoading(text) {
            loadingText.textContent = text;
            loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            loadingOverlay.classList.remove('visible');
        }

        // Import PDF - detect embedded strokes or treat as background
        async function importPDF(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoading('Analyzing PDF...');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;

                // Try to extract embedded stroke data from PDF metadata
                let embeddedStrokes = null;
                try {
                    const metadata = await pdf.getMetadata();
                    const keywords = metadata?.info?.Keywords || '';
                    
                    if (keywords.startsWith('STROKES_DATA:')) {
                        const encodedData = keywords.substring('STROKES_DATA:'.length);
                        const decodedString = decodeURIComponent(escape(atob(encodedData)));
                        embeddedStrokes = JSON.parse(decodedString);
                        showLoading('PDF with strokes detected...');
                    }
                } catch (metaErr) {
                    console.log('No embedded stroke data found:', metaErr);
                }

                // Clear existing pages
                state.pages = [];
                state.history = [];
                state.historyIndex = -1;
                updateHistoryButtons();
                canvasContainer.innerHTML = '';

                for (let i = 1; i <= numPages; i++) {
                    showLoading(`Processing page ${i} of ${numPages}...`);
                    
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 2 });

                    // Create temp canvas for PDF page
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    const tempCtx = tempCanvas.getContext('2d');

                    await page.render({
                        canvasContext: tempCtx,
                        viewport: viewport
                    }).promise;

                    // Convert to base64 and resize to A4
                    const a4Canvas = document.createElement('canvas');
                    a4Canvas.width = A4_WIDTH * CANVAS_SCALE;
                    a4Canvas.height = A4_HEIGHT * CANVAS_SCALE;
                    const a4Ctx = a4Canvas.getContext('2d');
                    
                    a4Ctx.fillStyle = 'white';
                    a4Ctx.fillRect(0, 0, a4Canvas.width, a4Canvas.height);
                    
                    const scale = Math.min(
                        a4Canvas.width / viewport.width,
                        a4Canvas.height / viewport.height
                    );
                    const offsetX = (a4Canvas.width - viewport.width * scale) / 2;
                    const offsetY = (a4Canvas.height - viewport.height * scale) / 2;
                    
                    a4Ctx.drawImage(
                        tempCanvas,
                        offsetX, offsetY,
                        viewport.width * scale,
                        viewport.height * scale
                    );

                    // Check if we have embedded strokes for this page
                    if (embeddedStrokes && embeddedStrokes[i - 1]) {
                        const pageData = embeddedStrokes[i - 1];
                        
                        // If page had custom background, keep PDF as background
                        // If not (was using default SVG), use default SVG background
                        if (pageData.hasCustomBackground) {
                            state.pages.push({
                                strokes: pageData.strokes || [],
                                backgroundImage: a4Canvas.toDataURL('image/jpeg', 0.85)
                            });
                        } else {
                            // Original was default template, don't use PDF as background
                            // (PDF contains rendered strokes, we want clean template + vector strokes)
                            state.pages.push({
                                strokes: pageData.strokes || [],
                                backgroundImage: null // Will use default SVG
                            });
                        }
                    } else {
                        // No embedded data - this is a regular PDF, use as background
                        state.pages.push({
                            strokes: [],
                            backgroundImage: a4Canvas.toDataURL('image/jpeg', 0.85)
                        });
                    }
                }

                renderAllPages();
                saveToStorage();
                hideLoading();
                centerViewOnTop();
                
                if (embeddedStrokes) {
                    const totalStrokes = embeddedStrokes.reduce((sum, p) => sum + (p.strokes?.length || 0), 0);
                    showStatus(`PDF imported: ${numPages} pages, ${totalStrokes} strokes restored`);
                } else {
                    showStatus(`PDF imported: ${numPages} pages (as background)`);
                }

            } catch (err) {
                console.error('Error importing PDF:', err);
                hideLoading();
                showStatus('Error importing PDF');
            }

            pdfInput.value = '';
        }

        // Export PDF with embedded stroke data
        async function exportPDF() {
            showLoading('Generando PDF...');

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            // Prepare stroke data to embed (without backgroundImage to save space)
            const strokeData = state.pages.map(page => ({
                strokes: page.strokes,
                hasCustomBackground: !!page.backgroundImage
            }));

            // Embed stroke data as PDF metadata (custom property)
            const metadataString = JSON.stringify(strokeData);
            const encodedMetadata = btoa(unescape(encodeURIComponent(metadataString)));
            
            // Add as PDF property
            pdf.setProperties({
                title: 'Cuaderno Digital',
                subject: 'Notas con S-Pen',
                creator: 'Cuaderno Digital App',
                keywords: `STROKES_DATA:${encodedMetadata}`
            });

            for (let i = 0; i < state.pages.length; i++) {
                showLoading(`Exporting page ${i + 1} of ${state.pages.length}...`);
                
                if (i > 0) pdf.addPage();

                const page = state.pages[i];
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = A4_WIDTH * CANVAS_SCALE;
                tempCanvas.height = A4_HEIGHT * CANVAS_SCALE;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw background
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                if (page.backgroundImage) {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                            resolve();
                        };
                        img.onerror = resolve;
                        img.src = page.backgroundImage;
                    });
                } else {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                            resolve();
                        };
                        img.onerror = resolve;
                        img.src = SVG_BACKGROUND;
                    });
                }

                // Draw strokes
                tempCtx.scale(CANVAS_SCALE, CANVAS_SCALE);
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';
                for (const stroke of page.strokes) {
                    if (stroke.points.length < 2) continue;
                    if (stroke.tool === 'eraser-stroke') continue;

                    setupContext(tempCtx, stroke.tool, stroke.color, stroke.width);

                    tempCtx.beginPath();
                    let p1 = stroke.points[0];
                    tempCtx.moveTo(p1.x, p1.y);

                    for (let j = 1; j < stroke.points.length; j++) {
                        const p2 = stroke.points[j];
                        const midPoint = {
                            x: p1.x + (p2.x - p1.x) / 2,
                            y: p1.y + (p2.y - p1.y) / 2
                        };
                        tempCtx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
                        p1 = p2;
                    }
                    tempCtx.lineTo(p1.x, p1.y);
                    tempCtx.stroke();
                }

                const imgData = tempCanvas.toDataURL('image/jpeg', 0.9);
                pdf.addImage(imgData, 'JPEG', 0, 0, 210, 297);
            }

            pdf.save('cuaderno.pdf');
            hideLoading();
            showStatus('PDF exported');
        }

        // Start
        init();
    </script>
</body>
</html>
