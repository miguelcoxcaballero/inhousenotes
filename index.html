<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>inhouse notes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=DM+Sans:wght@400;500;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        .hidden {
            display: none !important;
        }

        @property --toolbar-rotate {
            syntax: '<angle>';
            inherits: true;
            initial-value: 0deg;
        }

        :root {
            --bg-primary: #f5f5f0;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --accent-yellow: #ffde00;
            --accent-blue: #002FD9;
            --accent-red: #E81010;
            --accent-black: #4D4D4D;
            --accent-orange: #E07A3C;
            --accent-green: #34c759;
            --shadow-soft: 0 2px 20px rgba(0,0,0,0.08);
            --shadow-medium: 0 4px 30px rgba(0,0,0,0.12);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --tool-size: 44px;
            --toolbar-padding: 10px;
            --handle-width: 44px;
            --handle-height: 24px;
            --icon-size: 20px;
            --header-btn-size: 44px;
            --banner-height: 64px;
            --toolbar-tilt: 18deg;
            --selection-handle-size: 14px;
            --selection-handle-offset: calc(-1px - (var(--selection-handle-size) / 2));
            --rotate-handle-size: 10px;
        }

        [data-theme="dark"] {
            --bg-primary: #151515;
            --bg-secondary: #1c1c1c;
            --text-primary: #f5f5f5;
            --text-secondary: #a2a2a2;
            --shadow-soft: 0 2px 20px rgba(0,0,0,0.35);
            --shadow-medium: 0 4px 30px rgba(0,0,0,0.45);
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            touch-action: none;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            min-height: var(--banner-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid rgba(0,0,0,0.06);
            z-index: 100;
            flex-shrink: 0;
        }

        .logo,
        .drive-brand {
            font-family: 'Comfortaa', cursive;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo {
            cursor: pointer;
        }

        .logo:focus-visible {
            outline: 2px solid rgba(0, 47, 217, 0.5);
            outline-offset: 4px;
            border-radius: 10px;
        }

        .logo svg,
        .drive-brand svg {
            width: 32px;
            height: 24px;
        }

        .logo span,
        .drive-brand span {
            letter-spacing: -0.5px;
        }

        @media (max-width: 720px) {
            .logo {
                gap: 0;
            }

            .logo span {
                display: none;
            }
        }

        .header-actions {
            display: flex;
            gap: clamp(4px, 1.2vw, 8px);
            align-items: center;
        }

        .mode-toggle-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: var(--header-btn-size);
        }

        .mode-toggle-status {
            position: absolute;
            left: 50%;
            top: calc(100% - 4px);
            transform: translate(-50%, -4px);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.68rem;
            color: var(--text-secondary);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .mode-toggle-status .save-indicator {
            width: 8px;
            height: 8px;
            box-shadow: 0 0 0 1.5px rgba(0,0,0,0.08);
        }

        .mode-toggle-status .save-timestamp {
            font-size: 0.68rem;
        }

        .mode-toggle-btn {
            min-width: 132px;
            min-height: var(--header-btn-size);
            height: var(--header-btn-size);
            justify-content: space-between;
            padding: 0 12px;
            transition: height 0.22s ease, min-height 0.22s ease, transform 0.22s ease, padding 0.22s ease;
        }

        .mode-toggle-btn.is-editing {
            min-height: 36px;
            height: 36px;
            transform: translateY(-4px);
        }

        .mode-toggle-btn.is-editing + .mode-toggle-status {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        .mode-toggle-text {
            display: inline-block;
            width: 72px;
            text-align: left;
            font-weight: 600;
            letter-spacing: 0.01em;
        }

        .mode-toggle-pill {
            width: 38px;
            height: 20px;
            border-radius: 999px;
            background: rgba(0,0,0,0.15);
            position: relative;
            transition: background 0.2s ease;
            flex: 0 0 auto;
        }

        .mode-toggle-knob {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }

        .mode-toggle-btn.is-editing .mode-toggle-pill {
            background: var(--accent-orange);
        }

        .mode-toggle-btn.is-editing .mode-toggle-knob {
            transform: translateX(18px);
        }

        .save-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
            box-shadow: 0 0 0 2px rgba(0,0,0,0.08);
            transition: opacity 0.25s ease, background-color 0.25s ease;
        }

        .save-indicator.saving {
            background: var(--accent-orange);
        }

        .save-indicator.saved {
            background: var(--accent-green);
        }

        .save-indicator.error {
            background: var(--accent-red);
        }

        .save-timestamp {
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.75;
            letter-spacing: 0.01em;
            transition: opacity 0.25s ease;
        }

        .save-indicator.flash {
            animation: save-indicator-flash 0.45s ease;
        }

        .save-timestamp.flash {
            animation: save-text-fade 0.45s ease;
        }

        @keyframes save-indicator-flash {
            0% { opacity: 0.45; }
            100% { opacity: 1; }
        }

        @keyframes save-text-fade {
            0% { opacity: 0.35; }
            100% { opacity: 0.75; }
        }

        #editor-view.read-only #toolbar {
            opacity: 0;
            pointer-events: none;
        }

        #editor-view.read-only .save-indicator,
        #editor-view.read-only .save-timestamp {
            opacity: 0;
            pointer-events: none;
        }

        #editor-view.read-only #add-page-indicator {
            opacity: 0 !important;
        }

        #editor-view.read-only .selection-box {
            pointer-events: none;
        }

        #editor-view.read-only .doc-title {
            cursor: default;
        }

        #status-bar {
            display: none;
        }

        #btn-add-page {
            display: none;
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            border: none;
            border-radius: var(--radius-md);
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
            flex: 0 0 auto;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-icon {
            padding: 10px;
            min-width: 44px;
            min-height: 44px;
        }

        .btn-icon-square {
            width: var(--header-btn-size);
            height: var(--header-btn-size);
            padding: 0;
        }

        .btn-primary {
            background: var(--text-primary);
            color: white;
        }

        .btn-primary:hover {
            background: #333;
        }

        .btn-warning {
            background: var(--accent-orange);
            color: white;
        }

        .btn-warning:hover {
            background: #d36f33;
        }

        .btn-secondary {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: rgba(255,255,255,0.08);
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-primary {
            background: #f5f5f5;
            color: #111;
        }

        [data-theme="dark"] .btn-primary:hover {
            background: #ffffff;
        }

        .btn-secondary:hover {
            background: rgba(0,0,0,0.1);
        }

        .btn svg {
            width: 18px;
            height: 18px;
        }

        #canvas-viewport {
            flex: 1;
            overflow: hidden;
            background: #2c2c2c;
            position: relative;
            cursor: grab;
        }

        [data-theme="dark"] #canvas-viewport {
            background: #121212;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px;
            gap: 30px;
        }

        .page-wrapper {
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border-radius: 2px;
            overflow: hidden;
            flex-shrink: 0;
            background: white;
        }

        .page-wrapper.new-page {
            animation: pageFadeIn 0.5s ease;
        }

        @keyframes pageFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .page-canvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }

        .lasso-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .cursor-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed rgba(0, 47, 217, 0.55);
            border-radius: 8px;
            box-sizing: border-box;
            pointer-events: auto;
            touch-action: none;
            background: rgba(0, 47, 217, 0.03);
        }

        .selection-box.hidden {
            display: none;
        }

        .selection-box .selection-handle,
        .selection-box .rotate-handle {
            position: absolute;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0, 47, 217, 0.7);
            box-shadow: none;
            opacity: 0.9;
        }

        .selection-box .selection-handle {
            width: var(--selection-handle-size);
            height: var(--selection-handle-size);
        }

        .selection-box .rotate-handle {
            width: var(--rotate-handle-size);
            height: var(--rotate-handle-size);
        }

        .selection-trash {
            position: absolute;
            top: -42px;
            right: -42px;
            width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.98);
            color: var(--accent-red);
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            padding: 0;
        }

        .selection-duplicate {
            position: absolute;
            top: -42px;
            right: 4px;
            width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.98);
            color: var(--accent-blue);
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            padding: 0;
        }

        .selection-box.has-selection .selection-trash {
            display: flex;
        }

        .selection-box.has-selection .selection-duplicate {
            display: flex;
        }

        .selection-trash:hover {
            background: rgba(232, 16, 16, 0.08);
        }

        .selection-duplicate:hover {
            background: rgba(0, 47, 217, 0.08);
        }

        .selection-trash svg {
            width: 16px;
            height: 16px;
        }

        .selection-duplicate svg {
            width: 16px;
            height: 16px;
        }

        .selection-box .selection-handle.edge {
            border-radius: 3px;
        }

        .selection-box .handle-n { top: var(--selection-handle-offset); left: 50%; transform: translate(-50%, -50%); cursor: ns-resize; }
        .selection-box .handle-s { bottom: var(--selection-handle-offset); left: 50%; transform: translate(-50%, 50%); cursor: ns-resize; }
        .selection-box .handle-e { right: var(--selection-handle-offset); top: 50%; transform: translate(50%, -50%); cursor: ew-resize; }
        .selection-box .handle-w { left: var(--selection-handle-offset); top: 50%; transform: translate(-50%, -50%); cursor: ew-resize; }
        .selection-box .handle-ne { right: var(--selection-handle-offset); top: var(--selection-handle-offset); transform: translate(50%, -50%); cursor: nesw-resize; }
        .selection-box .handle-nw { left: var(--selection-handle-offset); top: var(--selection-handle-offset); transform: translate(-50%, -50%); cursor: nwse-resize; }
        .selection-box .handle-se { right: var(--selection-handle-offset); bottom: var(--selection-handle-offset); transform: translate(50%, 50%); cursor: nwse-resize; }
        .selection-box .handle-sw { left: var(--selection-handle-offset); bottom: var(--selection-handle-offset); transform: translate(-50%, 50%); cursor: nesw-resize; }

        .selection-box .selection-rotate-line {
            position: absolute;
            width: 1px;
            height: 10px;
            background: rgba(0, 47, 217, 0.7);
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
        }

        .selection-box .rotate-handle {
            top: -28px;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }

        #add-page-indicator {
            position: absolute;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px dashed rgba(255, 222, 0, 0.95);
            color: rgba(255, 222, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            background: rgba(20,20,20,0.25);
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        }

        .page-number {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            pointer-events: none;
            opacity: 0.6;
        }

        #toolbar {
            position: fixed;
            left: 20px;
            top: 50%;
            --toolbar-scale: 1;
            --toolbar-translate: -50%;
            --toolbar-rotate: 0deg;
            transform: translateY(var(--toolbar-translate)) scale(var(--toolbar-scale)) rotate(var(--toolbar-rotate));
            transform-origin: top left;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0,0,0,0.06);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-medium);
            padding: var(--toolbar-padding);
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 1000;
            opacity: 1;
            transition: border-radius 0.2s ease, opacity 0.25s ease;
            touch-action: none;
            user-select: none;
            backdrop-filter: blur(8px);
        }

        #toolbar.toolbar-flash {
            animation: toolbar-fade 0.45s ease;
        }

        @keyframes toolbar-fade {
            0% { opacity: 0.35; }
            100% { opacity: 1; }
        }

        #toolbar.toolbar-tilt-forward {
            animation: toolbar-tilt-forward 0.36s cubic-bezier(0.22, 0.61, 0.36, 1);
        }

        #toolbar.toolbar-tilt-back {
            animation: toolbar-tilt-back 0.36s cubic-bezier(0.22, 0.61, 0.36, 1);
        }

        #toolbar.horizontal {
            flex-direction: row;
            flex-wrap: nowrap;
            justify-content: center;
            align-items: center;
        }

        #toolbar.snapping {
            transition: left 0.2s ease, top 0.2s ease, right 0.2s ease, bottom 0.2s ease;
        }

        #toolbar-handle {
            width: var(--handle-width);
            height: var(--handle-height);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            color: var(--text-secondary);
            border-radius: var(--radius-sm);
            transition: background 0.2s;
        }

        #toolbar-handle:hover {
            background: rgba(0,0,0,0.05);
        }

        #toolbar-handle:active {
            cursor: grabbing;
        }

        #toolbar-handle svg {
            width: var(--icon-size);
            height: var(--icon-size);
        }

        #toolbar.horizontal #toolbar-handle {
            width: var(--handle-height);
            height: var(--handle-width);
        }

        #toolbar #toolbar-handle svg {
            --handle-rotation: 0deg;
            transform: rotate(calc(var(--handle-rotation) - var(--toolbar-rotate)));
            transition: transform 0.2s ease;
        }

        #toolbar.horizontal #toolbar-handle svg {
            --handle-rotation: 90deg;
        }

        #toolbar .tool-btn svg {
            transform: rotate(calc(-1 * var(--toolbar-rotate)));
            transition: transform 0.2s ease;
        }

        .tool-btn {
            width: var(--tool-size);
            height: var(--tool-size);
            border: none;
            border-radius: var(--radius-md);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
            touch-action: manipulation;
            flex: 0 0 auto;
        }

        .tool-btn:hover {
            background: rgba(0,0,0,0.05);
        }

        .tool-btn.active {
            background: var(--accent-yellow);
        }

        .tool-btn svg {
            width: var(--icon-size);
            height: var(--icon-size);
        }

        @keyframes toolbar-tilt-forward {
            0% {
                --toolbar-rotate: 0deg;
            }
            50% {
                --toolbar-rotate: var(--toolbar-tilt);
            }
            100% {
                --toolbar-rotate: 0deg;
            }
        }

        @keyframes toolbar-tilt-back {
            0% {
                --toolbar-rotate: 0deg;
            }
            50% {
                --toolbar-rotate: calc(-1 * var(--toolbar-tilt));
            }
            100% {
                --toolbar-rotate: 0deg;
            }
        }

        .tool-btn.size-btn {
            width: calc(var(--tool-size) * 0.7);
            height: calc(var(--tool-size) * 0.7);
        }

        .size-dot {
            display: inline-block;
            border-radius: 50%;
            background: var(--text-primary);
            opacity: 0.7;
        }

        .size-dot.sm { width: 6px; height: 6px; }
        .size-dot.md { width: 10px; height: 10px; }
        .size-dot.lg { width: 14px; height: 14px; }

        .color-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid transparent;
        }

        .tool-btn.active .color-dot {
            border-color: var(--text-primary);
        }

        .tool-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tool-btn:disabled:hover {
            background: transparent;
        }

        .tool-divider {
            height: 1px;
            background: rgba(0,0,0,0.1);
            margin: 4px 0;
            width: calc(var(--tool-size) * 0.6);
            align-self: center;
        }

        #toolbar.horizontal .tool-divider {
            width: 1px;
            height: calc(var(--tool-size) * 0.6);
            margin: 0 4px;
        }

        .eraser-menu {
            position: fixed;
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-medium);
            z-index: 1500;
            min-width: 180px;
        }

        .eraser-menu.visible {
            display: flex;
        }

        .eraser-menu-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .eraser-menu-options {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .eraser-menu .tool-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
        }

        .eraser-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .eraser-toggle input {
            appearance: none;
            width: 38px;
            height: 20px;
            border-radius: 999px;
            background: rgba(0,0,0,0.15);
            position: relative;
            outline: none;
            transition: background 0.2s ease;
            cursor: pointer;
        }

        .eraser-toggle input::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }

        .eraser-toggle input:checked {
            background: var(--text-primary);
        }

        .eraser-toggle input:checked::after {
            transform: translateX(18px);
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .theme-toggle input {
            appearance: none;
            width: 38px;
            height: 20px;
            border-radius: 999px;
            background: rgba(0,0,0,0.15);
            position: relative;
            outline: none;
            transition: background 0.2s ease;
            cursor: pointer;
        }

        .theme-toggle input::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            top: 3px;
            left: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }

        .theme-toggle input:checked {
            background: var(--text-primary);
        }

        .theme-toggle input:checked::after {
            transform: translateX(18px);
        }

        #status-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-medium);
            padding: 8px 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.2vw, 8px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #status-bar.visible {
            opacity: 1;
        }

        #status-bar .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-medium);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal h2 {
            font-size: 1.25rem;
            margin-bottom: 16px;
        }

        .confirm-slider {
            position: relative;
            height: 52px;
            border-radius: 16px;
            background: rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.08);
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .confirm-slider-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            background: rgba(224, 122, 60, 0.18);
            transition: width 0.2s ease;
        }

        .confirm-slider-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.95rem;
            color: var(--text-secondary);
            pointer-events: none;
            transition: color 0.2s ease;
        }

        .confirm-slider-handle {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 44px;
            height: 44px;
            border-radius: 14px;
            background: var(--accent-orange);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 18px rgba(0,0,0,0.18);
            transition: transform 0.2s ease;
        }

        .confirm-slider.dragging .confirm-slider-handle,
        .confirm-slider.dragging .confirm-slider-fill {
            transition: none;
        }

        .confirm-slider.complete .confirm-slider-fill {
            background: rgba(224, 122, 60, 0.9);
        }

        .confirm-slider.complete .confirm-slider-text {
            color: white;
        }

        .modal-input {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 12px;
            border-radius: var(--radius-md);
            background: rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.08);
        }

        .modal-input input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 0.95rem;
            font-family: inherit;
            color: var(--text-primary);
            outline: none;
        }

        .modal-input .file-ext {
            font-size: 0.9rem;
            color: var(--text-secondary);
            user-select: none;
        }

        .modal-actions {
            display: flex;
            gap: clamp(4px, 1.2vw, 8px);
            margin-top: 20px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        #file-input, #pdf-input {
            display: none;
        }

        #pages-panel {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background: var(--bg-secondary);
            box-shadow: -4px 0 30px rgba(0,0,0,0.15);
            z-index: 1500;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        #pages-panel.visible {
            right: 0;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0,0,0,0.08);
        }

        .panel-header h2 {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .panel-close {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .panel-close:hover {
            background: rgba(0,0,0,0.05);
        }

        .panel-close svg {
            width: 20px;
            height: 20px;
        }

        .pages-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .page-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .page-item:hover {
            background: rgba(0,0,0,0.06);
        }

        .page-thumbnail {
            width: 50px;
            height: 70px;
            background: white;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .page-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .page-info {
            flex: 1;
            min-width: 0;
        }

        .page-info h3 {
            font-size: 0.9375rem;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .page-info p {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .page-actions {
            display: flex;
            gap: 4px;
        }

        .page-action-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            color: var(--text-secondary);
        }

        .page-action-btn:hover {
            background: rgba(0,0,0,0.08);
            color: var(--text-primary);
        }

        .page-action-btn.delete:hover {
            background: rgba(255,59,48,0.1);
            color: #ff3b30;
        }

        .page-action-btn svg {
            width: 18px;
            height: 18px;
        }

        .panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: 1400;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .panel-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-danger .btn-primary {
            background: #ff3b30;
        }

        .modal-danger .btn-primary:hover {
            background: #e6352b;
        }

        .modal-warning .btn-primary {
            background: var(--accent-orange);
        }

        .modal-warning .btn-primary:hover {
            background: #d36f33;
        }

        .saving .status-dot {
            animation: pulse 1s infinite;
            background: var(--accent-yellow);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 768px) {
            #toolbar {
                left: 10px;
            }

            #canvas-container {
                padding: 20px;
            }
        }

        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-text {
            color: white;
            margin-top: 16px;
            font-size: 0.875rem;
        }

        /* Drive home */
        #drive-home {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            z-index: 1200;
        }

        #drive-home.hidden {
            display: none;
        }

        .drive-topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            min-height: var(--banner-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid rgba(0,0,0,0.06);
            gap: 12px;
        }

        .drive-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        #btn-drive-new {
            min-height: var(--header-btn-size);
            padding-top: 10px;
            padding-bottom: 10px;
        }

        #btn-drive-login {
            min-height: var(--header-btn-size);
            padding-top: 10px;
            padding-bottom: 10px;
        }

        .drive-profile {
            position: relative;
            display: flex;
            align-items: center;
        }

        .drive-profile-btn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
            background: white;
            padding: 0;
            cursor: pointer;
            overflow: hidden;
            display: grid;
            place-items: center;
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }

        .drive-profile-btn:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            transform: translateY(-1px);
        }

        .drive-profile-avatar {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .drive-profile-menu {
            position: absolute;
            right: 0;
            top: calc(100% + 10px);
            background: white;
            border-radius: 16px;
            padding: 14px;
            min-width: 240px;
            box-shadow: 0 18px 40px rgba(0,0,0,0.18);
            border: 1px solid rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 2000;
        }

        [data-theme="dark"] .drive-profile-btn,
        [data-theme="dark"] .drive-profile-menu {
            background: #1f1f1f;
            border-color: rgba(255,255,255,0.08);
        }

        .drive-profile-meta {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .drive-profile-meta .drive-profile-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
        }

        .drive-profile-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .drive-profile-email {
            font-size: 0.75rem;
            color: var(--text-secondary);
            word-break: break-all;
        }

        .drive-profile-actions {
            display: flex;
            gap: 8px;
        }

        .drive-profile-actions .btn {
            flex: 1;
        }

        .drive-main {
            flex: 1;
            overflow: auto;
            padding: 20px;
            padding-bottom: 80px;
        }

        .drive-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }

        .drive-search {
            flex: 1;
            min-width: 240px;
            max-width: 420px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.08);
            background: white;
            font-family: inherit;
            font-size: 0.9rem;
        }

        [data-theme="dark"] .drive-search {
            background: #1f1f1f;
            border-color: rgba(255,255,255,0.08);
            color: var(--text-primary);
        }

        .drive-search:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .drive-status {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .drive-section {
            margin-bottom: 28px;
        }

        .drive-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .drive-section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .drive-recents {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
            scroll-snap-type: x mandatory;
        }

        .drive-recents::-webkit-scrollbar {
            height: 8px;
        }

        .drive-recents::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.12);
            border-radius: 999px;
        }

        .drive-recents .drive-card {
            min-width: 190px;
            flex: 0 0 190px;
            scroll-snap-align: start;
        }

        .drive-breadcrumbs {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
            font-size: 0.82rem;
            color: var(--text-secondary);
        }

        .drive-breadcrumb {
            background: none;
            border: none;
            padding: 0;
            font: inherit;
            color: inherit;
            cursor: pointer;
        }

        .drive-breadcrumb.active {
            color: var(--text-primary);
            font-weight: 600;
            cursor: default;
        }

        .drive-folder-grid,
        .drive-file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
        }

        .drive-folder-grid {
            margin-bottom: 16px;
        }

        .drive-card {
            background: white;
            border-radius: 14px;
            padding: 14px;
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 6px 18px rgba(0,0,0,0.06);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 128px;
            position: relative;
        }

        .drive-card:hover {
            box-shadow: 0 10px 24px rgba(0,0,0,0.08);
        }

        .drive-card-preview {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0,0,0,0.04);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drive-card-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top center;
        }

        .drive-card-icon {
            width: 40px;
            height: 40px;
            color: rgba(0,0,0,0.4);
        }

        .drive-card-icon.folder {
            color: var(--accent-orange);
        }

        .drive-card-menu {
            position: absolute;
            top: 8px;
            right: 8px;
            z-index: 5;
        }

        .drive-card-more {
            width: 30px;
            height: 30px;
            border-radius: 10px;
            border: none;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            display: grid;
            place-items: center;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .drive-card-more:hover {
            color: var(--text-primary);
        }

        .drive-card-dropdown {
            position: absolute;
            top: 36px;
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 14px 32px rgba(0,0,0,0.16);
            border: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 160px;
            z-index: 10;
        }

        [data-theme="dark"] .drive-card,
        [data-theme="dark"] .drive-folder-card,
        [data-theme="dark"] .drive-card-dropdown,
        [data-theme="dark"] .drive-card-more,
        [data-theme="dark"] .drive-card-preview,
        [data-theme="dark"] .bin-item,
        [data-theme="dark"] .bin-item-dropdown,
        [data-theme="dark"] .folder-picker-item,
        [data-theme="dark"] .modal {
            background: #1f1f1f;
            border-color: rgba(255,255,255,0.08);
            box-shadow: 0 6px 18px rgba(0,0,0,0.3);
        }

        [data-theme="dark"] .drive-card-preview,
        [data-theme="dark"] .bin-item {
            background: rgba(255,255,255,0.04);
        }

        [data-theme="dark"] .drive-card-more,
        [data-theme="dark"] .bin-item-more {
            background: rgba(0,0,0,0.6);
            color: var(--text-primary);
            border: 1px solid rgba(255,255,255,0.12);
        }

        [data-theme="dark"] .drive-card-dropdown,
        [data-theme="dark"] .bin-item-dropdown {
            border-color: rgba(255,255,255,0.08);
        }

        [data-theme="dark"] .folder-picker-meta {
            background: rgba(255,255,255,0.04);
            border-color: rgba(255,255,255,0.08);
        }

        [data-theme="dark"] .drive-empty {
            background: rgba(255,255,255,0.04);
            border-color: rgba(255,255,255,0.1);
        }

        .drive-card-dropdown button {
            border: none;
            background: transparent;
            padding: 8px 10px;
            border-radius: 8px;
            text-align: left;
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drive-card-dropdown button svg {
            width: 16px;
            height: 16px;
        }

        .drive-card-dropdown button:hover {
            background: rgba(0,0,0,0.06);
        }

        .drive-card-dropdown button.danger {
            color: #ff3b30;
        }

        .drive-card-dropdown button.danger:hover {
            background: rgba(255,59,48,0.1);
        }

        .folder-picker {
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 14px;
            padding: 12px;
            max-height: 260px;
            overflow: auto;
            background: rgba(0,0,0,0.02);
            margin: 14px 0;
        }

        .folder-picker-meta {
            margin-top: 8px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.08);
            background: rgba(0,0,0,0.03);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .folder-picker-meta-label {
            font-size: 0.68rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
        }

        .folder-picker-meta-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .folder-picker-meta-path {
            font-size: 0.78rem;
            color: var(--text-secondary);
            word-break: break-word;
        }

        .folder-picker-breadcrumbs {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 0.8rem;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .folder-picker-breadcrumb {
            background: none;
            border: none;
            padding: 0;
            font: inherit;
            color: inherit;
            cursor: pointer;
        }

        .folder-picker-breadcrumb.active {
            color: var(--text-primary);
            font-weight: 600;
            cursor: default;
        }

        .folder-picker-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .folder-picker-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            background: white;
            border: 1px solid rgba(0,0,0,0.04);
        }

        .folder-picker-item:hover {
            background: rgba(0,0,0,0.04);
        }

        .folder-picker-item svg {
            width: 20px;
            height: 20px;
            color: var(--accent-orange);
        }

        .bin-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 260px;
            min-height: 220px;
            overflow: auto;
            margin-top: 12px;
            padding-bottom: 64px;
            scroll-padding-bottom: 64px;
        }

        .bin-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(0,0,0,0.02);
            border: 1px solid rgba(0,0,0,0.06);
            position: relative;
        }

        .bin-item svg {
            width: 18px;
            height: 18px;
            color: var(--text-secondary);
            flex: 0 0 auto;
        }

        .bin-item-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .bin-item-menu {
            margin-left: auto;
            position: relative;
        }

        .bin-item-more {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: none;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            display: grid;
            place-items: center;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .bin-item-dropdown {
            position: absolute;
            right: 0;
            top: 34px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 12px 26px rgba(0,0,0,0.18);
            border: 1px solid rgba(0,0,0,0.08);
            padding: 6px;
            min-width: 160px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 10;
        }

        .bin-item-dropdown button {
            border: none;
            background: transparent;
            padding: 8px 10px;
            border-radius: 8px;
            text-align: left;
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bin-item-dropdown button:hover {
            background: rgba(0,0,0,0.06);
        }

        .bin-item-dropdown svg {
            width: 16px;
            height: 16px;
        }

        .bin-loading {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        .bin-loading.hidden {
            display: none;
        }

        .mini-spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0,0,0,0.2);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        [data-theme="dark"] .mini-spinner {
            border-color: rgba(255,255,255,0.18);
            border-top-color: var(--text-primary);
        }

        .drive-folder-card {
            background: white;
            border-radius: 14px;
            padding: 14px 16px;
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 6px 18px rgba(0,0,0,0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .drive-folder-card:hover {
            box-shadow: 0 10px 24px rgba(0,0,0,0.08);
        }

        .drive-folder-icon {
            width: 36px;
            height: 28px;
            color: var(--accent-orange);
        }

        .drive-card-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .drive-card-meta {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .drive-empty {
            padding: 24px;
            text-align: center;
            color: var(--text-secondary);
            border: 1px dashed rgba(0,0,0,0.12);
            border-radius: 16px;
            background: rgba(255,255,255,0.6);
        }

        #editor-view.hidden {
            display: none;
        }

        #editor-view {
            height: 100%;
            width: 100%;
        }

        .doc-title {
            display: inline-flex;
            align-items: center;
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-left: 12px;
            padding: 4px 8px;
            border-radius: 8px;
            max-width: 320px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: text;
        }

        .doc-title.editing,
        .doc-title:focus {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
            outline: 2px solid rgba(0, 47, 217, 0.3);
            outline-offset: 2px;
            max-width: 420px;
            text-overflow: clip;
        }
    </style>
</head>
<body>
    <div id="drive-home">
        <div class="drive-topbar">
            <div class="drive-brand">
                <svg viewBox="0 0 40 24" fill="none">
                    <path d="M4 22 L20 6 L36 22" stroke="#E07A3C" stroke-width="4.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                </svg>
                <span>inhouse notes</span>
            </div>
            <div class="drive-actions">
                <button class="btn btn-secondary btn-icon-square" id="btn-drive-fullscreen" title="Fullscreen" aria-label="Fullscreen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 3 21 3 21 9"/>
                        <polyline points="9 21 3 21 3 15"/>
                        <line x1="21" y1="3" x2="14" y2="10"/>
                        <line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
                <button class="btn btn-primary" id="btn-drive-new">New PDF</button>
                <button class="btn btn-primary" id="btn-drive-login">Sign in</button>
                <div class="drive-profile hidden" id="drive-profile">
                    <button class="drive-profile-btn" id="btn-drive-profile" type="button" aria-label="Account menu" aria-haspopup="menu" aria-expanded="false">
                        <img class="drive-profile-avatar" id="drive-profile-avatar" alt="Profile">
                    </button>
                    <div class="drive-profile-menu hidden" id="drive-profile-menu" role="menu">
                        <div class="drive-profile-meta">
                            <img class="drive-profile-avatar" id="drive-profile-avatar-menu" alt="Profile">
                            <div>
                                <div class="drive-profile-name" id="drive-profile-name">Signed in</div>
                                <div class="drive-profile-email" id="drive-profile-email"></div>
                            </div>
                        </div>
                        <label class="theme-toggle" for="theme-toggle">
                            <span>Night mode</span>
                            <input type="checkbox" id="theme-toggle" aria-label="Night mode">
                        </label>
                        <div class="drive-profile-actions">
                            <button class="btn btn-secondary" id="btn-drive-menu-refresh" type="button">Refresh</button>
                            <button class="btn btn-secondary" id="btn-drive-menu-logout" type="button">Sign out</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="drive-main">
            <div class="drive-toolbar">
                <button class="btn btn-secondary btn-icon-square" id="btn-drive-bin" title="Bin" aria-label="Bin">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                </button>
                <input class="drive-search" id="drive-search" type="text" placeholder="Search PDFs..." autocomplete="off">
                <div class="drive-status" id="drive-status">Sign in to browse your Drive.</div>
            </div>
            <section class="drive-section">
                <div class="drive-section-header">
                    <div class="drive-section-title">Recents</div>
                </div>
                <div class="drive-recents" id="drive-recents"></div>
            </section>
            <section class="drive-section">
                <div class="drive-section-header">
                    <div class="drive-section-title">Starred</div>
                </div>
                <div class="drive-recents" id="drive-starred"></div>
                <div class="drive-empty hidden" id="drive-starred-empty">No starred PDFs yet.</div>
            </section>
            <section class="drive-section">
                <div class="drive-section-header">
                    <div class="drive-section-title">My Drive</div>
                    <button class="btn btn-secondary btn-icon-square" id="btn-drive-back" title="Up one folder" aria-label="Up one folder">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 18 9 12 15 6"/>
                        </svg>
                    </button>
                </div>
                <div class="drive-breadcrumbs" id="drive-breadcrumbs"></div>
                <div class="drive-folder-grid" id="drive-folders"></div>
                <div class="drive-file-grid" id="drive-folder-files"></div>
                <div class="drive-empty hidden" id="drive-folder-empty">No PDFs found in this folder.</div>
            </section>
        </div>
    </div>

    <div id="editor-view" class="hidden">
    <div id="app">
        <header>
            <div class="logo" id="btn-drive-home" role="button" tabindex="0" title="Drive Home" aria-label="Drive Home">
                <svg viewBox="0 0 40 24" fill="none">
                    <path d="M4 22 L20 6 L36 22" stroke="#E07A3C" stroke-width="4.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                </svg>
                <span>inhouse notes</span>
                <span class="doc-title" id="doc-title" role="textbox" aria-label="Document title" contenteditable="true" spellcheck="false">Untitled</span>
            </div>
            <div class="header-actions">
                <div class="mode-toggle-group">
                    <button class="btn btn-secondary mode-toggle-btn" id="mode-toggle-btn" type="button" aria-pressed="false" aria-label="Read mode" title="Toggle read/edit mode">
                        <span class="mode-toggle-text" id="mode-toggle-label">Read</span>
                        <span class="mode-toggle-pill" aria-hidden="true">
                            <span class="mode-toggle-knob"></span>
                        </span>
                    </button>
                    <div class="mode-toggle-status">
                        <div class="save-indicator saved" id="save-indicator" title="Saved" aria-label="Saved"></div>
                        <span class="save-timestamp" id="save-timestamp" aria-live="polite"></span>
                    </div>
                </div>
                <button class="btn btn-secondary btn-icon-square" id="btn-fullscreen" title="Fullscreen" aria-label="Fullscreen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="15 3 21 3 21 9"/>
                        <polyline points="9 21 3 21 3 15"/>
                        <line x1="21" y1="3" x2="14" y2="10"/>
                        <line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
                <button class="btn btn-secondary btn-icon-square" id="btn-edit-pages" title="Manage Pages" aria-label="Manage Pages">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                </button>
                <button class="btn btn-secondary btn-icon-square" id="btn-import-pdf" title="Import PDF" aria-label="Import PDF">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <polyline points="9 15 12 12 15 15"/>
                    </svg>
                </button>
                <button class="btn btn-primary btn-icon-square" id="btn-export-pdf" title="Export PDF" aria-label="Export PDF">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <polyline points="9 15 12 18 15 15"/>
                    </svg>
                </button>
                <div class="drive-profile hidden" id="drive-profile-editor">
                    <button class="drive-profile-btn" id="btn-drive-profile-editor" type="button" aria-label="Account menu" aria-haspopup="menu" aria-expanded="false">
                        <img class="drive-profile-avatar" id="drive-profile-avatar-editor" alt="Profile">
                    </button>
                    <div class="drive-profile-menu hidden" id="drive-profile-menu-editor" role="menu">
                        <div class="drive-profile-meta">
                            <img class="drive-profile-avatar" id="drive-profile-avatar-menu-editor" alt="Profile">
                            <div>
                                <div class="drive-profile-name" id="drive-profile-name-editor">Signed in</div>
                                <div class="drive-profile-email" id="drive-profile-email-editor"></div>
                            </div>
                        </div>
                        <label class="theme-toggle" for="theme-toggle-editor">
                            <span>Night mode</span>
                            <input type="checkbox" id="theme-toggle-editor" aria-label="Night mode">
                        </label>
                        <div class="drive-profile-actions">
                            <button class="btn btn-secondary" id="btn-drive-menu-refresh-editor" type="button">Refresh</button>
                            <button class="btn btn-secondary" id="btn-drive-menu-logout-editor" type="button">Sign out</button>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <div id="canvas-viewport">
            <div id="canvas-container"></div>
        </div>

        <div id="toolbar">
            <div id="toolbar-handle" title="Drag to move">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                    <circle cx="9" cy="6" r="1.5" fill="currentColor"/>
                    <circle cx="15" cy="6" r="1.5" fill="currentColor"/>
                    <circle cx="9" cy="12" r="1.5" fill="currentColor"/>
                    <circle cx="15" cy="12" r="1.5" fill="currentColor"/>
                    <circle cx="9" cy="18" r="1.5" fill="currentColor"/>
                    <circle cx="15" cy="18" r="1.5" fill="currentColor"/>
                </svg>
            </div>
            <div class="tool-divider"></div>
            <button class="tool-btn" data-tool="pen" data-color="#4D4D4D" data-width="2" title="Black Pen">
                <svg viewBox="0 0 24 24" fill="none">
                    <path d="M4 20h4l11-11a2 2 0 0 0 0-2.83l-1.17-1.17a2 2 0 0 0-2.83 0L4 16v4z" fill="#4D4D4D" stroke="#4D4D4D" stroke-width="1.5" stroke-linejoin="round"/>
                    <path d="M13.5 6.5l4 4" stroke="white" stroke-width="1" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="tool-btn active" data-tool="pen" data-color="#002FD9" data-width="2" title="Blue Pen">
                <svg viewBox="0 0 24 24" fill="none">
                    <path d="M4 20h4l11-11a2 2 0 0 0 0-2.83l-1.17-1.17a2 2 0 0 0-2.83 0L4 16v4z" fill="#002FD9" stroke="#002FD9" stroke-width="1.5" stroke-linejoin="round"/>
                    <path d="M13.5 6.5l4 4" stroke="white" stroke-width="1" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="pen" data-color="#E81010" data-width="2" title="Red Pen">
                <svg viewBox="0 0 24 24" fill="none">
                    <path d="M4 20h4l11-11a2 2 0 0 0 0-2.83l-1.17-1.17a2 2 0 0 0-2.83 0L4 16v4z" fill="#E81010" stroke="#E81010" stroke-width="1.5" stroke-linejoin="round"/>
                    <path d="M13.5 6.5l4 4" stroke="white" stroke-width="1" stroke-linecap="round"/>
                </svg>
            </button>
            <div class="tool-divider"></div>
            <button class="tool-btn" data-tool="highlighter" data-color="#ffde00" data-width="16" title="Highlighter">
                <svg viewBox="0 0 24 24" fill="none">
                    <rect x="6" y="3" width="6" height="14" rx="1" fill="#ffde00" stroke="#1a1a1a" stroke-width="1.2"/>
                    <path d="M6 17l3 4 3-4" fill="#ffde00" stroke="#1a1a1a" stroke-width="1.2" stroke-linejoin="round"/>
                    <rect x="7" y="5" width="4" height="3" fill="#fff" opacity="0.5" rx="0.5"/>
                </svg>
            </button>
            <div class="tool-divider"></div>
            <button class="tool-btn" data-tool="eraser" id="btn-eraser" title="Eraser">
                <svg viewBox="0 0 24 24" fill="none">
                    <rect x="3" y="10" width="18" height="8" rx="2" fill="#f5f5f5" stroke="currentColor" stroke-width="1.5"/>
                    <rect x="3" y="10" width="7" height="8" rx="2" fill="#ffb6c1" stroke="currentColor" stroke-width="1.5"/>
                    <path d="M3 18h18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="lasso" title="Lasso Select">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M6 8c0-2.5 2.7-4 6-4s6 1.5 6 4-2.7 4-6 4-6-1.5-6-4z"/>
                    <path d="M12 12c0 3-2 5-5 6"/>
                </svg>
            </button>
            <div class="tool-divider"></div>
            <button class="tool-btn" id="btn-undo" title="Undo (Ctrl+Z)" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                    <path d="M7 6l-4 4 4 4"/>
                </svg>
            </button>
            <button class="tool-btn" id="btn-redo" title="Redo (Ctrl+Y)" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                    <path d="M17 6l4 4-4 4"/>
                </svg>
            </button>
        </div>

        <div id="eraser-menu" class="eraser-menu" aria-hidden="true">
            <div class="eraser-menu-title">Eraser size</div>
            <div class="eraser-menu-options">
                <button class="tool-btn size-btn active" data-eraser-size="12" title="Small">
                    <span class="size-dot sm"></span>
                </button>
                <button class="tool-btn size-btn" data-eraser-size="22" title="Medium">
                    <span class="size-dot md"></span>
                </button>
                <button class="tool-btn size-btn" data-eraser-size="32" title="Large">
                    <span class="size-dot lg"></span>
                </button>
            </div>
            <label class="eraser-toggle" for="eraser-stroke-toggle">
                <span>Stroke eraser</span>
                <input type="checkbox" id="eraser-stroke-toggle">
            </label>
        </div>

        <div id="status-bar">
            <div class="status-dot"></div>
            <span id="status-text">Saved</span>
        </div>
    </div>
    </div>

    <div class="modal-overlay" id="modal-delete-page">
        <div class="modal modal-danger">
            <h2>Delete page?</h2>
            <p>This action will delete page <strong id="delete-page-number">1</strong> and all its strokes. This cannot be undone.</p>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="modal-delete-cancel">Cancel</button>
                <button class="btn btn-primary" id="modal-delete-confirm">Delete</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-reset-document">
        <div class="modal modal-warning">
            <h2>Start new document?</h2>
            <p>This action will clear all pages and strokes and start a fresh document. This cannot be undone.</p>
            <div class="confirm-slider" id="reset-slider" aria-label="Slide to start over">
                <div class="confirm-slider-fill" id="reset-slider-fill"></div>
                <div class="confirm-slider-text">Slide to start over</div>
                <div class="confirm-slider-handle" id="reset-slider-handle" aria-hidden="true">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 6 15 12 9 18"/>
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-export-pdf">
        <div class="modal">
            <h2>Export PDF</h2>
            <p>Choose a filename for your PDF.</p>
            <div class="modal-input">
                <input type="text" id="export-filename" placeholder="cuaderno" autocomplete="off" spellcheck="false">
                <span class="file-ext">.pdf</span>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="modal-export-cancel">Cancel</button>
                <button class="btn btn-primary" id="modal-export-confirm">Export</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-folder-picker">
        <div class="modal">
            <h2 id="folder-picker-title">New PDF</h2>
            <p id="folder-picker-subtitle">Choose a folder and name your file.</p>
            <div class="folder-picker-meta hidden" id="folder-picker-meta">
                <div class="folder-picker-meta-label">Moving</div>
                <div class="folder-picker-meta-name" id="folder-picker-file-name"></div>
                <div class="folder-picker-meta-path" id="folder-picker-file-path"></div>
            </div>
            <div class="folder-picker">
                <div class="folder-picker-breadcrumbs" id="folder-picker-breadcrumbs"></div>
                <div class="folder-picker-list" id="folder-picker-list"></div>
                <div class="drive-empty hidden" id="folder-picker-empty">No folders here.</div>
            </div>
            <div class="modal-input" id="folder-picker-name-row">
                <input type="text" id="folder-picker-name" placeholder="cuaderno" autocomplete="off" spellcheck="false">
                <span class="file-ext">.pdf</span>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="folder-picker-cancel">Cancel</button>
                <button class="btn btn-primary" id="folder-picker-confirm">Create</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-trash-file">
        <div class="modal modal-danger">
            <h2>Move to bin?</h2>
            <p>This will move <strong id="trash-file-name">this file</strong> to your Drive bin.</p>
            <div class="confirm-slider" id="trash-slider" aria-label="Slide to move to bin">
                <div class="confirm-slider-fill" id="trash-slider-fill"></div>
                <div class="confirm-slider-text">Slide to move to bin</div>
                <div class="confirm-slider-handle" id="trash-slider-handle" aria-hidden="true">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 6 15 12 9 18"/>
                    </svg>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="trash-file-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-drive-bin">
        <div class="modal">
            <h2>Bin</h2>
            <p>Files currently in your Drive bin.</p>
            <div class="bin-loading hidden" id="drive-bin-loading">
                <div class="mini-spinner" aria-hidden="true"></div>
                <span>Loading bin...</span>
            </div>
            <div class="bin-list" id="drive-bin-list"></div>
            <div class="drive-empty hidden" id="drive-bin-empty">Bin is empty.</div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="drive-bin-close">Close</button>
            </div>
        </div>
    </div>

    <div class="panel-overlay" id="panel-overlay"></div>

    <div id="pages-panel">
        <div class="panel-header">
            <h2>Manage Pages</h2>
            <button class="panel-close" id="panel-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        <div class="pages-list" id="pages-list"></div>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Loading PDF...</div>
    </div>

    <input type="file" id="pdf-input" accept=".pdf">

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // SVG Background
        const svgString = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 29.7" width="21cm" height="29.7cm">
            <defs>
                <filter id="softBlur" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="0.02" />
                </filter>
                <pattern id="dotGrid" x="1.75" y="1.68" width="0.5" height="0.5" patternUnits="userSpaceOnUse">
                    <circle cx="0.25" cy="0.25" r="0.035" fill="#a8a8a8" filter="url(#softBlur)" />
                </pattern>
            </defs>
            <!-- A4 Background -->
            <rect x="0" y="0" width="21" height="29.7" fill="white" />
            <!-- Main Yellow Frame -->
            <rect x="1.5" y="1.43" width="18" height="27" rx="0.03" ry="0.03" fill="none" stroke="#ffde00" stroke-width="0.06" />
            <!-- Dot Grid Area -->
            <rect x="1.75" y="1.68" width="17.5" height="25.5" fill="url(#dotGrid)" />
            <!-- Footer -->
            <g stroke="#ffde00" stroke-width="0.06" fill="none">
                <rect x="2.0" y="27.43" width="8.0" height="0.5" rx="0.03" ry="0.03" />
                <path d="M 2.5 27.43 v 0.5 M 3.0 27.43 v 0.5 M 3.5 27.43 v 0.5 M 4.0 27.43 v 0.5 M 4.5 27.43 v 0.5 M 5.0 27.43 v 0.5 M 5.5 27.43 v 0.5 M 6.0 27.43 v 0.5 M 6.5 27.43 v 0.5 M 7.0 27.43 v 0.5 M 7.5 27.43 v 0.5 M 8.0 27.43 v 0.5 M 8.5 27.43 v 0.5 M 9.0 27.43 v 0.5 M 9.5 27.43 v 0.5" />
                <rect x="11.0" y="27.43" width="8.0" height="0.5" rx="0.03" ry="0.03" />
                <path d="M 11.5 27.43 v 0.5 M 12.0 27.43 v 0.5 M 12.5 27.43 v 0.5 M 13.0 27.43 v 0.5 M 13.5 27.43 v 0.5 M 14.0 27.43 v 0.5 M 14.5 27.43 v 0.5 M 15.0 27.43 v 0.5 M 15.5 27.43 v 0.5 M 16.0 27.43 v 0.5 M 16.5 27.43 v 0.5 M 17.0 27.43 v 0.5 M 17.5 27.43 v 0.5 M 18.0 27.43 v 0.5 M 18.5 27.43 v 0.5" />
            </g>
            <!-- Footer Colors -->
            <g stroke="#ffde00" stroke-width="0.06">
                <circle cx="10.125" cy="27.68" r="0.125" fill="#ff0000" />
                <circle cx="10.375" cy="27.68" r="0.125" fill="#000000" />
                <circle cx="10.625" cy="27.68" r="0.125" fill="#0000ff" />
                <circle cx="10.875" cy="27.68" r="0.125" fill="#6eff12" />
            </g>
        </svg>`;
        const SVG_BACKGROUND = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgString)}`;
        const FULLSCREEN_ICON_ENTER = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="15 3 21 3 21 9"/>
                <polyline points="9 21 3 21 3 15"/>
                <line x1="21" y1="3" x2="14" y2="10"/>
                <line x1="3" y1="21" x2="10" y2="14"/>
            </svg>`;
        const FULLSCREEN_ICON_EXIT = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="4 14 10 14 10 20"/>
                <polyline points="20 10 14 10 14 4"/>
                <line x1="14" y1="10" x2="21" y2="3"/>
                <line x1="10" y1="14" x2="3" y2="21"/>
            </svg>`;
        const DEFAULT_AVATAR = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">' +
            '<defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1">' +
            '<stop offset="0%" stop-color="#f2f2f2"/><stop offset="100%" stop-color="#d9d9d9"/>' +
            '</linearGradient></defs>' +
            '<circle cx="32" cy="32" r="32" fill="url(#g)"/>' +
            '<circle cx="32" cy="26" r="12" fill="#b3b3b3"/>' +
            '<path d="M14 56c4-10 14-16 18-16s14 6 18 16" fill="#b3b3b3"/>' +
            '</svg>'
        )}`;

        // A4 dimensions - using 2x resolution for crisp drawing
        const A4_WIDTH = 794;
        const A4_HEIGHT = 1123;
        const CANVAS_SCALE = 2; // Fixed at 2x for memory optimization
        const PAGE_PADDING = 30;
        const PAGE_GAP = 30;
        const VISIBLE_PAGE_BUFFER = 1;
        const VISIBLE_PAGE_BUFFER_ACTIVE = 0;
        const MAX_ACTIVE_PAGES = 3;
        const MAX_PDF_BACKGROUND_CACHE = 6;
        const MAX_IMAGE_CACHE = 80;
        const PAGE_PREVIEW_SCALE = 0.18;
        const PDF_RENDER_SCALE_LARGE = 1.5;
        const PDF_RENDER_SCALE_HUGE = 1.2;
        const OVERLAY_SCALE = 1;
        const OVERSCROLL_THRESHOLD = 360;
        const OVERSCROLL_FRICTION = 0.24;
        const OVERSCROLL_MARGIN = 100;
        const CREATE_PAGE_MIN_BOTTOM_RATIO = 0.45;
        const LIVE_PREVIEW_POINTS = 6;
        const FINALIZE_STEP_POINTS = 6;
        const MIN_PAGE_VISIBLE = 5;
        const VIEW_STORAGE_KEY = 'notebook-view-v1';
        const VIEW_SAVE_DELAY = 250;
        const MAX_SAVE_INTERVAL = 15000;
        const PEN_DOUBLE_TAP_MS = 320;
        const PEN_DOUBLE_TAP_DIST = 42;
        const TOUCH_INERTIA_DECAY = 0.92;
        const TOUCH_INERTIA_STOP = 0.02;
        const DRIVE_SYNC_IDLE_DELAY = 15000;
        const DRIVE_SYNC_MAX_DELAY = 120000;
        const GOOGLE_CLIENT_ID = '435784295430-cmug30o42f1vu4ijgor9sjb0ro4oo37o.apps.googleusercontent.com';
        const DRIVE_SCOPE = 'https://www.googleapis.com/auth/drive';
        const DRIVE_FOLDER_NAME = 'Inhouse Notes';
        const DRIVE_TOKEN_KEY = 'drive-token-v1';
        const DRIVE_REMEMBER_KEY = 'drive-remember-v1';
        const DRIVE_SESSION_KEY = 'drive-session-v1';
        const THEME_KEY = 'inhouse-theme';
        const VIEW_MODE_KEY = 'notebook-view-mode-v1';
        const DATA_STORAGE_KEY = 'notebook-data-v3';
        const LEGACY_DATA_KEYS = ['notebook-data-v2'];
        const DB_NAME = 'notebook-data-db-v1';
        const DB_VERSION = 2;
        const DB_STORE = 'snapshots';
        const DB_KEY = 'latest';
        const PAGE_STORE = 'pages';

        const imageCache = new Map();
        const imageCacheUsage = new Map();
        const highlighterMaskCanvas = document.createElement('canvas');
        const highlighterMaskCtx = highlighterMaskCanvas.getContext('2d');
        const pageAccess = new Map();
        const pageDirty = new Set();
        const pageLoadQueue = new Map();
        let legacyPagesCache = null;

        // ============= MEMORY OPTIMIZATION UTILITIES =============

        // Efficient deep clone without JSON.parse/stringify
        function cloneStroke(stroke) {
            if (!stroke) return null;
            return {
                tool: stroke.tool,
                color: stroke.color,
                width: stroke.width,
                points: stroke.points.map(p => ({ x: p.x, y: p.y, p: p.p }))
            };
        }

        function cloneStrokesArray(strokes) {
            if (!Array.isArray(strokes)) return [];
            return strokes.map(cloneStroke);
        }

        // Douglas-Peucker line simplification algorithm
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const mag = Math.hypot(dx, dy);
            if (mag === 0) return Math.hypot(point.x - lineStart.x, point.y - lineStart.y);
            const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag);
            const closestX = lineStart.x + u * dx;
            const closestY = lineStart.y + u * dy;
            return Math.hypot(point.x - closestX, point.y - closestY);
        }

        function simplifyPoints(points, epsilon = 0.5) {
            if (!points || points.length < 3) return points;

            let maxDist = 0;
            let maxIndex = 0;
            const end = points.length - 1;

            for (let i = 1; i < end; i++) {
                const dist = perpendicularDistance(points[i], points[0], points[end]);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }

            if (maxDist > epsilon) {
                const left = simplifyPoints(points.slice(0, maxIndex + 1), epsilon);
                const right = simplifyPoints(points.slice(maxIndex), epsilon);
                return left.slice(0, -1).concat(right);
            }

            return [points[0], points[end]];
        }

        // Simplify stroke points to reduce memory
        function simplifyStrokePoints(stroke, epsilon = 0.45) {
            if (!stroke || !stroke.points) return stroke;

            const isHighlighter = stroke.tool === 'highlighter';
            const minPointsToSimplify = isHighlighter ? 6 : 8;
            if (stroke.points.length < minPointsToSimplify) return stroke;

            // Light simplification with a tiny distance filter
            const minDist = isHighlighter ? 0.4 : 0.18;
            const filtered = [stroke.points[0]];
            for (let i = 1; i < stroke.points.length - 1; i++) {
                const last = filtered[filtered.length - 1];
                const point = stroke.points[i];
                if (Math.hypot(point.x - last.x, point.y - last.y) >= minDist) {
                    filtered.push(point);
                }
            }
            filtered.push(stroke.points[stroke.points.length - 1]);

            // Keep more points for highlighter (needs smooth appearance)
            const adjustedEpsilon = isHighlighter ? epsilon * 1.3 : epsilon;

            // Preserve pressure data by mapping simplified indices
            const simplified = simplifyPoints(filtered, adjustedEpsilon);

            // Avoid over-simplifying handwriting details
            const minKeepRatio = isHighlighter ? 0.5 : 0.7;
            const minKeep = Math.max(3, Math.ceil(filtered.length * minKeepRatio));
            if (simplified.length < minKeep) {
                stroke.points = filtered;
                return stroke;
            }

            stroke.points = simplified;
            return stroke;
        }

        // Limit strokes array size by baking old strokes into background
        const MAX_STROKES_PER_PAGE = 500;
        const BAKE_THRESHOLD = 400;
        let bakingInProgress = new Set();

        function shouldBakeStrokes(pageIndex) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes) || bakingInProgress.has(pageIndex)) return false;
            return page.strokes.length > MAX_STROKES_PER_PAGE;
        }

        function bakeOldStrokes(pageIndex) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes) || bakingInProgress.has(pageIndex)) return;
            if (page.strokes.length <= BAKE_THRESHOLD) return;

            bakingInProgress.add(pageIndex);

            const canvas = document.querySelector(`canvas.page-canvas[data-page="${pageIndex}"]`);
            if (!canvas) {
                bakingInProgress.delete(pageIndex);
                return;
            }

            // Create offscreen canvas for baking
            const offscreen = document.createElement('canvas');
            offscreen.width = canvas.width;
            offscreen.height = canvas.height;
            const offCtx = offscreen.getContext('2d');
            offCtx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);

            // Draw background
            if (page.backgroundSource === 'template') {
                const bgImg = new Image();
                bgImg.onload = () => {
                    offCtx.drawImage(bgImg, 0, 0, A4_WIDTH, A4_HEIGHT);
                    finishBaking();
                };
                bgImg.onerror = finishBaking;
                bgImg.src = SVG_BACKGROUND;
            } else {
                finishBaking();
            }

            function finishBaking() {
                // Draw old strokes to bake (keep last BAKE_THRESHOLD/2 strokes editable)
                const keepCount = Math.floor(BAKE_THRESHOLD / 2);
                const strokesToBake = page.strokes.slice(0, page.strokes.length - keepCount);

                for (const stroke of strokesToBake) {
                    if (stroke.tool === 'eraser-stroke') continue;
                    drawSmoothStroke(offCtx, stroke);
                }

                // Convert baked strokes to background image
                page.bakedBackground = offscreen.toDataURL('image/png', 0.9);

                // Remove baked strokes
                page.strokes = page.strokes.slice(page.strokes.length - keepCount);

                bakingInProgress.delete(pageIndex);
                redrawPage(pageIndex);
                scheduleSave(false, pageIndex);
            }
        }

        // Memory-limited history with stroke count estimation
        const MAX_HISTORY_MEMORY = 50000; // Approximate max points in history

        function estimateHistoryMemory() {
            let totalPoints = 0;
            for (const action of state.history) {
                if (action.stroke?.points) {
                    totalPoints += action.stroke.points.length;
                }
                if (action.strokes) {
                    for (const item of action.strokes) {
                        if (item.stroke?.points) {
                            totalPoints += item.stroke.points.length;
                        }
                    }
                }
                if (action.before) {
                    if (Array.isArray(action.before)) {
                        for (const item of action.before) {
                            if (item.stroke?.points) totalPoints += item.stroke.points.length;
                        }
                    } else if (action.before.strokes) {
                        for (const item of action.before.strokes) {
                            if (item.stroke?.points) totalPoints += item.stroke.points.length;
                        }
                    }
                }
                if (action.after) {
                    if (Array.isArray(action.after)) {
                        for (const item of action.after) {
                            if (item.stroke?.points) totalPoints += item.stroke.points.length;
                        }
                    }
                }
            }
            return totalPoints;
        }

        function trimHistoryByMemory() {
            while (state.history.length > 1 && estimateHistoryMemory() > MAX_HISTORY_MEMORY) {
                state.history.shift();
                state.historyIndex = Math.max(-1, state.historyIndex - 1);
            }
        }

        // ============= END MEMORY OPTIMIZATION UTILITIES =============

        // App State
        const state = {
            pages: [],
            currentTool: 'pen',
            currentColor: '#002FD9',
            currentWidth: 2,
            eraserWidth: 12,
            eraserMode: 'stroke',
            exportName: 'cuaderno',
            zoom: 1,
            panX: 0,
            panY: 0,
            overscrollY: 0,
            pageCreateLocked: false,
            pendingPageCreate: false,
            isPanning: false,
            isScrolling: false,
            scrollLocked: false,
            lastPanX: 0,
            lastPanY: 0,
            panStartX: 0,
            panStartY: 0,
            initialPinchDist: 0,
            initialScale: 1,
            initialPanX: 0,
            initialPanY: 0,
            pinchCenterX: 0,
            pinchCenterY: 0,
            activePointers: new Map(),
            saveTimeout: null,
            lastSavedAt: null,
            lastNonEraserTool: {
                tool: 'pen',
                color: '#002FD9',
                width: 2
            },
            driveFileId: null,
            driveFileName: null,
            driveFolderId: null,
            driveAutosave: false,
            panVelocityX: 0,
            panVelocityY: 0,
            lastPanTime: 0,
            inertiaFrame: null,
            inertiaLock: 'free',
            selection: {
                pageIndex: null,
                strokeIndices: [],
                imageIndices: []
            },
            selectionTransform: null,
            activePageIndex: 0,
            // Undo/Redo history
            history: [],
            historyIndex: -1,
            maxHistory: 10,
            isReadOnly: true
        };

        // DOM Elements
        const canvasContainer = document.getElementById('canvas-container');
        const canvasViewport = document.getElementById('canvas-viewport');
        const toolbar = document.getElementById('toolbar');
        const eraserMenu = document.getElementById('eraser-menu');
        const eraserToggle = document.getElementById('eraser-stroke-toggle');
        const eraserButton = document.getElementById('btn-eraser');
        const statusBar = document.getElementById('status-bar');
        const statusText = document.getElementById('status-text');
        const pdfInput = document.getElementById('pdf-input');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const driveHome = document.getElementById('drive-home');
        const editorView = document.getElementById('editor-view');
        const driveStatusEl = document.getElementById('drive-status');
        const driveSearchInput = document.getElementById('drive-search');
        const driveRecentsEl = document.getElementById('drive-recents');
        const driveStarredEl = document.getElementById('drive-starred');
        const driveStarredEmptyEl = document.getElementById('drive-starred-empty');
        const driveFoldersEl = document.getElementById('drive-folders');
        const driveFolderFilesEl = document.getElementById('drive-folder-files');
        const driveFolderEmptyEl = document.getElementById('drive-folder-empty');
        const driveBreadcrumbsEl = document.getElementById('drive-breadcrumbs');
        const driveLoginBtn = document.getElementById('btn-drive-login');
        const driveNewBtn = document.getElementById('btn-drive-new');
        const driveBinBtn = document.getElementById('btn-drive-bin');
        const driveFullscreenBtn = document.getElementById('btn-drive-fullscreen');
        const driveProfileWrap = document.getElementById('drive-profile');
        const driveProfileBtn = document.getElementById('btn-drive-profile');
        const driveProfileMenu = document.getElementById('drive-profile-menu');
        const driveProfileAvatar = document.getElementById('drive-profile-avatar');
        const driveProfileAvatarMenu = document.getElementById('drive-profile-avatar-menu');
        const driveProfileName = document.getElementById('drive-profile-name');
        const driveProfileEmail = document.getElementById('drive-profile-email');
        const themeToggle = document.getElementById('theme-toggle');
        const driveMenuRefreshBtn = document.getElementById('btn-drive-menu-refresh');
        const driveMenuLogoutBtn = document.getElementById('btn-drive-menu-logout');
        const driveProfileWrapEditor = document.getElementById('drive-profile-editor');
        const driveProfileBtnEditor = document.getElementById('btn-drive-profile-editor');
        const driveProfileMenuEditor = document.getElementById('drive-profile-menu-editor');
        const driveProfileAvatarEditor = document.getElementById('drive-profile-avatar-editor');
        const driveProfileAvatarMenuEditor = document.getElementById('drive-profile-avatar-menu-editor');
        const driveProfileNameEditor = document.getElementById('drive-profile-name-editor');
        const driveProfileEmailEditor = document.getElementById('drive-profile-email-editor');
        const themeToggleEditor = document.getElementById('theme-toggle-editor');
        const driveMenuRefreshBtnEditor = document.getElementById('btn-drive-menu-refresh-editor');
        const driveMenuLogoutBtnEditor = document.getElementById('btn-drive-menu-logout-editor');
        const driveHomeBtn = document.getElementById('btn-drive-home');
        const driveBackBtn = document.getElementById('btn-drive-back');
        const docTitleEl = document.getElementById('doc-title');
        const modeToggleBtn = document.getElementById('mode-toggle-btn');
        const modeToggleLabel = document.getElementById('mode-toggle-label');
        const folderPickerModal = document.getElementById('modal-folder-picker');
        const folderPickerTitle = document.getElementById('folder-picker-title');
        const folderPickerSubtitle = document.getElementById('folder-picker-subtitle');
        const folderPickerMeta = document.getElementById('folder-picker-meta');
        const folderPickerFileName = document.getElementById('folder-picker-file-name');
        const folderPickerFilePath = document.getElementById('folder-picker-file-path');
        const folderPickerBreadcrumbs = document.getElementById('folder-picker-breadcrumbs');
        const folderPickerList = document.getElementById('folder-picker-list');
        const folderPickerEmpty = document.getElementById('folder-picker-empty');
        const folderPickerNameRow = document.getElementById('folder-picker-name-row');
        const folderPickerNameInput = document.getElementById('folder-picker-name');
        const folderPickerCancel = document.getElementById('folder-picker-cancel');
        const folderPickerConfirm = document.getElementById('folder-picker-confirm');
        const trashModal = document.getElementById('modal-trash-file');
        const trashFileName = document.getElementById('trash-file-name');
        const trashCancelBtn = document.getElementById('trash-file-cancel');
        const driveBinModal = document.getElementById('modal-drive-bin');
        const driveBinList = document.getElementById('drive-bin-list');
        const driveBinEmpty = document.getElementById('drive-bin-empty');
        const driveBinClose = document.getElementById('drive-bin-close');
        const driveBinLoading = document.getElementById('drive-bin-loading');
        let overscrollResetTimeout = null;
        let wheelReleaseTimeout = null;
        let viewSaveTimeout = null;
        let pendingViewState = null;
        let saveTimestampInterval = null;
        let lastPenBackgroundTap = null;
        let driveTokenClient = null;
        let driveAccessToken = null;
        let driveTokenExpiry = 0;
        let driveSaveTimeout = null;
        let driveSyncMaxTimeout = null;
        let driveSaveInProgress = false;
        let driveSaveQueued = false;
        let driveSaveQueuedForce = false;
        let driveSaveQueuedKeepalive = false;
        let driveDirty = false;
        let driveRecentsCache = [];
        let driveStarredCache = [];
        let driveFolderCache = { folders: [], files: [] };
        let driveFolderStack = [{ id: 'root', name: 'My Drive' }];
        let driveCurrentFolderId = 'root';
        const driveFolderMetaCache = new Map();
        let driveOpenInProgress = false;
        let driveOpenFileId = null;
        let driveUserProfile = null;
        let docTitleEditing = false;
        let docTitleOriginal = '';
        let activeDriveCardMenu = null;
        let activeBinMenu = null;
        let folderPickerMode = null;
        let folderPickerTargetFile = null;
        let folderPickerStack = [{ id: 'root', name: 'My Drive' }];
        let folderPickerCurrentFolderId = 'root';
        let trashTargetFile = null;
        let activePdfDocument = null;
        let activePdfPageCount = 0;
        let pdfBackgroundScale = Math.min(2, CANVAS_SCALE);
        let pdfRenderQueue = [];
        let pdfRenderActive = false;
        let pdfRenderToken = 0;
        let pdfRenderResumeHandle = null;
        let pdfRestoreInProgress = false;
        const pdfBackgroundCache = new Map();
        const activePageIndices = new Set();
        let visiblePageUpdateHandle = null;
        let visiblePageUpdateForce = false;
        const addPageIndicator = document.createElement('div');
        addPageIndicator.id = 'add-page-indicator';
        addPageIndicator.textContent = '+';
        canvasContainer.appendChild(addPageIndicator);

        function setReadOnlyMode(isReadOnly, options = {}) {
            const next = !!isReadOnly;
            const wasReadOnly = !!state.isReadOnly;
            if (next === wasReadOnly && !options.force) return;
            state.isReadOnly = next;

            if (editorView) {
                editorView.classList.toggle('read-only', next);
            }
            if (modeToggleBtn) {
                modeToggleBtn.classList.toggle('is-editing', !next);
                modeToggleBtn.setAttribute('aria-pressed', next ? 'false' : 'true');
                modeToggleBtn.setAttribute('aria-label', next ? 'Read mode' : 'Edit mode');
            }
            if (modeToggleLabel) {
                modeToggleLabel.textContent = next ? 'Read' : 'Edit';
            }
            if (docTitleEl) {
                docTitleEl.setAttribute('contenteditable', next ? 'false' : 'true');
                docTitleEl.setAttribute('aria-readonly', next ? 'true' : 'false');
                docTitleEl.setAttribute('tabindex', next ? '-1' : '0');
            }

            const editButtons = [
                document.getElementById('btn-edit-pages'),
                document.getElementById('btn-import-pdf'),
                document.getElementById('btn-undo'),
                document.getElementById('btn-redo'),
                document.getElementById('btn-reset-document')
            ];
            editButtons.forEach(btn => {
                if (btn) btn.disabled = next;
            });

            if (toolbar) {
                toolbar.querySelectorAll('button').forEach(btn => {
                    btn.disabled = next;
                });
                if (next) {
                    toolbar.classList.remove('toolbar-flash');
                } else {
                    toolbar.classList.remove('toolbar-flash');
                    void toolbar.offsetWidth;
                    toolbar.classList.add('toolbar-flash');
                }
            }
            if (eraserToggle) {
                eraserToggle.disabled = next;
            }
            if (eraserMenu) {
                eraserMenu.querySelectorAll('button').forEach(btn => {
                    btn.disabled = next;
                });
            }

            if (next) {
                if (docTitleEditing) {
                    finishDocTitleEdit(false);
                }
                closeEraserMenu();
                closePagesPanel();
                closeDeleteModal();
                closeResetModal();
                clearSelection();
                state.selectionTransform = null;
                state.pendingPageCreate = false;
                state.pageCreateLocked = false;
                state.overscrollY = 0;
                updateAddPageIndicator();
                clearTimeout(state.saveTimeout);
                clearDriveSyncTimers();
            } else {
                updateHistoryButtons();
                updateSaveTimestamp();
                scheduleVisiblePageUpdate(true);
            }
        }

        // Initialize
        async function init() {
            pendingViewState = loadViewState();
            initTheme();
            await loadFromStorage();
            loadDriveSession();
            bakeLegacyEraserAreaStrokes();
            if (state.pages.length === 0) {
                addPage();
            } else {
                renderAllPages();
            }
            setupEventListeners();
            syncEraserMenuState();
            initDriveAuth();
            updateDocTitle();
            updateDriveProfileUI(null);
            if (!saveTimestampInterval) {
                saveTimestampInterval = setInterval(updateSaveTimestamp, 60000);
            }
            setReadOnlyMode(true, { force: true });
            const lastView = loadViewMode();
            if (lastView === 'drive') {
                showDriveHome();
            } else {
                showEditorView();
            }
            
            // Center page after DOM is ready
            setTimeout(() => {
                if (!applyViewState(pendingViewState)) {
                    centerViewOnTop();
                }
            }, 100);
        }

        // Center view on top of first page
        function centerViewOnTop() {
            const viewportRect = canvasViewport.getBoundingClientRect();
            const pageWidth = A4_WIDTH * state.zoom;
            const padding = PAGE_PADDING * state.zoom;
            
            // Center horizontally
            state.panX = (viewportRect.width - pageWidth) / 2 - padding;
            // Show top with some margin
            state.panY = 20;
            state.overscrollY = 0;
            if (overscrollResetTimeout) {
                clearTimeout(overscrollResetTimeout);
                overscrollResetTimeout = null;
            }
            updateAddPageIndicator();
            
            updateTransform();
        }

        // Add a new blank page
        function addPage(backgroundImage = null, animate = false) {
            const pageIndex = state.pages.length;
            const pageData = {
                strokes: [],
                backgroundImage: backgroundImage, // Base64 image for PDF pages
                images: [],
                backgroundSource: backgroundImage ? 'custom' : 'template',
                pdfPageIndex: null,
                needsRedraw: true,
                preview: null,
                strokeCount: 0,
                unloaded: false
            };
            state.pages.push(pageData);
            createPageElement(pageIndex, animate, false);
            scheduleVisiblePageUpdate(true);
            scheduleSave(true, pageIndex);
            showStatus('Page added', { preserveState: true });
        }

        // Create page DOM element shell (canvases are lazy-loaded)
        function createPageElement(pageIndex, animate = false, withCanvas = false) {
            const wrapper = document.createElement('div');
            wrapper.className = 'page-wrapper';
            wrapper.dataset.page = pageIndex;
            wrapper.style.width = `${A4_WIDTH}px`;
            wrapper.style.height = `${A4_HEIGHT}px`;
            if (animate) {
                wrapper.classList.add('new-page');
                setTimeout(() => wrapper.classList.remove('new-page'), 600);
            }

            const pageNumber = document.createElement('div');
            pageNumber.className = 'page-number';
            pageNumber.textContent = `${pageIndex + 1}`;

            wrapper.appendChild(pageNumber);
            canvasContainer.appendChild(wrapper);

            if (withCanvas) {
                attachPageCanvases(wrapper, pageIndex);
                activePageIndices.add(pageIndex);
            }
            applyPagePreview(pageIndex);
            wrapper.addEventListener('pointerdown', (e) => {
                if (state.isReadOnly) return;
                state.activePageIndex = pageIndex;
                if (!activePageIndices.has(pageIndex)) {
                    if (!e.target || !e.target.closest || !e.target.closest('canvas.page-canvas')) {
                        ensurePageCanvas(pageIndex);
                        ensurePageDataLoaded(pageIndex);
                        scheduleVisiblePageUpdate(true);
                    }
                }
            });
            return wrapper;
        }

        function attachPageCanvases(wrapper, pageIndex, options = {}) {
            if (!wrapper) return;
            if (wrapper.querySelector('canvas.page-canvas')) return;
            const defer = !!options.defer;
            const deferPdfRender = !!options.deferPdfRender;

            const canvas = document.createElement('canvas');
            canvas.className = 'page-canvas';
            canvas.width = A4_WIDTH * CANVAS_SCALE;
            canvas.height = A4_HEIGHT * CANVAS_SCALE;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.dataset.page = pageIndex;

            const lassoOverlay = document.createElement('canvas');
            lassoOverlay.className = 'lasso-overlay';
            lassoOverlay.dataset.page = pageIndex;
            lassoOverlay.width = A4_WIDTH * OVERLAY_SCALE;
            lassoOverlay.height = A4_HEIGHT * OVERLAY_SCALE;
            lassoOverlay.style.width = '100%';
            lassoOverlay.style.height = '100%';

            const cursorOverlay = document.createElement('canvas');
            cursorOverlay.className = 'cursor-overlay';
            cursorOverlay.dataset.page = pageIndex;
            // Use lower resolution for cursor overlay (eraser preview only)
            cursorOverlay.width = A4_WIDTH * OVERLAY_SCALE;
            cursorOverlay.height = A4_HEIGHT * OVERLAY_SCALE;
            cursorOverlay.style.width = '100%';
            cursorOverlay.style.height = '100%';

            const selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box hidden';
            selectionBox.dataset.page = pageIndex;
            selectionBox.innerHTML = `
                <div class="selection-rotate-line"></div>
                <div class="rotate-handle" data-handle="rotate"></div>
                <button class="selection-duplicate" type="button" title="Duplicate selection" aria-label="Duplicate selection">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="10" height="10" rx="2"/>
                        <rect x="5" y="5" width="10" height="10" rx="2"/>
                    </svg>
                </button>
                <button class="selection-trash" type="button" title="Delete image" aria-label="Delete image">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                </button>
                <div class="selection-handle edge handle-n" data-handle="n"></div>
                <div class="selection-handle edge handle-s" data-handle="s"></div>
                <div class="selection-handle edge handle-e" data-handle="e"></div>
                <div class="selection-handle edge handle-w" data-handle="w"></div>
                <div class="selection-handle handle-ne" data-handle="ne"></div>
                <div class="selection-handle handle-nw" data-handle="nw"></div>
                <div class="selection-handle handle-se" data-handle="se"></div>
                <div class="selection-handle handle-sw" data-handle="sw"></div>
            `;

            wrapper.insertBefore(canvas, wrapper.firstChild);
            wrapper.insertBefore(lassoOverlay, wrapper.lastChild);
            wrapper.insertBefore(cursorOverlay, wrapper.lastChild);
            wrapper.insertBefore(selectionBox, wrapper.lastChild);

            applyPageBackground(pageIndex, canvas, { deferPdfRender });

            // Setup context with scale
            const ctx = canvas.getContext('2d');
            ctx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            setupCanvasEvents(canvas, pageIndex);
            setupSelectionBoxEvents(selectionBox, pageIndex);
            if (!defer) {
                const page = state.pages[pageIndex];
                if (page && isPageLoaded(page)) {
                    redrawPage(pageIndex);
                } else if (page) {
                    page.needsRedraw = true;
                    ensurePageDataLoaded(pageIndex);
                }
            } else {
                const page = state.pages[pageIndex];
                if (page) {
                    page.needsRedraw = true;
                }
            }
        }

        function ensurePageCanvas(pageIndex, options = {}) {
            if (activePageIndices.has(pageIndex)) {
                const canvas = document.querySelector(`canvas.page-canvas[data-page="${pageIndex}"]`);
                if (canvas) {
                    applyPageBackground(pageIndex, canvas, { deferPdfRender: !!options.deferPdfRender });
                }
                touchPageAccess(pageIndex);
                return;
            }
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (!wrapper) return;
            const page = state.pages[pageIndex];
            if (page) {
                page.pendingUnload = false;
            }
            attachPageCanvases(wrapper, pageIndex, options);
            activePageIndices.add(pageIndex);
            touchPageAccess(pageIndex);
            if (!options.defer) {
                ensurePageDataLoaded(pageIndex);
            }
        }

        function releasePageCanvas(pageIndex) {
            if (!activePageIndices.has(pageIndex)) return;
            if (state.selection.pageIndex === pageIndex) {
                clearSelection();
            }
            const page = state.pages[pageIndex];
            if (page) {
                page.pendingUnload = true;
            }
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (wrapper) {
                wrapper.querySelectorAll('canvas.page-canvas, canvas.lasso-overlay, canvas.cursor-overlay, .selection-box').forEach(el => {
                    el.remove();
                });
            }
            activePageIndices.delete(pageIndex);
            void unloadPageData(pageIndex);
        }

        function getPdfBackgroundScale(pageCount) {
            if (pageCount >= 500) return PDF_RENDER_SCALE_HUGE;
            if (pageCount >= 200) return PDF_RENDER_SCALE_LARGE;
            return Math.min(2, CANVAS_SCALE);
        }

        function resetPdfState() {
            cancelPdfRenderResume();
            pdfBackgroundCache.forEach(entry => {
                if (entry?.dataUrl && entry.dataUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(entry.dataUrl);
                }
            });
            activePdfDocument = null;
            activePdfPageCount = 0;
            pdfBackgroundScale = Math.min(2, CANVAS_SCALE);
            pdfRenderQueue = [];
            pdfRenderActive = false;
            pdfBackgroundCache.clear();
            pdfRenderToken += 1;
        }

        function cancelPdfRenderResume() {
            if (!pdfRenderResumeHandle) return;
            if ('cancelIdleCallback' in window) {
                cancelIdleCallback(pdfRenderResumeHandle);
            } else {
                clearTimeout(pdfRenderResumeHandle);
            }
            pdfRenderResumeHandle = null;
        }

        function touchPdfBackgroundCache(pageIndex, dataUrl) {
            if (!dataUrl) return;
            pdfBackgroundCache.set(pageIndex, {
                dataUrl,
                lastUsed: Date.now()
            });
            prunePdfBackgroundCache();
        }

        function prunePdfBackgroundCache() {
            if (pdfBackgroundCache.size <= MAX_PDF_BACKGROUND_CACHE) return;
            const candidates = Array.from(pdfBackgroundCache.entries())
                .filter(([index]) => !activePageIndices.has(index))
                .sort((a, b) => a[1].lastUsed - b[1].lastUsed);

            while (pdfBackgroundCache.size > MAX_PDF_BACKGROUND_CACHE && candidates.length > 0) {
                const [pageIndex] = candidates.shift();
                const entry = pdfBackgroundCache.get(pageIndex);
                if (entry?.dataUrl && entry.dataUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(entry.dataUrl);
                }
                pdfBackgroundCache.delete(pageIndex);
                const page = state.pages[pageIndex];
                if (page && page.backgroundSource === 'pdf') {
                    page.backgroundImage = null;
                }
            }
        }

        function applyPageBackground(pageIndex, canvas, options = {}) {
            const page = state.pages[pageIndex];
            if (!page || !canvas) return;
            const deferPdfRender = !!options.deferPdfRender;
            if (page.backgroundImage) {
                if (!page.backgroundSource) {
                    page.backgroundSource = page.pdfPageIndex ? 'pdf' : 'custom';
                }
                canvas.style.backgroundImage = `url("${page.backgroundImage}")`;
                canvas.style.backgroundSize = 'cover';
                canvas.style.backgroundRepeat = 'no-repeat';
                canvas.style.backgroundPosition = 'center';
                canvas.style.backgroundColor = 'transparent';
                if (page.backgroundSource === 'pdf') {
                    touchPdfBackgroundCache(pageIndex, page.backgroundImage);
                }
                return;
            }

            if (page.pdfPageIndex && activePdfDocument) {
                canvas.style.backgroundImage = '';
                canvas.style.backgroundColor = 'white';
                if (!deferPdfRender) {
                    queuePdfPageRender(pageIndex);
                }
                return;
            }

            canvas.style.backgroundImage = `url("${SVG_BACKGROUND}")`;
            canvas.style.backgroundSize = 'cover';
            canvas.style.backgroundRepeat = 'no-repeat';
            canvas.style.backgroundPosition = 'center';
            canvas.style.backgroundColor = 'transparent';
        }

        function queuePdfPageRender(pageIndex) {
            if (!activePdfDocument) return;
            if (pdfRenderQueue.includes(pageIndex)) return;
            pdfRenderQueue.push(pageIndex);
            processPdfRenderQueue();
        }

        async function processPdfRenderQueue() {
            if (pdfRenderActive) return;
            if (isViewportInteracting()) {
                schedulePdfRenderResume();
                return;
            }
            pdfRenderActive = true;
            const token = pdfRenderToken;
            while (pdfRenderQueue.length > 0) {
                const pageIndex = pdfRenderQueue.shift();
                if (token !== pdfRenderToken) break;
                if (isViewportInteracting()) break;
                if (!activePageIndices.has(pageIndex)) continue;
                await renderPdfPageToBackground(pageIndex, token);
                await new Promise(requestAnimationFrame);
            }
            pdfRenderActive = false;
            if (pdfRenderQueue.length > 0 && !isViewportInteracting()) {
                schedulePdfRenderResume();
            }
        }

        function schedulePdfRenderResume() {
            if (pdfRenderResumeHandle) return;
            const resume = () => {
                pdfRenderResumeHandle = null;
                if (!isViewportInteracting()) {
                    processPdfRenderQueue();
                }
            };
            if ('requestIdleCallback' in window) {
                pdfRenderResumeHandle = requestIdleCallback(resume, { timeout: 600 });
            } else {
                pdfRenderResumeHandle = setTimeout(resume, 120);
            }
        }

        async function renderPdfPageToBackground(pageIndex, token) {
            if (!activePdfDocument) return;
            const page = state.pages[pageIndex];
            if (!page || !page.pdfPageIndex) return;
            if (page.backgroundImage) return;
            if (token !== pdfRenderToken) return;

            try {
                const pdfPage = await activePdfDocument.getPage(page.pdfPageIndex);
                const baseViewport = pdfPage.getViewport({ scale: 1 });
                const targetWidth = A4_WIDTH * pdfBackgroundScale;
                const targetHeight = A4_HEIGHT * pdfBackgroundScale;
                const scale = Math.min(targetWidth / baseViewport.width, targetHeight / baseViewport.height);
                const viewport = pdfPage.getViewport({ scale });

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                const tempCtx = tempCanvas.getContext('2d');

                await pdfPage.render({ canvasContext: tempCtx, viewport }).promise;

                const a4Canvas = document.createElement('canvas');
                a4Canvas.width = targetWidth;
                a4Canvas.height = targetHeight;
                const a4Ctx = a4Canvas.getContext('2d');
                a4Ctx.fillStyle = 'white';
                a4Ctx.fillRect(0, 0, targetWidth, targetHeight);
                const offsetX = (targetWidth - viewport.width) / 2;
                const offsetY = (targetHeight - viewport.height) / 2;
                a4Ctx.drawImage(tempCanvas, offsetX, offsetY, viewport.width, viewport.height);

                const blob = await new Promise(resolve => a4Canvas.toBlob(resolve, 'image/jpeg', 0.85));
                let objectUrl = '';
                if (blob) {
                    if (page.backgroundImage && page.backgroundImage.startsWith('blob:')) {
                        URL.revokeObjectURL(page.backgroundImage);
                    }
                    objectUrl = URL.createObjectURL(blob);
                } else {
                    objectUrl = a4Canvas.toDataURL('image/jpeg', 0.85);
                }
                page.backgroundImage = objectUrl;
                page.backgroundSource = 'pdf';
                touchPdfBackgroundCache(pageIndex, objectUrl);

                const canvas = document.querySelector(`canvas.page-canvas[data-page="${pageIndex}"]`);
                if (canvas) {
                    canvas.style.backgroundImage = `url("${objectUrl}")`;
                    canvas.style.backgroundSize = 'cover';
                    canvas.style.backgroundRepeat = 'no-repeat';
                    canvas.style.backgroundPosition = 'center';
                    canvas.style.backgroundColor = 'transparent';
                }

                if (pdfPage.cleanup) {
                    pdfPage.cleanup();
                }
            } catch (err) {
                console.error('Failed to render PDF page background:', err);
            }
        }

        function isViewportInteracting() {
            return !!state.isPanning || state.activePointers.size > 0 || !!state.inertiaFrame;
        }

        function getVisiblePageRange(bufferOverride = null) {
            const rect = canvasViewport.getBoundingClientRect();
            if (!rect.height) return { start: 0, end: -1 };
            const viewTop = (-state.panY) / state.zoom;
            const viewBottom = (rect.height - state.panY) / state.zoom;
            const pageSpan = A4_HEIGHT + PAGE_GAP;
            let start = Math.floor((viewTop - PAGE_PADDING) / pageSpan);
            let end = Math.floor((viewBottom - PAGE_PADDING) / pageSpan);
            const buffer = Number.isFinite(bufferOverride) ? bufferOverride : VISIBLE_PAGE_BUFFER;
            start = Math.max(0, Math.min(state.pages.length - 1, start - buffer));
            end = Math.max(0, Math.min(state.pages.length - 1, end + buffer));
            return { start, end };
        }

        function updateVisiblePages(force = false) {
            const pageCount = state.pages.length;
            if (!pageCount) return;
            const deferHeavy = !force && isViewportInteracting();
            const buffer = deferHeavy ? VISIBLE_PAGE_BUFFER_ACTIVE : VISIBLE_PAGE_BUFFER;
            const range = getVisiblePageRange(buffer);
            if (range.end < range.start) return;
            const visibleIndices = [];
            for (let i = range.start; i <= range.end; i++) {
                visibleIndices.push(i);
            }

            const rect = canvasViewport.getBoundingClientRect();
            const viewCenterY = (-state.panY + rect.height / 2) / state.zoom;
            const pageSpan = A4_HEIGHT + PAGE_GAP;
            const pageCenterY = (index) => PAGE_PADDING + (index * pageSpan) + (A4_HEIGHT / 2);

            const activeSet = new Set();
            if (Number.isFinite(state.selection.pageIndex)
                && state.selection.pageIndex >= range.start
                && state.selection.pageIndex <= range.end) {
                activeSet.add(state.selection.pageIndex);
            }
            if (Number.isFinite(state.activePageIndex)
                && state.activePageIndex >= range.start
                && state.activePageIndex <= range.end) {
                activeSet.add(state.activePageIndex);
            }

            const candidates = visibleIndices
                .map(index => ({
                    index,
                    dist: Math.abs(pageCenterY(index) - viewCenterY)
                }))
                .sort((a, b) => a.dist - b.dist);

            for (const item of candidates) {
                if (activeSet.size >= MAX_ACTIVE_PAGES) break;
                activeSet.add(item.index);
            }

            activeSet.forEach(index => {
                if (index < range.start || index > range.end) return;
                ensurePageCanvas(index, { defer: deferHeavy, deferPdfRender: deferHeavy });
                clearPagePreview(index);
                const page = state.pages[index];
                if (page && page.needsRedraw && !deferHeavy) {
                    redrawPage(index);
                }
                if (page && page.backgroundSource === 'pdf' && !page.backgroundImage && activePdfDocument && !deferHeavy) {
                    const canvas = document.querySelector(`canvas.page-canvas[data-page="${index}"]`);
                    if (canvas) {
                        applyPageBackground(index, canvas);
                    }
                }
                if (!deferHeavy) {
                    ensurePageDataLoaded(index);
                }
            });

            visibleIndices.forEach(index => {
                if (!activeSet.has(index)) {
                    applyPagePreview(index);
                }
            });

            if (!deferHeavy) {
                activePageIndices.forEach(index => {
                    if (!activeSet.has(index)) {
                        releasePageCanvas(index);
                    }
                });
            }

            prunePdfBackgroundCache();
        }

        function scheduleVisiblePageUpdate(force = false) {
            visiblePageUpdateForce = visiblePageUpdateForce || force;
            if (visiblePageUpdateHandle) return;
            visiblePageUpdateHandle = requestAnimationFrame(() => {
                const shouldForce = visiblePageUpdateForce;
                visiblePageUpdateForce = false;
                visiblePageUpdateHandle = null;
                updateVisiblePages(shouldForce);
            });
        }

        // Setup canvas pointer events with improved drawing
        function setupCanvasEvents(canvas, pageIndex) {
            let isDrawing = false;
            let currentStroke = null;
            let erasedStrokes = []; // For eraser tools to track what was erased
            let areaEraseBefore = null;
            let areaEraseChanged = false;
            let isLassoing = false;
            let lassoPoints = [];
            const wrapper = canvas.closest('.page-wrapper');
            const lassoCanvas = wrapper ? wrapper.querySelector('.lasso-overlay') : null;

            canvas.addEventListener('pointerdown', (e) => {
                if (state.isReadOnly) return;
                state.activePageIndex = pageIndex;
                const activePage = state.pages[pageIndex];
                if (!isPageLoaded(activePage)) {
                    ensurePageDataLoaded(pageIndex);
                    return;
                }
                if (state.currentTool === 'lasso') {
                    if (e.pointerType === 'touch') return;
                    if (!lassoCanvas) return;
                    isLassoing = true;
                    lassoPoints = [];
                    clearSelection();
                    const pos = getCanvasPos(canvas, e);
                    lassoPoints.push(pos);
                    drawLassoPath(lassoCanvas, lassoPoints);
                    canvas.setPointerCapture(e.pointerId);
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Only pen draws
                if (e.pointerType !== 'pen') return;
                clearSelection();

                e.preventDefault();
                canvas.setPointerCapture(e.pointerId);

                const pos = getCanvasPos(canvas, e);
                const pressure = e.pressure || 0.5;

                isDrawing = true;
                erasedStrokes = [];

                if (state.currentTool === 'eraser-stroke') {
                    // Check if we hit a stroke to erase
                    eraseStrokeAtPoint(pageIndex, pos.x, pos.y, erasedStrokes, state.eraserWidth / 2);
                    drawEraserPreview(pageIndex, pos);
                } else if (state.currentTool === 'eraser-area') {
                    areaEraseBefore = cloneStrokesArray(state.pages[pageIndex].strokes);
                    areaEraseChanged = eraseAreaAtPoint(pageIndex, pos.x, pos.y, state.eraserWidth / 2) || areaEraseChanged;
                    drawEraserPreview(pageIndex, pos);
                } else {
                    currentStroke = {
                        tool: state.currentTool,
                        color: state.currentColor,
                        width: state.currentWidth,
                        points: [{ x: pos.x, y: pos.y, p: pressure }],
                        lastMid: null,
                        finalizedIndex: -1
                    };
                }
            });

            canvas.addEventListener('pointermove', (e) => {
                if (state.isReadOnly) return;
                if (isLassoing) {
                    const pos = getCanvasPos(canvas, e);
                    lassoPoints.push(pos);
                    drawLassoPath(lassoCanvas, lassoPoints);
                    return;
                }

                if (!isDrawing || e.pointerType !== 'pen') return;

                const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];

                if (state.currentTool === 'eraser-stroke' || state.currentTool === 'eraser-area') {
                    events.forEach(ev => {
                        const pos = getCanvasPos(canvas, ev);
                        if (state.currentTool === 'eraser-stroke') {
                            eraseStrokeAtPoint(pageIndex, pos.x, pos.y, erasedStrokes, state.eraserWidth / 2);
                            drawEraserPreview(pageIndex, pos);
                        } else {
                            areaEraseChanged = eraseAreaAtPoint(pageIndex, pos.x, pos.y, state.eraserWidth / 2) || areaEraseChanged;
                            drawEraserPreview(pageIndex, pos);
                        }
                    });
                    return;
                }

                events.forEach(ev => {
                    const pos = getCanvasPos(canvas, ev);
                    const pressure = ev.pressure || 0.5;
                    if (currentStroke.tool === 'highlighter') {
                        const lastPoint = currentStroke.points[currentStroke.points.length - 1];
                        const minDist = Math.max(0.6, currentStroke.width * 0.12);
                        const dist = Math.hypot(pos.x - lastPoint.x, pos.y - lastPoint.y);
                        if (dist < minDist) {
                            lastPoint.x = pos.x;
                            lastPoint.y = pos.y;
                            lastPoint.p = pressure;
                            return;
                        }
                    }
                    currentStroke.points.push({ x: pos.x, y: pos.y, p: pressure });
                });
                updateLiveStroke(pageIndex, canvas, currentStroke);
            });

            const endDrawing = (e) => {
                if (state.isReadOnly) {
                    isDrawing = false;
                    if (isLassoing) {
                        isLassoing = false;
                        clearLassoCanvas(pageIndex);
                        lassoPoints = [];
                    }
                    clearEraserPreview(pageIndex);
                    currentStroke = null;
                    erasedStrokes = [];
                    areaEraseBefore = null;
                    areaEraseChanged = false;
                    return;
                }
                if (isLassoing) {
                    isLassoing = false;
                    if (lassoPoints.length > 2) {
                        selectStrokesWithLasso(pageIndex, lassoPoints);
                    } else {
                        clearSelection();
                    }
                    clearLassoCanvas(pageIndex);
                    lassoPoints = [];
                    if (canvas.hasPointerCapture && canvas.hasPointerCapture(e.pointerId)) {
                        canvas.releasePointerCapture(e.pointerId);
                    }
                    return;
                }

                if (!isDrawing) return;
                isDrawing = false;

                if (state.currentTool === 'eraser-stroke') {
                    // Save erased strokes to history
                    if (erasedStrokes.length > 0) {
                        saveToHistory({
                            type: 'erase-strokes',
                            pageIndex: pageIndex,
                            strokes: erasedStrokes
                        });
                        scheduleSave(false, pageIndex);
                        requestImmediateDriveSave();
                    }
                    clearEraserPreview(pageIndex);
                } else if (state.currentTool === 'eraser-area') {
                    if (areaEraseChanged && areaEraseBefore) {
                        const after = cloneStrokesArray(state.pages[pageIndex].strokes);
                        saveToHistory({
                            type: 'erase-area',
                            pageIndex: pageIndex,
                            before: areaEraseBefore,
                            after
                        });
                        scheduleSave(false, pageIndex);
                        requestImmediateDriveSave();
                    }
                    clearEraserPreview(pageIndex);
                } else if (currentStroke && currentStroke.points.length > 0) {
                    if (e && typeof e.clientX === 'number' && typeof e.clientY === 'number') {
                        const pos = getCanvasPos(canvas, e);
                        const last = currentStroke.points[currentStroke.points.length - 1];
                        const dist = Math.hypot(pos.x - last.x, pos.y - last.y);
                        if (dist > 0.5) {
                            currentStroke.points.push({ x: pos.x, y: pos.y, p: e.pressure || last.p || 0.5 });
                        }
                    }
                    // Simplify stroke points to save memory
                    simplifyStrokePoints(currentStroke);

                    const finalizedStroke = {
                        tool: currentStroke.tool,
                        color: currentStroke.color,
                        width: currentStroke.width,
                        points: currentStroke.points
                    };
                    state.pages[pageIndex].strokes.push(finalizedStroke);
                    saveToHistory({
                        type: 'add-stroke',
                        pageIndex: pageIndex,
                        stroke: cloneStroke(finalizedStroke)
                    });
                    scheduleSave(false, pageIndex);
                    requestImmediateDriveSave();
                    redrawPage(pageIndex);

                    // Check if we need to bake old strokes
                    if (shouldBakeStrokes(pageIndex)) {
                        setTimeout(() => bakeOldStrokes(pageIndex), 100);
                    }
                }
                clearEraserPreview(pageIndex);

                currentStroke = null;
                erasedStrokes = [];
                areaEraseBefore = null;
                areaEraseChanged = false;
            };

            canvas.addEventListener('pointerup', endDrawing);
            canvas.addEventListener('pointercancel', endDrawing);
            canvas.addEventListener('pointerleave', endDrawing);
        }

        function clearLassoCanvas(pageIndex) {
            const lassoCanvas = document.querySelector(`.lasso-overlay[data-page="${pageIndex}"]`);
            if (!lassoCanvas) return;
            const ctx = lassoCanvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
        }

        function drawLassoPath(lassoCanvas, points) {
            if (!lassoCanvas || points.length === 0) return;
            const ctx = lassoCanvas.getContext('2d');
            ctx.setTransform(OVERLAY_SCALE, 0, 0, OVERLAY_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);
            ctx.strokeStyle = '#002FD9';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawStrokePreviewTail(pageIndex, stroke) {
            const previewCanvas = document.querySelector(`.cursor-overlay[data-page="${pageIndex}"]`);
            if (!previewCanvas) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.setTransform(OVERLAY_SCALE, 0, 0, OVERLAY_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);

            if (!stroke || !stroke.points || stroke.points.length === 0) return;
            if (stroke.tool === 'highlighter') {
                drawFixedHighlighterStroke(ctx, stroke);
                return;
            }
            if (stroke.points.length < 2) return;
            const points = stroke.points;
            const startIndex = stroke.finalizedIndex >= 0
                ? stroke.finalizedIndex + 1
                : 0;

            setupContext(ctx, stroke.tool, stroke.color, stroke.width);
            setStrokeCaps(ctx, stroke.tool);
            ctx.lineWidth = getStrokeWidth(stroke);

            let localMid = stroke.lastMid;
            let i = startIndex;

            if (!localMid) {
                if (startIndex === 0) {
                    const mid0 = {
                        x: (points[0].x + points[1].x) / 2,
                        y: (points[0].y + points[1].y) / 2
                    };
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(mid0.x, mid0.y);
                    ctx.stroke();
                    localMid = mid0;
                    i = 1;
                } else {
                    const prev = points[startIndex - 1];
                    const curr = points[startIndex];
                    const midPrev = {
                        x: (prev.x + curr.x) / 2,
                        y: (prev.y + curr.y) / 2
                    };
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(midPrev.x, midPrev.y);
                    ctx.stroke();
                    localMid = midPrev;
                }
            }

            for (; i < points.length - 1; i++) {
                const next = points[i + 1];
                const mid = {
                    x: (points[i].x + next.x) / 2,
                    y: (points[i].y + next.y) / 2
                };
                ctx.beginPath();
                ctx.moveTo(localMid.x, localMid.y);
                ctx.quadraticCurveTo(points[i].x, points[i].y, mid.x, mid.y);
                ctx.stroke();
                localMid = mid;
            }

            const last = points[points.length - 1];
            ctx.beginPath();
            ctx.moveTo(localMid.x, localMid.y);
            ctx.lineTo(last.x, last.y);
            ctx.stroke();
        }

        function finalizeStrokeSegments(pageIndex, canvas, stroke) {
            const points = stroke.points;
            if (points.length < 2) return;
            const targetIndex = Math.min(points.length - 2, points.length - LIVE_PREVIEW_POINTS - 1);
            if (targetIndex <= stroke.finalizedIndex) return;

            const ctx = canvas.getContext('2d');
            setupContext(ctx, stroke.tool, stroke.color, stroke.width);
            setStrokeCaps(ctx, stroke.tool);
            ctx.lineWidth = getStrokeWidth(stroke);

            let startIndex = stroke.finalizedIndex + 1;
            if (startIndex === 0) {
                const mid0 = {
                    x: (points[0].x + points[1].x) / 2,
                    y: (points[0].y + points[1].y) / 2
                };
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(mid0.x, mid0.y);
                ctx.stroke();
                stroke.lastMid = mid0;
                stroke.finalizedIndex = 0;
                startIndex = 1;
            }

            for (let i = startIndex; i <= targetIndex; i++) {
                const next = points[i + 1];
                const mid = {
                    x: (points[i].x + next.x) / 2,
                    y: (points[i].y + next.y) / 2
                };
                ctx.beginPath();
                ctx.moveTo(stroke.lastMid.x, stroke.lastMid.y);
                ctx.quadraticCurveTo(points[i].x, points[i].y, mid.x, mid.y);
                ctx.stroke();
                stroke.lastMid = mid;
                stroke.finalizedIndex = i;
            }
        }

        function updateLiveStroke(pageIndex, canvas, stroke) {
            if (stroke.tool === 'highlighter') {
                drawStrokePreviewTail(pageIndex, stroke);
                return;
            }
            if (!stroke || stroke.points.length < 2) {
                drawStrokePreviewTail(pageIndex, stroke);
                return;
            }
            const pending = stroke.points.length - 1 - stroke.finalizedIndex;
            if (pending > LIVE_PREVIEW_POINTS + FINALIZE_STEP_POINTS) {
                finalizeStrokeSegments(pageIndex, canvas, stroke);
            }
            drawStrokePreviewTail(pageIndex, stroke);
        }

        function drawEraserPreview(pageIndex, pos) {
            const previewCanvas = document.querySelector(`.cursor-overlay[data-page="${pageIndex}"]`);
            if (!previewCanvas) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.setTransform(OVERLAY_SCALE, 0, 0, OVERLAY_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);
            const radius = state.eraserWidth / 2;
            ctx.strokeStyle = 'rgba(0,0,0,0.45)';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fill();
        }

        function clearEraserPreview(pageIndex) {
            const previewCanvas = document.querySelector(`.cursor-overlay[data-page="${pageIndex}"]`);
            if (!previewCanvas) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }

        function clearSelection() {
            if (state.selection.pageIndex !== null) {
                const box = document.querySelector(`.selection-box[data-page="${state.selection.pageIndex}"]`);
                if (box) {
                    box.classList.add('hidden');
                    box.classList.remove('has-selection');
                    box.classList.remove('has-image');
                }
            }
            document.querySelectorAll('.lasso-overlay').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
            state.selection.pageIndex = null;
            state.selection.strokeIndices = [];
            state.selection.imageIndices = [];
        }

        function selectStrokesWithLasso(pageIndex, polygon) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return;
            const selected = [];
            const selectedImages = [];
            for (let i = 0; i < page.strokes.length; i++) {
                const stroke = page.strokes[i];
                if (stroke.tool && stroke.tool.startsWith('eraser')) continue;
                if (strokeIntersectsPolygon(stroke, polygon)) {
                    selected.push(i);
                }
            }
            if (Array.isArray(page.images)) {
                for (let i = 0; i < page.images.length; i++) {
                    const image = page.images[i];
                    if (!image) continue;
                    const corners = getImageCorners(image);
                    if (polygonIntersectsRect(polygon, corners)) {
                        selectedImages.push(i);
                    }
                }
            }
            if (selected.length === 0 && selectedImages.length === 0) {
                clearSelection();
                return;
            }
            state.selection.pageIndex = pageIndex;
            state.selection.strokeIndices = selected;
            state.selection.imageIndices = selectedImages;
            updateSelectionBox();
        }

        function strokeIntersectsPolygon(stroke, polygon) {
            for (const point of stroke.points) {
                if (pointInPolygon(point, polygon)) {
                    return true;
                }
            }
            return false;
        }

        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 0.00001) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getImageCorners(image) {
            const halfW = image.width / 2;
            const halfH = image.height / 2;
            const cos = Math.cos(image.rotation || 0);
            const sin = Math.sin(image.rotation || 0);
            const corners = [
                { x: -halfW, y: -halfH },
                { x: halfW, y: -halfH },
                { x: halfW, y: halfH },
                { x: -halfW, y: halfH }
            ];
            return corners.map(pt => ({
                x: image.x + pt.x * cos - pt.y * sin,
                y: image.y + pt.x * sin + pt.y * cos
            }));
        }

        function getImageBounds(image) {
            const corners = getImageCorners(image);
            const xs = corners.map(pt => pt.x);
            const ys = corners.map(pt => pt.y);
            return {
                minX: Math.min(...xs),
                minY: Math.min(...ys),
                maxX: Math.max(...xs),
                maxY: Math.max(...ys)
            };
        }

        function segmentsIntersect(a, b, c, d) {
            const det = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);
            if (det === 0) return false;
            const t = ((c.x - a.x) * (d.y - c.y) - (c.y - a.y) * (d.x - c.x)) / det;
            const u = ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)) / det;
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        function polygonIntersectsRect(polygon, rectCorners) {
            for (const corner of rectCorners) {
                if (pointInPolygon(corner, polygon)) return true;
            }
            for (const point of polygon) {
                if (pointInPolygon(point, rectCorners)) return true;
            }
            for (let i = 0; i < polygon.length; i++) {
                const a = polygon[i];
                const b = polygon[(i + 1) % polygon.length];
                for (let j = 0; j < rectCorners.length; j++) {
                    const c = rectCorners[j];
                    const d = rectCorners[(j + 1) % rectCorners.length];
                    if (segmentsIntersect(a, b, c, d)) return true;
                }
            }
            return false;
        }

        function getSelectionBounds(pageIndex, strokeIndices = [], imageIndices = []) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            strokeIndices.forEach(index => {
                const stroke = page.strokes[index];
                if (!stroke) return;
                stroke.points.forEach(pt => {
                    minX = Math.min(minX, pt.x);
                    minY = Math.min(minY, pt.y);
                    maxX = Math.max(maxX, pt.x);
                    maxY = Math.max(maxY, pt.y);
                });
            });

            imageIndices.forEach(index => {
                const image = page.images?.[index];
                if (!image) return;
                const bounds = getImageBounds(image);
                minX = Math.min(minX, bounds.minX);
                minY = Math.min(minY, bounds.minY);
                maxX = Math.max(maxX, bounds.maxX);
                maxY = Math.max(maxY, bounds.maxY);
            });

            if (!isFinite(minX)) return null;
            return {
                minX,
                minY,
                maxX,
                maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        function updateSelectionBox() {
            if (state.selection.pageIndex === null) return;
            const bounds = getSelectionBounds(
                state.selection.pageIndex,
                state.selection.strokeIndices,
                state.selection.imageIndices
            );
            const box = document.querySelector(`.selection-box[data-page="${state.selection.pageIndex}"]`);
            if (!box || !bounds) return;
            box.classList.remove('hidden');
            const hasSelection = state.selection.strokeIndices.length > 0 || state.selection.imageIndices.length > 0;
            box.classList.toggle('has-selection', hasSelection);
            box.classList.toggle('has-image', state.selection.imageIndices.length > 0);
            box.style.left = bounds.minX + 'px';
            box.style.top = bounds.minY + 'px';
            box.style.width = bounds.width + 'px';
            box.style.height = bounds.height + 'px';
        }

        function deleteSelectedImages(pageIndex) {
            if (state.isReadOnly) return;
            const page = state.pages[pageIndex];
            if (!page) return;
            if (!isPageLoaded(page)) {
                ensurePageDataLoaded(pageIndex);
                return;
            }
            if (!Array.isArray(page.images)) return;
            if (!state.selection.imageIndices || state.selection.imageIndices.length === 0) return;
            const uniqueIndices = Array.from(new Set(state.selection.imageIndices))
                .filter(index => index >= 0 && index < page.images.length);
            if (uniqueIndices.length === 0) return;

            const removed = uniqueIndices
                .slice()
                .sort((a, b) => a - b)
                .map(index => ({
                    index,
                    image: JSON.parse(JSON.stringify(page.images[index]))
                }));

            uniqueIndices
                .slice()
                .sort((a, b) => b - a)
                .forEach(index => {
                    page.images.splice(index, 1);
                });

            saveToHistory({
                type: 'delete-images',
                pageIndex,
                images: removed
            });
            clearSelection();
            redrawPage(pageIndex);
            renderPagesList();
            scheduleSave(false, pageIndex);
            showStatus(uniqueIndices.length > 1 ? 'Images deleted' : 'Image deleted', { preserveState: true });
        }

        function deleteSelection(pageIndex) {
            if (state.isReadOnly) return;
            const page = state.pages[pageIndex];
            if (!page) return;
            if (!isPageLoaded(page)) {
                ensurePageDataLoaded(pageIndex);
                return;
            }
            const strokeIndices = Array.from(new Set(state.selection.strokeIndices || []))
                .filter(index => index >= 0 && index < page.strokes.length);
            const imageIndices = Array.from(new Set(state.selection.imageIndices || []))
                .filter(index => page.images?.[index]);

            if (strokeIndices.length === 0 && imageIndices.length === 0) return;

            const removedStrokes = strokeIndices
                .slice()
                .sort((a, b) => a - b)
                .map(index => ({
                    index,
                    stroke: cloneStroke(page.strokes[index])
                }));

            const removedImages = imageIndices
                .slice()
                .sort((a, b) => a - b)
                .map(index => ({
                    index,
                    image: JSON.parse(JSON.stringify(page.images[index]))
                }));

            strokeIndices
                .slice()
                .sort((a, b) => b - a)
                .forEach(index => {
                    page.strokes.splice(index, 1);
                });

            if (Array.isArray(page.images)) {
                imageIndices
                    .slice()
                    .sort((a, b) => b - a)
                    .forEach(index => {
                        page.images.splice(index, 1);
                    });
            }

            saveToHistory({
                type: 'delete-selection',
                pageIndex,
                strokes: removedStrokes,
                images: removedImages
            });

            clearSelection();
            redrawPage(pageIndex);
            renderPagesList();
            scheduleSave(false, pageIndex);
            showStatus((removedStrokes.length + removedImages.length) > 1 ? 'Selection deleted' : 'Item deleted', { preserveState: true });
        }

        function duplicateSelection(pageIndex) {
            if (state.isReadOnly) return;
            const page = state.pages[pageIndex];
            if (!page) return;
            if (!isPageLoaded(page)) {
                ensurePageDataLoaded(pageIndex);
                return;
            }
            const strokeIndices = Array.from(new Set(state.selection.strokeIndices || []))
                .filter(index => index >= 0 && index < page.strokes.length);
            const imageIndices = Array.from(new Set(state.selection.imageIndices || []))
                .filter(index => page.images?.[index]);
            if (strokeIndices.length === 0 && imageIndices.length === 0) return;

            const bounds = getSelectionBounds(pageIndex, strokeIndices, imageIndices);
            const offset = 18;
            let dx = offset;
            let dy = offset;
            if (bounds) {
                const margin = 6;
                const minDx = margin - bounds.minX;
                const maxDx = (A4_WIDTH - margin) - bounds.maxX;
                const minDy = margin - bounds.minY;
                const maxDy = (A4_HEIGHT - margin) - bounds.maxY;
                dx = minDx > maxDx ? 0 : clamp(dx, minDx, maxDx);
                dy = minDy > maxDy ? 0 : clamp(dy, minDy, maxDy);
            }

            const addedStrokes = [];
            strokeIndices.forEach(index => {
                const stroke = page.strokes[index];
                if (!stroke) return;
                const duplicate = cloneStroke(stroke);
                duplicate.points = stroke.points.map(pt => ({
                    x: pt.x + dx,
                    y: pt.y + dy,
                    p: pt.p
                }));
                page.strokes.push(duplicate);
                addedStrokes.push({
                    index: page.strokes.length - 1,
                    stroke: cloneStroke(duplicate)
                });
            });

            const addedImages = [];
            if (Array.isArray(page.images)) {
                imageIndices.forEach(index => {
                    const image = page.images[index];
                    if (!image) return;
                    const duplicate = {
                        ...image,
                        x: image.x + dx,
                        y: image.y + dy
                    };
                    page.images.push(duplicate);
                    addedImages.push({
                        index: page.images.length - 1,
                        image: JSON.parse(JSON.stringify(duplicate))
                    });
                });
            }

            if (addedStrokes.length === 0 && addedImages.length === 0) return;

            saveToHistory({
                type: 'duplicate-selection',
                pageIndex,
                strokes: addedStrokes,
                images: addedImages
            });

            state.selection.pageIndex = pageIndex;
            state.selection.strokeIndices = addedStrokes.map(item => item.index);
            state.selection.imageIndices = addedImages.map(item => item.index);
            setActiveTool('lasso');
            updateSelectionBox();
            redrawPage(pageIndex);
            renderPagesList();
            scheduleSave(false, pageIndex);
            showStatus('Selection duplicated', { preserveState: true });
        }

        function getPagePosFromEvent(pageIndex, e) {
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (!wrapper) return { x: 0, y: 0 };
            const rect = wrapper.getBoundingClientRect();
            const scaleX = A4_WIDTH / rect.width;
            const scaleY = A4_HEIGHT / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function getPagePosFromClient(pageIndex, clientX, clientY) {
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (!wrapper) return { x: 0, y: 0 };
            const rect = wrapper.getBoundingClientRect();
            const scaleX = A4_WIDTH / rect.width;
            const scaleY = A4_HEIGHT / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function getPageIndexFromClientPoint(clientX, clientY) {
            const wrappers = Array.from(document.querySelectorAll('.page-wrapper'));
            let bestIndex = null;
            let bestDistance = Infinity;
            wrappers.forEach(wrapper => {
                const rect = wrapper.getBoundingClientRect();
                const dx = Math.max(rect.left - clientX, 0, clientX - rect.right);
                const dy = Math.max(rect.top - clientY, 0, clientY - rect.bottom);
                const dist = Math.hypot(dx, dy);
                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestIndex = parseInt(wrapper.dataset.page, 10);
                }
            });
            return Number.isFinite(bestIndex) ? bestIndex : null;
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function isEraserTool(toolName) {
            return toolName === 'eraser' || toolName === 'eraser-area' || toolName === 'eraser-stroke';
        }

        function rememberNonEraserTool(toolName) {
            if (!toolName || isEraserTool(toolName) || toolName === 'lasso') return;
            state.lastNonEraserTool = {
                tool: toolName,
                color: state.currentColor,
                width: state.currentWidth
            };
        }

        function setActiveToolButton(toolName, color = null, width = null) {
            if (!toolbar) return;
            const normalizedTool = isEraserTool(toolName) ? 'eraser' : toolName;
            const targetColor = color || ((normalizedTool === 'pen' || normalizedTool === 'highlighter') ? state.currentColor : null);
            const targetWidth = width || ((normalizedTool === 'pen' || normalizedTool === 'highlighter') ? state.currentWidth : null);

            toolbar.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                if (btn.dataset.tool !== normalizedTool) {
                    btn.classList.remove('active');
                    return;
                }
                if (normalizedTool === 'pen' || normalizedTool === 'highlighter') {
                    if (targetColor && btn.dataset.color && btn.dataset.color.toLowerCase() !== targetColor.toLowerCase()) {
                        btn.classList.remove('active');
                        return;
                    }
                    if (targetWidth && btn.dataset.width && parseFloat(btn.dataset.width) !== parseFloat(targetWidth)) {
                        btn.classList.remove('active');
                        return;
                    }
                }
                btn.classList.add('active');
            });
        }

        function setActiveTool(toolName, options = {}) {
            if (!toolName) return;
            if (state.isReadOnly) return;
            if (toolName === 'eraser') {
                state.currentTool = state.eraserMode === 'stroke' ? 'eraser-stroke' : 'eraser-area';
                setActiveToolButton('eraser');
            } else {
                if (options.color) state.currentColor = options.color;
                if (options.width) state.currentWidth = options.width;
                state.currentTool = toolName;
                setActiveToolButton(toolName, options.color, options.width);
            }
            if (toolName !== 'eraser') {
                closeEraserMenu();
            }
            rememberNonEraserTool(state.currentTool);
        }

        function activateEraserTool() {
            setActiveTool('eraser');
        }

        function restoreLastNonEraserTool() {
            const fallback = {
                tool: 'pen',
                color: state.currentColor,
                width: state.currentWidth
            };
            const last = state.lastNonEraserTool || fallback;
            if (last.color) state.currentColor = last.color;
            if (last.width) state.currentWidth = last.width;
            state.currentTool = last.tool;
            setActiveToolButton(last.tool, last.color, last.width);
            closeEraserMenu();
        }

        function toggleEraserFromGesture() {
            if (state.isReadOnly) return;
            if (isEraserTool(state.currentTool)) {
                restoreLastNonEraserTool();
                return;
            }
            rememberNonEraserTool(state.currentTool);
            activateEraserTool();
        }

        function handlePenBackgroundDoubleTap(e) {
            if (state.isReadOnly) return false;
            if (!e || e.pointerType !== 'pen') return false;
            if (e.target && e.target.closest && e.target.closest('.page-wrapper')) return false;
            const now = Date.now();
            const tap = { time: now, x: e.clientX, y: e.clientY };
            if (lastPenBackgroundTap) {
                const dt = now - lastPenBackgroundTap.time;
                const dx = tap.x - lastPenBackgroundTap.x;
                const dy = tap.y - lastPenBackgroundTap.y;
                const dist = Math.hypot(dx, dy);
                if (dt <= PEN_DOUBLE_TAP_MS && dist <= PEN_DOUBLE_TAP_DIST) {
                    lastPenBackgroundTap = null;
                    toggleEraserFromGesture();
                    return true;
                }
            }
            lastPenBackgroundTap = tap;
            return false;
        }

        function getBaseDocTitle(name) {
            if (!name) return 'Untitled';
            const trimmed = name.trim();
            if (!trimmed) return 'Untitled';
            return trimmed.replace(/\.pdf$/i, '') || 'Untitled';
        }

        function updateDocTitle() {
            if (!docTitleEl || docTitleEditing) return;
            const name = state.driveFileName || (state.exportName ? `${state.exportName}` : 'Untitled');
            docTitleEl.textContent = getBaseDocTitle(name);
        }

        function getSystemTheme() {
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
                ? 'dark'
                : 'light';
        }

        function applyTheme(mode, persist = false) {
            const next = mode === 'dark' ? 'dark' : 'light';
            document.documentElement.dataset.theme = next;
            if (persist) {
                try {
                    localStorage.setItem(THEME_KEY, next);
                } catch (e) {
                    console.error('Failed to save theme:', e);
                }
            }
            updateThemeToggleState();
        }

        function updateThemeToggleState() {
            const isDark = document.documentElement.dataset.theme === 'dark';
            if (themeToggle) {
                themeToggle.checked = isDark;
            }
            if (themeToggleEditor) {
                themeToggleEditor.checked = isDark;
            }
        }

        function initTheme() {
            let stored = null;
            try {
                stored = localStorage.getItem(THEME_KEY);
            } catch (e) {
                stored = null;
            }
            if (stored === 'dark' || stored === 'light') {
                applyTheme(stored, false);
            } else {
                applyTheme(getSystemTheme(), false);
            }
            if (window.matchMedia) {
                const media = window.matchMedia('(prefers-color-scheme: dark)');
                if (media && media.addEventListener) {
                    media.addEventListener('change', (e) => {
                        let currentStored = null;
                        try {
                            currentStored = localStorage.getItem(THEME_KEY);
                        } catch (err) {
                            currentStored = null;
                        }
                        if (!currentStored) {
                            applyTheme(e.matches ? 'dark' : 'light', false);
                        }
                    });
                }
            }
        }

        function normalizeDocTitleInput(value) {
            const cleaned = (value || '').replace(/\s+/g, ' ').trim();
            if (!cleaned) return 'Untitled';
            const noExt = cleaned.replace(/\.pdf$/i, '').trim();
            return sanitizeFilename(noExt) || 'Untitled';
        }

        async function renameDriveFile(newBaseName, fallbackBase) {
            if (!state.driveFileId) return;
            try {
                await ensureDriveToken(false);
                const nextName = newBaseName.toLowerCase().endsWith('.pdf')
                    ? newBaseName
                    : `${newBaseName}.pdf`;
                const res = await driveFetch(`https://www.googleapis.com/drive/v3/files/${state.driveFileId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ name: nextName })
                });
                const data = await res.json();
                state.driveFileName = data.name || nextName;
                updateDocTitle();
                saveDriveSession();
            } catch (err) {
                console.error('Failed to rename Drive file:', err);
                if (fallbackBase) {
                    state.exportName = fallbackBase;
                }
                updateDocTitle();
                showStatus('Rename failed', { preserveState: true });
            }
        }

        function beginDocTitleEdit() {
            if (!docTitleEl) return;
            if (state.isReadOnly) return;
            docTitleEditing = true;
            docTitleOriginal = docTitleEl.textContent || '';
            docTitleEl.classList.add('editing');
        }

        function finishDocTitleEdit(commit) {
            if (!docTitleEl) return;
            if (state.isReadOnly) return;
            const nextBase = normalizeDocTitleInput(docTitleEl.textContent || '');
            const originalBase = normalizeDocTitleInput(docTitleOriginal);
            docTitleEditing = false;
            docTitleEl.classList.remove('editing');

            if (!commit) {
                docTitleEl.textContent = getBaseDocTitle(originalBase);
                updateDocTitle();
                return;
            }

            if (nextBase !== originalBase) {
                state.exportName = nextBase;
                const nextFileName = `${nextBase}.pdf`;
                if (state.driveFileId) {
                    renameDriveFile(nextBase, originalBase);
                } else {
                    state.driveFileName = nextFileName;
                }
                saveDriveSession();
            }

            updateDocTitle();
        }

        function showDriveHome() {
            if (driveHome) driveHome.classList.remove('hidden');
            if (editorView) editorView.classList.add('hidden');
            closeDriveProfileMenus();
            saveViewMode('drive');
        }

        function clampToolbarPosition() {
            if (!toolbar) return;
            const header = document.querySelector('header');
            const headerHeight = header ? header.getBoundingClientRect().height : 60;
            const margin = 12;
            const rect = toolbar.getBoundingClientRect();
            const minTop = headerHeight + margin;
            const maxTop = Math.max(minTop, window.innerHeight - rect.height - margin);
            const minLeft = margin;
            const maxLeft = Math.max(minLeft, window.innerWidth - rect.width - margin);
            const nextLeft = Math.max(minLeft, Math.min(rect.left, maxLeft));
            const nextTop = Math.max(minTop, Math.min(rect.top, maxTop));
            toolbar.style.left = nextLeft + 'px';
            toolbar.style.top = nextTop + 'px';
            toolbar.style.right = 'auto';
            toolbar.style.bottom = 'auto';
            toolbar.style.setProperty('--toolbar-translate', '0px');
        }

        function showEditorView() {
            if (driveHome) driveHome.classList.add('hidden');
            if (editorView) editorView.classList.remove('hidden');
            requestAnimationFrame(() => {
                clampToolbarPosition();
                scheduleVisiblePageUpdate(true);
            });
            saveViewMode('editor');
        }

        function initDriveAuth() {
            if (!window.google || !google.accounts || !google.accounts.oauth2) {
                setTimeout(initDriveAuth, 200);
                return;
            }
            driveTokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: DRIVE_SCOPE,
                callback: () => {}
            });
            const hasStoredToken = loadDriveTokenFromStorage();
            updateDriveAuthUI();
            if (hasStoredToken) {
                refreshDriveFiles();
            } else if (localStorage.getItem(DRIVE_REMEMBER_KEY) === '1') {
                ensureDriveToken(false)
                    .then(() => refreshDriveFiles())
                    .catch(() => updateDriveAuthUI());
            }
        }

        function updateDriveAuthUI() {
            const signedIn = !!driveAccessToken;
            if (driveLoginBtn) driveLoginBtn.style.display = signedIn ? 'none' : 'inline-flex';
            if (driveProfileWrap) driveProfileWrap.classList.toggle('hidden', !signedIn);
            if (driveProfileWrapEditor) driveProfileWrapEditor.classList.toggle('hidden', !signedIn);
            if (driveSearchInput) driveSearchInput.disabled = !signedIn;
            if (driveNewBtn) driveNewBtn.disabled = !signedIn;
            if (driveBinBtn) driveBinBtn.disabled = !signedIn;
            if (driveBackBtn) driveBackBtn.disabled = !signedIn || driveFolderStack.length <= 1;
            if (driveStatusEl) {
                driveStatusEl.textContent = signedIn ? 'Loading your PDFs...' : 'Sign in to browse your Drive.';
            }
            if (!signedIn) {
                if (driveStarredEmptyEl) driveStarredEmptyEl.classList.add('hidden');
                if (driveFolderEmptyEl) driveFolderEmptyEl.classList.add('hidden');
                closeDriveProfileMenus();
            } else if (state.driveAutosave && !state.isReadOnly && driveDirty) {
                clearTimeout(driveSaveTimeout);
                driveSaveTimeout = setTimeout(() => {
                    scheduleDriveSync();
                }, 500);
            }
            if (signedIn) {
                loadDriveProfile();
                restorePdfBackgroundsIfNeeded();
            }
        }

        function ensureDriveToken(interactive = false) {
            if (driveAccessToken && Date.now() < driveTokenExpiry - 60000) {
                return Promise.resolve(driveAccessToken);
            }
            if (!driveTokenClient) {
                return Promise.reject(new Error('Drive auth not ready'));
            }
            return new Promise((resolve, reject) => {
                driveTokenClient.callback = (resp) => {
                    if (resp.error) {
                        reject(resp);
                        return;
                    }
                    driveAccessToken = resp.access_token;
                    driveTokenExpiry = Date.now() + (resp.expires_in || 0) * 1000;
                    saveDriveTokenToStorage(driveAccessToken, driveTokenExpiry);
                    updateDriveAuthUI();
                    resolve(driveAccessToken);
                };
                driveTokenClient.requestAccessToken({ prompt: interactive ? 'consent' : '' });
            });
        }

        function signInDrive() {
            ensureDriveToken(true)
                .then(() => refreshDriveFiles())
                .catch(() => {
                    if (driveStatusEl) driveStatusEl.textContent = 'Sign-in failed. Try again.';
                });
        }

        function signOutDrive() {
            if (driveAccessToken && window.google?.accounts?.oauth2?.revoke) {
                google.accounts.oauth2.revoke(driveAccessToken, () => {});
            }
            driveAccessToken = null;
            driveTokenExpiry = 0;
            state.driveFileId = null;
            state.driveFileName = null;
            state.driveFolderId = null;
            state.driveAutosave = false;
            driveRecentsCache = [];
            driveStarredCache = [];
            driveFolderCache = { folders: [], files: [] };
            driveFolderStack = [{ id: 'root', name: 'My Drive' }];
            driveCurrentFolderId = 'root';
            driveFolderMetaCache.clear();
            if (driveRecentsEl) driveRecentsEl.innerHTML = '';
            if (driveStarredEl) driveStarredEl.innerHTML = '';
            if (driveFoldersEl) driveFoldersEl.innerHTML = '';
            if (driveFolderFilesEl) driveFolderFilesEl.innerHTML = '';
            if (driveBreadcrumbsEl) driveBreadcrumbsEl.innerHTML = '';
            if (driveStatusEl) driveStatusEl.textContent = 'Sign in to browse your Drive.';
            driveUserProfile = null;
            updateDriveProfileUI(null);
            closeDriveProfileMenus();
            clearDriveTokenStorage();
            localStorage.removeItem(DRIVE_REMEMBER_KEY);
            clearDriveSession();
            updateDriveAuthUI();
        }

        function updateDriveProfileUI(profile) {
            const fallback = DEFAULT_AVATAR;
            if (driveProfileAvatar) {
                driveProfileAvatar.src = profile?.photo || fallback;
            }
            if (driveProfileAvatarMenu) {
                driveProfileAvatarMenu.src = profile?.photo || fallback;
            }
            if (driveProfileName) {
                driveProfileName.textContent = profile?.name || 'Signed in';
            }
            if (driveProfileEmail) {
                driveProfileEmail.textContent = profile?.email || '';
            }
            if (driveProfileAvatarEditor) {
                driveProfileAvatarEditor.src = profile?.photo || fallback;
            }
            if (driveProfileAvatarMenuEditor) {
                driveProfileAvatarMenuEditor.src = profile?.photo || fallback;
            }
            if (driveProfileNameEditor) {
                driveProfileNameEditor.textContent = profile?.name || 'Signed in';
            }
            if (driveProfileEmailEditor) {
                driveProfileEmailEditor.textContent = profile?.email || '';
            }
        }

        async function loadDriveProfile() {
            if (!driveAccessToken) return;
            if (driveUserProfile && driveUserProfile.token === driveAccessToken) {
                updateDriveProfileUI(driveUserProfile);
                return;
            }
            try {
                const res = await driveFetch('https://www.googleapis.com/drive/v3/about?fields=user(displayName,emailAddress,photoLink)');
                const data = await res.json();
                const user = data?.user;
                if (!user) return;
                driveUserProfile = {
                    name: user.displayName || 'Signed in',
                    email: user.emailAddress || '',
                    photo: user.photoLink || DEFAULT_AVATAR,
                    token: driveAccessToken
                };
                updateDriveProfileUI(driveUserProfile);
            } catch (err) {
                console.error('Failed to load Drive profile:', err);
            }
        }

        function toggleDriveProfileMenu(menuEl, btnEl, force) {
            if (!menuEl) return;
            const shouldOpen = typeof force === 'boolean'
                ? force
                : menuEl.classList.contains('hidden');
            if (menuEl !== driveProfileMenu) {
                closeDriveProfileMenu(driveProfileMenu, driveProfileBtn);
            }
            if (menuEl !== driveProfileMenuEditor) {
                closeDriveProfileMenu(driveProfileMenuEditor, driveProfileBtnEditor);
            }
            menuEl.classList.toggle('hidden', !shouldOpen);
            if (btnEl) {
                btnEl.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
            }
        }

        function closeDriveProfileMenu(menuEl, btnEl) {
            if (!menuEl) return;
            menuEl.classList.add('hidden');
            if (btnEl) {
                btnEl.setAttribute('aria-expanded', 'false');
            }
        }

        function closeDriveProfileMenus() {
            closeDriveProfileMenu(driveProfileMenu, driveProfileBtn);
            closeDriveProfileMenu(driveProfileMenuEditor, driveProfileBtnEditor);
        }

        async function restorePdfBackgroundsIfNeeded() {
            if (!driveAccessToken || activePdfDocument || !state.driveFileId) return;
            const needsPdf = state.pages.some(page => page?.pdfPageIndex);
            if (!needsPdf) return;
            if (pdfRestoreInProgress) return;
            pdfRestoreInProgress = true;
            try {
                const res = await driveFetch(`https://www.googleapis.com/drive/v3/files/${state.driveFileId}?alt=media`);
                const arrayBuffer = await res.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                resetPdfState();
                activePdfDocument = pdf;
                activePdfPageCount = pdf.numPages;
                pdfBackgroundScale = getPdfBackgroundScale(activePdfPageCount);
                scheduleVisiblePageUpdate(true);
            } catch (err) {
                console.error('Failed to restore PDF backgrounds:', err);
            } finally {
                pdfRestoreInProgress = false;
            }
        }

        async function driveFetch(url, options = {}) {
            const token = await ensureDriveToken(false);
            const headers = new Headers(options.headers || {});
            headers.set('Authorization', `Bearer ${token}`);
            const res = await fetch(url, { ...options, headers, keepalive: !!options.keepalive });
            if (!res.ok) {
                const message = await res.text().catch(() => '');
                throw new Error(`Drive API error ${res.status}: ${message}`);
            }
            return res;
        }

        async function ensureDriveFolder() {
            if (state.driveFolderId) return state.driveFolderId;
            const query = encodeURIComponent(`name='${DRIVE_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`);
            const res = await driveFetch(`https://www.googleapis.com/drive/v3/files?q=${query}&fields=files(id,name)`);
            const data = await res.json();
            if (data.files && data.files.length > 0) {
                state.driveFolderId = data.files[0].id;
                return state.driveFolderId;
            }
            const createRes = await driveFetch('https://www.googleapis.com/drive/v3/files', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: DRIVE_FOLDER_NAME,
                    mimeType: 'application/vnd.google-apps.folder'
                })
            });
            const created = await createRes.json();
            state.driveFolderId = created.id;
            return state.driveFolderId;
        }

        function formatDriveDate(value) {
            if (!value) return '';
            const date = new Date(value);
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function normalizeDriveThumbnail(link) {
            if (!link) return '';
            const resized = link.replace(/=s\d+/, '=s480');
            return resized.includes('=s') ? resized : `${resized}&sz=w480-h640`;
        }

        function createDrivePreview(file) {
            const preview = document.createElement('div');
            preview.className = 'drive-card-preview';
            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            icon.setAttribute('viewBox', '0 0 24 24');
            icon.setAttribute('fill', 'none');
            icon.setAttribute('stroke', 'currentColor');
            icon.setAttribute('stroke-width', '1.8');
            icon.classList.add('drive-card-icon');
            icon.innerHTML = '<path d="M6 2h8l4 4v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"/><path d="M14 2v6h6"/>';

            const thumb = normalizeDriveThumbnail(file.thumbnailLink || '');
            if (thumb) {
                const img = new Image();
                img.src = thumb;
                img.alt = `${file.name} preview`;
                img.loading = 'lazy';
                img.onerror = () => {
                    preview.innerHTML = '';
                    preview.appendChild(icon);
                };
                preview.appendChild(img);
                return preview;
            }
            preview.appendChild(icon);
            return preview;
        }

        function createDriveFileCard(file) {
            const card = document.createElement('div');
            card.className = 'drive-card';
            card.appendChild(createDrivePreview(file));

            const title = document.createElement('div');
            title.className = 'drive-card-title';
            title.textContent = file.name || 'Untitled';
            card.appendChild(title);

            const meta = document.createElement('div');
            meta.className = 'drive-card-meta';
            meta.textContent = `Modified ${formatDriveDate(file.modifiedTime || file.createdTime)}`;
            card.appendChild(meta);

            card.appendChild(createDriveItemMenu(file));

            card.addEventListener('click', (e) => {
                if (e.target.closest('.drive-card-menu')) return;
                openDriveFile(file);
            });
            return card;
        }

        function createDriveItemMenu(item) {
            const menuWrap = document.createElement('div');
            menuWrap.className = 'drive-card-menu';

            const menuBtn = document.createElement('button');
            menuBtn.type = 'button';
            menuBtn.className = 'drive-card-more';
            menuBtn.title = 'More actions';
            menuBtn.setAttribute('aria-label', 'More actions');
            menuBtn.innerHTML = `
                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" aria-hidden="true">
                    <circle cx="5" cy="12" r="2"></circle>
                    <circle cx="12" cy="12" r="2"></circle>
                    <circle cx="19" cy="12" r="2"></circle>
                </svg>
            `;

            const menu = document.createElement('div');
            menu.className = 'drive-card-dropdown hidden';
            const isStarred = !!item?.starred;
            const starLabel = isStarred ? 'Remove from favorites' : 'Add to favorites';
            menu.innerHTML = `
                <button type="button" data-action="star">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
                        <path d="M12 3.6l2.6 5.3 5.8.8-4.2 4.1 1 5.7-5.2-2.8-5.2 2.8 1-5.7-4.2-4.1 5.8-.8z"/>
                    </svg>
                    <span>${starLabel}</span>
                </button>
                <button type="button" data-action="move">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
                        <path d="M3 6a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                    </svg>
                    <span>Move</span>
                </button>
                <button type="button" class="danger" data-action="trash">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    <span>Move to bin</span>
                </button>
            `;

            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleDriveCardMenu(menu);
            });

            menu.addEventListener('click', (e) => {
                e.stopPropagation();
                const button = e.target?.closest ? e.target.closest('button[data-action]') : null;
                const action = button?.dataset?.action;
                if (!action) return;
                closeDriveCardMenu();
                if (action === 'star') {
                    const nextStar = !item?.starred;
                    updateDriveStarStatus(item, nextStar);
                } else if (action === 'move') {
                    openFolderPicker('move', item);
                } else if (action === 'trash') {
                    openTrashModal(item);
                }
            });

            menuWrap.appendChild(menuBtn);
            menuWrap.appendChild(menu);
            return menuWrap;
        }

        function toggleDriveCardMenu(menuEl) {
            if (!menuEl) return;
            if (activeDriveCardMenu && activeDriveCardMenu !== menuEl) {
                activeDriveCardMenu.classList.add('hidden');
            }
            const shouldOpen = menuEl.classList.contains('hidden');
            menuEl.classList.toggle('hidden', !shouldOpen);
            activeDriveCardMenu = shouldOpen ? menuEl : null;
        }

        function closeDriveCardMenu() {
            if (!activeDriveCardMenu) return;
            activeDriveCardMenu.classList.add('hidden');
            activeDriveCardMenu = null;
        }

        async function updateDriveStarStatus(item, shouldStar) {
            if (!item || !item.id) return;
            try {
                await ensureDriveToken(false);
                await driveFetch(`https://www.googleapis.com/drive/v3/files/${item.id}?fields=id,starred`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ starred: !!shouldStar })
                });
                item.starred = !!shouldStar;
                showStatus(shouldStar ? 'Added to favorites' : 'Removed from favorites', { preserveState: true });
                refreshDriveFiles();
            } catch (err) {
                console.error('Failed to update favorite status:', err);
                showStatus('Failed to update favorites', { preserveState: true });
            }
        }

        function openStarredFolder(folder) {
            if (!folder || !folder.id) return;
            driveFolderStack = [{ id: 'root', name: 'My Drive' }, { id: folder.id, name: folder.name || 'Folder' }];
            driveCurrentFolderId = folder.id;
            renderDriveBreadcrumbs();
            if (driveStatusEl) driveStatusEl.textContent = 'Loading folder...';
            refreshDriveFolderContents();
        }

        function createDriveStarredCard(item) {
            if (item?.mimeType === 'application/vnd.google-apps.folder') {
                const card = document.createElement('div');
                card.className = 'drive-card';

                const preview = document.createElement('div');
                preview.className = 'drive-card-preview';
                const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                icon.setAttribute('viewBox', '0 0 24 24');
                icon.setAttribute('fill', 'none');
                icon.setAttribute('stroke', 'currentColor');
                icon.setAttribute('stroke-width', '1.8');
                icon.classList.add('drive-card-icon', 'folder');
                icon.innerHTML = '<path d="M3 6a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>';
                preview.appendChild(icon);
                card.appendChild(preview);

                const title = document.createElement('div');
                title.className = 'drive-card-title';
                title.textContent = item.name || 'Folder';
                card.appendChild(title);

                const meta = document.createElement('div');
                meta.className = 'drive-card-meta';
                meta.textContent = 'Folder';
                card.appendChild(meta);

                card.appendChild(createDriveItemMenu(item));

                card.addEventListener('click', (e) => {
                    if (e.target.closest('.drive-card-menu')) return;
                    openStarredFolder(item);
                });
                return card;
            }

            return createDriveFileCard(item);
        }

        function createDriveFolderCard(folder) {
            const card = document.createElement('div');
            card.className = 'drive-folder-card';

            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            icon.setAttribute('viewBox', '0 0 24 24');
            icon.setAttribute('fill', 'none');
            icon.setAttribute('stroke', 'currentColor');
            icon.setAttribute('stroke-width', '1.8');
            icon.classList.add('drive-folder-icon');
            icon.innerHTML = '<path d="M3 6a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>';
            card.appendChild(icon);

            const name = document.createElement('div');
            name.className = 'drive-card-title';
            name.textContent = folder.name || 'Folder';
            card.appendChild(name);

            card.appendChild(createDriveItemMenu(folder));

            card.addEventListener('click', (e) => {
                if (e.target.closest('.drive-card-menu')) return;
                enterDriveFolder(folder);
            });
            return card;
        }

        function renderDriveBreadcrumbs() {
            if (!driveBreadcrumbsEl) return;
            driveBreadcrumbsEl.innerHTML = '';
            driveFolderStack.forEach((crumb, index) => {
                const btn = document.createElement('button');
                btn.className = `drive-breadcrumb${index === driveFolderStack.length - 1 ? ' active' : ''}`;
                const label = crumb.id === 'root' ? `${crumb.name}/` : crumb.name;
                btn.textContent = label;
                if (index < driveFolderStack.length - 1) {
                    btn.addEventListener('click', () => navigateDriveBreadcrumb(index));
                }
                driveBreadcrumbsEl.appendChild(btn);
                if (index < driveFolderStack.length - 1) {
                    const sep = document.createElement('span');
                    sep.textContent = '/';
                    driveBreadcrumbsEl.appendChild(sep);
                }
            });
            if (driveBackBtn) driveBackBtn.disabled = driveFolderStack.length <= 1;
        }

        function renderDriveRecents(files) {
            if (!driveRecentsEl) return;
            driveRecentsEl.innerHTML = '';
            if (!files || files.length === 0) return;
            files.forEach(file => driveRecentsEl.appendChild(createDriveFileCard(file)));
        }

        function renderDriveStarred(files) {
            if (!driveStarredEl) return;
            driveStarredEl.innerHTML = '';
            if (!files || files.length === 0) {
                if (driveStarredEmptyEl) driveStarredEmptyEl.classList.remove('hidden');
                return;
            }
            if (driveStarredEmptyEl) driveStarredEmptyEl.classList.add('hidden');
            files.forEach(item => driveStarredEl.appendChild(createDriveStarredCard(item)));
        }

        function renderDriveFolderContents(folders, files) {
            if (driveFoldersEl) driveFoldersEl.innerHTML = '';
            if (driveFolderFilesEl) driveFolderFilesEl.innerHTML = '';

            const hasFolders = Array.isArray(folders) && folders.length > 0;
            const hasFiles = Array.isArray(files) && files.length > 0;

            if (hasFolders && driveFoldersEl) {
                folders.forEach(folder => driveFoldersEl.appendChild(createDriveFolderCard(folder)));
            }

            if (hasFiles && driveFolderFilesEl) {
                files.forEach(file => driveFolderFilesEl.appendChild(createDriveFileCard(file)));
            }

            if (driveFolderEmptyEl) {
                driveFolderEmptyEl.classList.toggle('hidden', hasFolders || hasFiles);
            }
        }

        function navigateDriveBreadcrumb(index) {
            driveFolderStack = driveFolderStack.slice(0, index + 1);
            driveCurrentFolderId = driveFolderStack[driveFolderStack.length - 1].id;
            renderDriveBreadcrumbs();
            if (driveStatusEl) driveStatusEl.textContent = 'Loading folder...';
            refreshDriveFolderContents();
        }

        function enterDriveFolder(folder) {
            if (!folder || !folder.id) return;
            driveFolderStack.push({ id: folder.id, name: folder.name || 'Folder' });
            driveCurrentFolderId = folder.id;
            renderDriveBreadcrumbs();
            if (driveStatusEl) driveStatusEl.textContent = 'Loading folder...';
            refreshDriveFolderContents();
        }

        async function refreshDriveRecents() {
            const search = driveSearchInput ? driveSearchInput.value.trim() : '';
            const queryParts = [
                `mimeType='application/pdf'`,
                'trashed=false'
            ];
            if (search) {
                const safe = search.replace(/'/g, "\\'");
                queryParts.push(`name contains '${safe}'`);
            }
            const q = encodeURIComponent(queryParts.join(' and '));
            const fields = encodeURIComponent('files(id,name,modifiedTime,createdTime,thumbnailLink,iconLink,parents,starred)');
            const res = await driveFetch(`https://www.googleapis.com/drive/v3/files?q=${q}&orderBy=modifiedTime desc&pageSize=12&fields=${fields}`);
            const data = await res.json();
            driveRecentsCache = data.files || [];
            renderDriveRecents(driveRecentsCache);
        }

        async function refreshDriveStarred() {
            const q = encodeURIComponent(`starred=true and trashed=false and (mimeType='application/pdf' or mimeType='application/vnd.google-apps.folder')`);
            const fields = encodeURIComponent('files(id,name,modifiedTime,createdTime,thumbnailLink,iconLink,mimeType,parents,starred)');
            const res = await driveFetch(`https://www.googleapis.com/drive/v3/files?q=${q}&orderBy=modifiedTime desc&pageSize=12&fields=${fields}`);
            const data = await res.json();
            driveStarredCache = data.files || [];
            renderDriveStarred(driveStarredCache);
        }

        async function refreshDriveFolderContents() {
            try {
                const search = driveSearchInput ? driveSearchInput.value.trim() : '';
                const baseParts = [
                    `'${driveCurrentFolderId}' in parents`,
                    'trashed=false'
                ];
                if (search) {
                    const safe = search.replace(/'/g, "\\'");
                    baseParts.push(`name contains '${safe}'`);
                }

                const folderQuery = encodeURIComponent([...baseParts, `mimeType='application/vnd.google-apps.folder'`].join(' and '));
                const fileQuery = encodeURIComponent([...baseParts, `mimeType='application/pdf'`].join(' and '));
                const folderFields = encodeURIComponent('files(id,name,starred)');
                const fileFields = encodeURIComponent('files(id,name,modifiedTime,createdTime,thumbnailLink,iconLink,parents,starred)');

                const [folderRes, fileRes] = await Promise.all([
                    driveFetch(`https://www.googleapis.com/drive/v3/files?q=${folderQuery}&orderBy=name&pageSize=100&fields=${folderFields}`),
                    driveFetch(`https://www.googleapis.com/drive/v3/files?q=${fileQuery}&orderBy=modifiedTime desc&pageSize=100&fields=${fileFields}`)
                ]);

                const foldersData = await folderRes.json();
                const filesData = await fileRes.json();
                driveFolderCache = {
                    folders: foldersData.files || [],
                    files: filesData.files || []
                };
                renderDriveFolderContents(driveFolderCache.folders, driveFolderCache.files);
                updateDriveStatusCounts();
            } catch (err) {
                if (driveStatusEl) driveStatusEl.textContent = 'Unable to load this folder.';
            }
        }

        function updateDriveStatusCounts() {
            if (!driveStatusEl || !driveAccessToken) return;
            const recentCount = driveRecentsCache.length;
            const starredCount = driveStarredCache.length;
            const folderCount = driveFolderCache.files.length;
            driveStatusEl.textContent = `Recents: ${recentCount} | Starred: ${starredCount} | This folder: ${folderCount} PDF${folderCount !== 1 ? 's' : ''}.`;
        }

        async function refreshDriveFiles() {
            if (!driveStatusEl) return;
            if (!driveAccessToken) {
                updateDriveAuthUI();
                return;
            }
            driveStatusEl.textContent = 'Loading your Drive...';
            try {
                await ensureDriveToken(false);
                renderDriveBreadcrumbs();
                await Promise.all([refreshDriveRecents(), refreshDriveStarred(), refreshDriveFolderContents()]);
                updateDriveStatusCounts();
            } catch (err) {
                driveStatusEl.textContent = 'Unable to load Drive files.';
            }
        }

        async function openDriveFile(file) {
            if (!file || !file.id) return;
            if (driveOpenInProgress) return;
            closeDriveCardMenu();
            driveOpenInProgress = true;
            driveOpenFileId = file.id;
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            state.overscrollY = 0;
            setReadOnlyMode(true, { force: true });
            showEditorView();
            showLoading('Opening PDF...');
            try {
                await ensureDriveToken(false);
                const res = await driveFetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`);
                const arrayBuffer = await res.arrayBuffer();
                await importPDFArrayBuffer(arrayBuffer);
                state.driveFileId = file.id;
                state.driveFileName = file.name || 'Untitled';
                state.driveAutosave = true;
                const baseName = state.driveFileName.replace(/\.pdf$/i, '');
                state.exportName = baseName || state.exportName;
                updateDocTitle();
                saveDriveSession();
                showStatus('PDF loaded', { preserveState: true });
            } catch (err) {
                showStatus('Failed to load PDF', { preserveState: true });
            } finally {
                hideLoading();
                driveOpenInProgress = false;
                driveOpenFileId = null;
            }
        }

        function createNewDriveDocument() {
            openFolderPicker('new');
        }

        async function createNewDriveDocumentWithFolder(folderId, fileBaseName) {
            const safeBase = normalizeDocTitleInput(fileBaseName || 'Untitled');
            const fileName = `${safeBase}.pdf`;
            setReadOnlyMode(true, { force: true });
            showEditorView();
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            state.overscrollY = 0;
            clearSelection();
            state.selectionTransform = null;
            resetPdfState();
            await clearPageStore();
            pageDirty.clear();
            pageAccess.clear();
            pageLoadQueue.clear();
            legacyPagesCache = null;
            imageCache.clear();
            imageCacheUsage.clear();
            state.pages = [{
                strokes: [],
                backgroundImage: null,
                backgroundSource: 'template',
                pdfPageIndex: null,
                images: [],
                needsRedraw: true,
                preview: null,
                strokeCount: 0,
                unloaded: false
            }];
            state.history = [];
            state.historyIndex = -1;
            updateHistoryButtons();
            renderAllPages();
            centerViewOnTop();
            state.exportName = safeBase;
            state.driveFileId = null;
            state.driveFileName = fileName;
            state.driveFolderId = folderId || null;
            state.driveAutosave = true;
            updateDocTitle();
            saveDriveSession();
            scheduleSave(true, 0);

            try {
                showLoading('Creating PDF...');
                await ensureDriveToken(false);
                const pdfBlob = await buildPdfBlob();
                const createdId = await createDriveFileInFolder(folderId, fileName, pdfBlob);
                state.driveFileId = createdId;
                saveDriveSession();
                showStatus('PDF created', { preserveState: true });
            } catch (err) {
                showStatus('Failed to create PDF', { preserveState: true });
            } finally {
                hideLoading();
            }
        }

        function getDrivePathLabelFromStack(stack) {
            if (!Array.isArray(stack) || stack.length === 0) return 'My Drive';
            return stack.map(crumb => crumb.name || 'Folder').join(' / ');
        }

        async function getDriveFolderMeta(folderId) {
            if (!folderId || folderId === 'root') {
                return { id: 'root', name: 'My Drive', parents: [] };
            }
            if (driveFolderMetaCache.has(folderId)) {
                return driveFolderMetaCache.get(folderId);
            }
            try {
                const res = await driveFetch(`https://www.googleapis.com/drive/v3/files/${folderId}?fields=id,name,parents`);
                const data = await res.json();
                if (data && data.id) {
                    driveFolderMetaCache.set(folderId, data);
                    return data;
                }
            } catch (err) {
                return null;
            }
            return null;
        }

        async function resolveDrivePathForFile(file) {
            if (!file?.id) return 'My Drive';
            const currentParents = Array.isArray(file.parents) ? file.parents : [];
            if (currentParents.length > 0 && currentParents.includes(driveCurrentFolderId) && driveFolderStack.length > 0) {
                return getDrivePathLabelFromStack(driveFolderStack);
            }

            let parents = currentParents;
            if (parents.length === 0) {
                try {
                    const res = await driveFetch(`https://www.googleapis.com/drive/v3/files/${file.id}?fields=parents`);
                    const data = await res.json();
                    parents = Array.isArray(data.parents) ? data.parents : [];
                } catch (err) {
                    parents = [];
                }
            }

            if (parents.length === 0) return 'My Drive';

            const parts = [];
            let currentId = parents[0];
            const visited = new Set();
            while (currentId && currentId !== 'root' && !visited.has(currentId) && parts.length < 20) {
                visited.add(currentId);
                const meta = await getDriveFolderMeta(currentId);
                if (!meta) break;
                parts.unshift(meta.name || 'Folder');
                const nextParents = Array.isArray(meta.parents) ? meta.parents : [];
                currentId = nextParents[0];
            }
            return ['My Drive', ...parts].join(' / ');
        }

        function openFolderPicker(mode, file = null) {
            if (!driveAccessToken) return;
            folderPickerMode = mode;
            folderPickerTargetFile = file;
            if (driveFolderStack && driveFolderStack.length > 0) {
                folderPickerStack = driveFolderStack.map(crumb => ({ id: crumb.id, name: crumb.name }));
                folderPickerCurrentFolderId = driveCurrentFolderId || 'root';
            } else {
                folderPickerStack = [{ id: 'root', name: 'My Drive' }];
                folderPickerCurrentFolderId = 'root';
            }
            if (folderPickerTitle) {
                folderPickerTitle.textContent = mode === 'move' ? 'Move file' : 'New PDF';
            }
            if (folderPickerSubtitle) {
                folderPickerSubtitle.textContent = mode === 'move'
                    ? 'Choose the destination folder.'
                    : 'Choose a folder and name your file.';
            }
            if (folderPickerMeta) {
                if (mode === 'move' && file) {
                    folderPickerMeta.classList.remove('hidden');
                    if (folderPickerFileName) {
                        folderPickerFileName.textContent = file.name || 'Untitled';
                    }
                    if (folderPickerFilePath) {
                        folderPickerFilePath.textContent = 'Current: loading...';
                    }
                    resolveDrivePathForFile(file).then((path) => {
                        if (folderPickerMode === 'move' && folderPickerTargetFile?.id === file.id && folderPickerFilePath) {
                            folderPickerFilePath.textContent = `Current: ${path}`;
                        }
                    });
                } else {
                    folderPickerMeta.classList.add('hidden');
                }
            }
            if (folderPickerNameRow) {
                folderPickerNameRow.style.display = mode === 'move' ? 'none' : 'flex';
            }
            if (folderPickerNameInput) {
                const defaultName = normalizeDocTitleInput(state.exportName || 'Untitled');
                folderPickerNameInput.value = mode === 'move' ? '' : defaultName;
            }
            if (folderPickerConfirm) {
                folderPickerConfirm.textContent = mode === 'move' ? 'Move' : 'Create';
            }
            updateFolderPickerConfirmState();
            renderFolderPickerBreadcrumbs();
            refreshFolderPickerFolders();
            if (folderPickerModal) folderPickerModal.classList.add('visible');
            if (folderPickerNameInput && mode !== 'move') {
                requestAnimationFrame(() => {
                    folderPickerNameInput.focus();
                    folderPickerNameInput.select();
                });
            }
        }

        function closeFolderPicker() {
            folderPickerMode = null;
            folderPickerTargetFile = null;
            if (folderPickerModal) folderPickerModal.classList.remove('visible');
            if (folderPickerMeta) folderPickerMeta.classList.add('hidden');
            if (folderPickerFileName) folderPickerFileName.textContent = '';
            if (folderPickerFilePath) folderPickerFilePath.textContent = '';
        }

        function updateFolderPickerConfirmState() {
            if (!folderPickerConfirm) return;
            if (folderPickerMode === 'move') {
                folderPickerConfirm.disabled = false;
                return;
            }
            const name = folderPickerNameInput ? folderPickerNameInput.value.trim() : '';
            folderPickerConfirm.disabled = name.length === 0;
        }

        function renderFolderPickerBreadcrumbs() {
            if (!folderPickerBreadcrumbs) return;
            folderPickerBreadcrumbs.innerHTML = '';
            folderPickerStack.forEach((crumb, index) => {
                const btn = document.createElement('button');
                btn.className = `folder-picker-breadcrumb${index === folderPickerStack.length - 1 ? ' active' : ''}`;
                btn.textContent = crumb.name;
                if (index < folderPickerStack.length - 1) {
                    btn.addEventListener('click', () => navigateFolderPickerBreadcrumb(index));
                }
                folderPickerBreadcrumbs.appendChild(btn);
                if (index < folderPickerStack.length - 1) {
                    const sep = document.createElement('span');
                    sep.textContent = '/';
                    folderPickerBreadcrumbs.appendChild(sep);
                }
            });
        }

        function navigateFolderPickerBreadcrumb(index) {
            folderPickerStack = folderPickerStack.slice(0, index + 1);
            folderPickerCurrentFolderId = folderPickerStack[folderPickerStack.length - 1].id;
            renderFolderPickerBreadcrumbs();
            refreshFolderPickerFolders();
        }

        function enterFolderPickerFolder(folder) {
            if (!folder || !folder.id) return;
            folderPickerStack.push({ id: folder.id, name: folder.name || 'Folder' });
            folderPickerCurrentFolderId = folder.id;
            renderFolderPickerBreadcrumbs();
            refreshFolderPickerFolders();
        }

        async function refreshFolderPickerFolders() {
            if (!driveAccessToken || !folderPickerList) return;
            try {
                const q = encodeURIComponent(`'${folderPickerCurrentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`);
                const fields = encodeURIComponent('files(id,name)');
                const res = await driveFetch(`https://www.googleapis.com/drive/v3/files?q=${q}&orderBy=name&pageSize=200&fields=${fields}`);
                const data = await res.json();
                renderFolderPickerList(data.files || []);
            } catch (err) {
                renderFolderPickerList([]);
            }
        }

        function renderFolderPickerList(folders) {
            if (!folderPickerList) return;
            folderPickerList.innerHTML = '';
            const hasFolders = Array.isArray(folders) && folders.length > 0;
            if (folderPickerEmpty) {
                folderPickerEmpty.classList.toggle('hidden', hasFolders);
            }
            if (!hasFolders) return;
            folders.forEach(folder => {
                const item = document.createElement('div');
                item.className = 'folder-picker-item';
                item.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
                        <path d="M3 6a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                    </svg>
                    <span>${folder.name || 'Folder'}</span>
                `;
                item.addEventListener('click', () => enterFolderPickerFolder(folder));
                folderPickerList.appendChild(item);
            });
        }

        async function confirmFolderPicker() {
            if (folderPickerMode === 'move') {
                const target = folderPickerTargetFile;
                closeFolderPicker();
                if (target) {
                    await moveDriveFileToFolder(target, folderPickerCurrentFolderId);
                }
                return;
            }
            const name = folderPickerNameInput ? folderPickerNameInput.value.trim() : '';
            if (!name) return;
            closeFolderPicker();
            await createNewDriveDocumentWithFolder(folderPickerCurrentFolderId, name);
        }

        async function moveDriveFileToFolder(file, folderId) {
            if (!file?.id) return;
            try {
                showLoading('Moving file...');
                const metaRes = await driveFetch(`https://www.googleapis.com/drive/v3/files/${file.id}?fields=parents`);
                const meta = await metaRes.json();
                const parents = Array.isArray(meta.parents) ? meta.parents : [];
                const removeParents = parents.length > 0 ? parents.join(',') : '';
                const addParents = folderId || 'root';
                const params = new URLSearchParams();
                if (addParents) params.set('addParents', addParents);
                if (removeParents) params.set('removeParents', removeParents);
                await driveFetch(`https://www.googleapis.com/drive/v3/files/${file.id}?${params.toString()}`, {
                    method: 'PATCH'
                });
                showStatus('File moved', { preserveState: true });
                refreshDriveFiles();
            } catch (err) {
                showStatus('Move failed', { preserveState: true });
            } finally {
                hideLoading();
            }
        }

        function openTrashModal(file) {
            trashTargetFile = file;
            if (trashFileName) {
                trashFileName.textContent = file?.name || 'this file';
            }
            resetTrashSlider();
            if (trashModal) trashModal.classList.add('visible');
        }

        function closeTrashModal() {
            trashTargetFile = null;
            if (trashModal) trashModal.classList.remove('visible');
            resetTrashSlider();
        }

        function openDriveBinModal() {
            if (!driveAccessToken) return;
            if (driveBinModal) driveBinModal.classList.add('visible');
            refreshDriveBin();
        }

        function closeDriveBinModal() {
            if (driveBinModal) driveBinModal.classList.remove('visible');
        }

        async function refreshDriveBin() {
            if (!driveBinList || !driveAccessToken) return;
            driveBinList.innerHTML = '';
            driveBinList.setAttribute('aria-busy', 'true');
            if (driveBinEmpty) driveBinEmpty.classList.add('hidden');
            if (driveBinLoading) driveBinLoading.classList.remove('hidden');
            try {
                const q = encodeURIComponent(`trashed=true and (mimeType='application/pdf' or mimeType='application/vnd.google-apps.folder')`);
                const fields = encodeURIComponent('files(id,name,modifiedTime,createdTime,mimeType,parents)');
                const res = await driveFetch(`https://www.googleapis.com/drive/v3/files?q=${q}&orderBy=modifiedTime desc&pageSize=100&fields=${fields}`);
                const data = await res.json();
                const files = data.files || [];
                if (driveBinLoading) driveBinLoading.classList.add('hidden');
                driveBinList.setAttribute('aria-busy', 'false');
                if (files.length === 0) {
                    if (driveBinEmpty) driveBinEmpty.classList.remove('hidden');
                    return;
                }
                files.forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'bin-item';
                    const isFolder = file.mimeType === 'application/vnd.google-apps.folder';
                    item.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            ${isFolder
                                ? '<path d="M3 6a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>'
                                : '<path d="M6 2h8l4 4v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"/><path d="M14 2v6h6"/>'}
                        </svg>
                        <div>
                            <div>${file.name || 'Untitled'}</div>
                            <div class="bin-item-meta">Modified ${formatDriveDate(file.modifiedTime || file.createdTime)}</div>
                        </div>
                    `;
                    const menuWrap = document.createElement('div');
                    menuWrap.className = 'bin-item-menu';
                    const menuBtn = document.createElement('button');
                    menuBtn.type = 'button';
                    menuBtn.className = 'bin-item-more';
                    menuBtn.title = 'More actions';
                    menuBtn.setAttribute('aria-label', 'More actions');
                    menuBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor" aria-hidden="true">
                            <circle cx="5" cy="12" r="2"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                            <circle cx="19" cy="12" r="2"></circle>
                        </svg>
                    `;
                    const menu = document.createElement('div');
                    menu.className = 'bin-item-dropdown hidden';
                    menu.innerHTML = `
                        <button type="button" data-action="restore">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/>
                                <path d="M10 11l2-2 2 2"/>
                                <path d="M12 9v6"/>
                            </svg>
                            <span>Restore</span>
                        </button>
                    `;
                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleBinItemMenu(menu);
                    });
                    menu.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const btn = e.target?.closest ? e.target.closest('button[data-action]') : null;
                        const action = btn?.dataset?.action;
                        if (action === 'restore') {
                            closeBinItemMenu();
                            await restoreDriveFile(file);
                        }
                    });
                    menuWrap.appendChild(menuBtn);
                    menuWrap.appendChild(menu);
                    item.appendChild(menuWrap);
                    driveBinList.appendChild(item);
                });
            } catch (err) {
                if (driveBinLoading) driveBinLoading.classList.add('hidden');
                driveBinList.setAttribute('aria-busy', 'false');
                if (driveBinEmpty) driveBinEmpty.classList.remove('hidden');
            }
        }

        function toggleBinItemMenu(menuEl) {
            if (!menuEl) return;
            if (activeBinMenu && activeBinMenu !== menuEl) {
                activeBinMenu.classList.add('hidden');
            }
            const shouldOpen = menuEl.classList.contains('hidden');
            menuEl.classList.toggle('hidden', !shouldOpen);
            activeBinMenu = shouldOpen ? menuEl : null;
        }

        function closeBinItemMenu() {
            if (!activeBinMenu) return;
            activeBinMenu.classList.add('hidden');
            activeBinMenu = null;
        }

        async function restoreDriveFile(file) {
            if (!file?.id) return;
            try {
                showLoading('Restoring...');
                const parents = Array.isArray(file.parents) ? file.parents : [];
                const params = new URLSearchParams();
                if (parents.length > 0) {
                    params.set('addParents', parents.join(','));
                }
                await driveFetch(`https://www.googleapis.com/drive/v3/files/${file.id}?${params.toString()}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ trashed: false })
                });
                showStatus('Restored', { preserveState: true });
                refreshDriveBin();
                refreshDriveFiles();
            } catch (err) {
                showStatus('Restore failed', { preserveState: true });
            } finally {
                hideLoading();
            }
        }

        async function confirmTrashFile() {
            if (!trashTargetFile?.id) return;
            const target = trashTargetFile;
            closeTrashModal();
            try {
                showLoading('Moving to bin...');
                await driveFetch(`https://www.googleapis.com/drive/v3/files/${target.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ trashed: true })
                });
                showStatus('Moved to bin', { preserveState: true });
                refreshDriveFiles();
            } catch (err) {
                showStatus('Move to bin failed', { preserveState: true });
            } finally {
                hideLoading();
            }
        }

        function addImageToPage(pageIndex, src, dropPos, offsetIndex = 0, options = {}) {
            const page = state.pages[pageIndex];
            if (!page) return;
            if (!isPageLoaded(page)) {
                ensurePageCanvas(pageIndex);
                ensurePageDataLoaded(pageIndex, { keepLoaded: true }).then(() => {
                    if (options.retry) return;
                    addImageToPage(pageIndex, src, dropPos, offsetIndex, { retry: true });
                });
                return;
            }
            if (!Array.isArray(page.images)) page.images = [];

            const img = getCachedImage(src, () => redrawPage(pageIndex));
            if (!img) return;

            const placeImage = () => {
                const maxWidth = A4_WIDTH * 0.6;
                const maxHeight = A4_HEIGHT * 0.45;
                const naturalWidth = img.naturalWidth || maxWidth;
                const naturalHeight = img.naturalHeight || maxHeight;
                const scale = Math.min(maxWidth / naturalWidth, maxHeight / naturalHeight, 1);
                const width = naturalWidth * scale;
                const height = naturalHeight * scale;
                const offset = offsetIndex * 18;
                const centerX = clamp(dropPos.x + offset, width / 2, A4_WIDTH - width / 2);
                const centerY = clamp(dropPos.y + offset, height / 2, A4_HEIGHT - height / 2);

                const imageData = {
                    src,
                    x: centerX,
                    y: centerY,
                    width,
                    height,
                    rotation: 0
                };
                page.images.push(imageData);
                saveToHistory({
                    type: 'add-image',
                    pageIndex,
                    index: page.images.length - 1,
                    image: JSON.parse(JSON.stringify(imageData))
                });
                clearSelection();
                state.selection.pageIndex = pageIndex;
                state.selection.strokeIndices = [];
                state.selection.imageIndices = [page.images.length - 1];
                setActiveTool('lasso');
                updateSelectionBox();
                redrawPage(pageIndex);
                renderPagesList();
                scheduleSave(false, pageIndex);
                showStatus('Image added', { preserveState: true });
            };

            if (img.complete) {
                placeImage();
            } else {
                img.addEventListener('load', placeImage, { once: true });
            }
        }

        function handleImageDragOver(e) {
            if (state.isReadOnly) return;
            if (!e.dataTransfer) return;
            const types = Array.from(e.dataTransfer.types || []);
            const hasFiles = types.includes('Files');
            if (!hasFiles) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleImageDrop(e) {
            if (state.isReadOnly) return;
            if (!e.dataTransfer) return;
            e.preventDefault();
            const files = Array.from(e.dataTransfer.files || []).filter(file => file.type.startsWith('image/'));
            if (files.length === 0) return;

            const pageIndex = getPageIndexFromClientPoint(e.clientX, e.clientY);
            if (pageIndex === null) return;
            const dropPos = getPagePosFromClient(pageIndex, e.clientX, e.clientY);

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const src = reader.result;
                    if (typeof src === 'string') {
                        addImageToPage(pageIndex, src, dropPos, index);
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        function captureStrokes(pageIndex, indices) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return [];
            return indices.map(index => ({
                index,
                stroke: cloneStroke(page.strokes[index])
            }));
        }

        function captureImages(pageIndex, indices) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.images)) return [];
            return indices.map(index => ({
                index,
                image: JSON.parse(JSON.stringify(page.images[index]))
            }));
        }

        function applyTransformToSelection(originalStrokes, originalImages, transform, center, pageIndex) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return;
            const cos = Math.cos(transform.rotation);
            const sin = Math.sin(transform.rotation);

            originalStrokes.forEach(item => {
                const stroke = item.stroke;
                const updated = {
                    tool: stroke.tool,
                    color: stroke.color,
                    width: stroke.width,
                    points: stroke.points.map(pt => {
                        let x = pt.x - center.x;
                        let y = pt.y - center.y;
                        x *= transform.scaleX;
                        y *= transform.scaleY;
                        const rx = x * cos - y * sin;
                        const ry = x * sin + y * cos;
                        return {
                            x: center.x + rx + transform.translateX,
                            y: center.y + ry + transform.translateY,
                            p: pt.p
                        };
                    })
                };
                page.strokes[item.index] = updated;
            });

            if (Array.isArray(originalImages) && originalImages.length > 0) {
                if (!Array.isArray(page.images)) page.images = [];
                originalImages.forEach(item => {
                    const image = item.image;
                    let x = image.x - center.x;
                    let y = image.y - center.y;
                    x *= transform.scaleX;
                    y *= transform.scaleY;
                    const rx = x * cos - y * sin;
                    const ry = x * sin + y * cos;
                    page.images[item.index] = {
                        ...image,
                        x: center.x + rx + transform.translateX,
                        y: center.y + ry + transform.translateY,
                        width: image.width * transform.scaleX,
                        height: image.height * transform.scaleY,
                        rotation: (image.rotation || 0) + transform.rotation
                    };
                });
            }

            redrawPage(pageIndex);
        }

        function setupSelectionBoxEvents(selectionBox, pageIndex) {
            selectionBox.addEventListener('pointerdown', (e) => {
                if (state.isReadOnly) return;
                if (state.currentTool !== 'lasso') return;
                if (state.selection.pageIndex !== pageIndex) return;
                const target = e.target;
                if (target.closest && target.closest('.selection-duplicate')) {
                    duplicateSelection(pageIndex);
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                if (target.closest && target.closest('.selection-trash')) {
                    deleteSelection(pageIndex);
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                if (target.classList.contains('rotate-handle')) {
                    startSelectionTransform(pageIndex, 'rotate', 'rotate', e);
                } else if (target.classList.contains('selection-handle')) {
                    startSelectionTransform(pageIndex, 'scale', target.dataset.handle, e);
                } else {
                    startSelectionTransform(pageIndex, 'move', 'move', e);
                }
                e.preventDefault();
                e.stopPropagation();
            });
        }

        function startSelectionTransform(pageIndex, mode, handle, e) {
            if (state.isReadOnly) return;
            const bounds = getSelectionBounds(
                pageIndex,
                state.selection.strokeIndices,
                state.selection.imageIndices
            );
            if (!bounds) return;
            const center = {
                x: bounds.minX + bounds.width / 2,
                y: bounds.minY + bounds.height / 2
            };
            const startPos = getPagePosFromEvent(pageIndex, e);
            const originalStrokes = captureStrokes(pageIndex, state.selection.strokeIndices);
            const originalImages = captureImages(pageIndex, state.selection.imageIndices);
            const startAngle = Math.atan2(startPos.y - center.y, startPos.x - center.x);
            state.selectionTransform = {
                pageIndex,
                mode,
                handle,
                bounds,
                center,
                startPos,
                startAngle,
                originalStrokes,
                originalImages,
                pointerId: e.pointerId
            };
        }

        function onSelectionPointerMove(e) {
            if (state.isReadOnly) return;
            if (!state.selectionTransform) return;
            if (e.pointerId !== state.selectionTransform.pointerId) return;
            const { pageIndex, mode, handle, bounds, center, startPos, startAngle, originalStrokes, originalImages } = state.selectionTransform;
            const pos = getPagePosFromEvent(pageIndex, e);
            const transform = {
                translateX: 0,
                translateY: 0,
                scaleX: 1,
                scaleY: 1,
                rotation: 0
            };

            if (mode === 'move') {
                transform.translateX = pos.x - startPos.x;
                transform.translateY = pos.y - startPos.y;
            } else if (mode === 'scale') {
                const halfW = Math.max(10, bounds.width / 2);
                const halfH = Math.max(10, bounds.height / 2);
                const dx = (pos.x - center.x) / halfW;
                const dy = (pos.y - center.y) / halfH;
                const isCorner = ['ne', 'nw', 'se', 'sw'].includes(handle);
                if (isCorner) {
                    const currentDist = Math.hypot(pos.x - center.x, pos.y - center.y);
                    const baseDist = Math.hypot(halfW, halfH);
                    const uniform = Math.max(0.2, currentDist / baseDist);
                    transform.scaleX = uniform;
                    transform.scaleY = uniform;
                } else {
                    if (['e', 'w'].includes(handle)) {
                        transform.scaleX = Math.max(0.2, Math.abs(dx));
                    }
                    if (['n', 's'].includes(handle)) {
                        transform.scaleY = Math.max(0.2, Math.abs(dy));
                    }
                }
            } else if (mode === 'rotate') {
                const angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                transform.rotation = angle - startAngle;
            }

            applyTransformToSelection(originalStrokes, originalImages, transform, center, pageIndex);
            updateSelectionBox();
            e.preventDefault();
        }

        function onSelectionPointerUp(e) {
            if (state.isReadOnly) return;
            if (!state.selectionTransform) return;
            if (e.pointerId !== state.selectionTransform.pointerId) return;
            const { pageIndex, originalStrokes, originalImages } = state.selectionTransform;
            const afterStrokes = captureStrokes(pageIndex, state.selection.strokeIndices);
            const afterImages = captureImages(pageIndex, state.selection.imageIndices);
            const before = {
                strokes: originalStrokes,
                images: originalImages
            };
            const after = {
                strokes: afterStrokes,
                images: afterImages
            };
            const beforeJSON = JSON.stringify(before);
            const afterJSON = JSON.stringify(after);
            if (beforeJSON !== afterJSON) {
                saveToHistory({
                    type: 'transform-selection',
                    pageIndex: pageIndex,
                    before,
                    after
                });
                scheduleSave(false, pageIndex);
            }
            state.selectionTransform = null;
        }

        function splitStrokeByEraser(stroke, x, y, radius) {
            const segments = [];
            let current = [];
            const r = radius;
            const pts = stroke.points;
            for (let i = 0; i < pts.length; i++) {
                const pt = pts[i];
                const dist = Math.hypot(pt.x - x, pt.y - y);
                const inside = dist <= r;
                if (i > 0) {
                    const prev = pts[i - 1];
                    const crosses = !inside && distancePointToSegment(x, y, prev.x, prev.y, pt.x, pt.y) <= r;
                    if (crosses) {
                        if (current.length > 1) {
                            segments.push({
                                tool: stroke.tool,
                                color: stroke.color,
                                width: stroke.width,
                                points: current
                            });
                        }
                        current = [{ x: pt.x, y: pt.y, p: pt.p }];
                        continue;
                    }
                }

                if (!inside) {
                    current.push({ x: pt.x, y: pt.y, p: pt.p });
                } else {
                    if (current.length > 1) {
                        segments.push({
                            tool: stroke.tool,
                            color: stroke.color,
                            width: stroke.width,
                            points: current
                        });
                    }
                    current = [];
                }
            }
            if (current.length > 1) {
                segments.push({
                    tool: stroke.tool,
                    color: stroke.color,
                    width: stroke.width,
                    points: current
                });
            }
            return segments;
        }

        function distancePointToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            if (dx === 0 && dy === 0) {
                return Math.hypot(px - x1, py - y1);
            }
            const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
            const clamped = Math.max(0, Math.min(1, t));
            const cx = x1 + clamped * dx;
            const cy = y1 + clamped * dy;
            return Math.hypot(px - cx, py - cy);
        }

        function eraseAreaAtPoint(pageIndex, x, y, radius, options = {}) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return false;
            let changed = false;
            const newStrokes = [];

            for (const stroke of page.strokes) {
                if (!stroke) continue;
                if (stroke.points.length < 2) {
                    newStrokes.push(stroke);
                    continue;
                }
                if (stroke.tool && stroke.tool.startsWith('eraser')) {
                    newStrokes.push(stroke);
                    continue;
                }

                const segments = splitStrokeByEraser(stroke, x, y, radius);
                if (segments.length === 1 && segments[0].points.length === stroke.points.length) {
                    newStrokes.push(stroke);
                } else {
                    changed = true;
                    segments.forEach(seg => newStrokes.push(seg));
                }
            }

            if (changed) {
                page.strokes = newStrokes;
                if (!options.deferRedraw) {
                    redrawPage(pageIndex);
                }
            }

            return changed;
        }

        // Erase entire stroke that intersects with point
        function eraseStrokeAtPoint(pageIndex, x, y, erasedList, hitRadius = 15) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return;
            
            for (let i = page.strokes.length - 1; i >= 0; i--) {
                const stroke = page.strokes[i];
                if (stroke.tool && stroke.tool.startsWith('eraser')) continue; // Don't erase eraser strokes
                
                for (const point of stroke.points) {
                    const dist = Math.hypot(point.x - x, point.y - y);
                    if (dist < hitRadius) {
                        // Remove stroke and add to erased list
                        const removed = page.strokes.splice(i, 1)[0];
                        erasedList.push({ index: i, stroke: cloneStroke(removed) });
                        redrawPage(pageIndex);
                        break;
                    }
                }
            }
        }

        // Get canvas position accounting for scale
        function getCanvasPos(canvas, e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width / CANVAS_SCALE),
                y: (e.clientY - rect.top) * (canvas.height / rect.height / CANVAS_SCALE)
            };
        }

        function touchImageCache(src) {
            if (!src) return;
            imageCacheUsage.set(src, Date.now());
            pruneImageCache();
        }

        function pruneImageCache() {
            if (imageCache.size <= MAX_IMAGE_CACHE) return;
            const candidates = Array.from(imageCacheUsage.entries())
                .sort((a, b) => a[1] - b[1]);
            while (imageCache.size > MAX_IMAGE_CACHE && candidates.length > 0) {
                const [src] = candidates.shift();
                imageCache.delete(src);
                imageCacheUsage.delete(src);
            }
            if (imageCache.size > MAX_IMAGE_CACHE) {
                const fallback = Array.from(imageCache.keys());
                while (imageCache.size > MAX_IMAGE_CACHE && fallback.length > 0) {
                    const src = fallback.shift();
                    imageCache.delete(src);
                    imageCacheUsage.delete(src);
                }
            }
        }

        function getCachedImage(src, onload) {
            if (!src) return null;
            let img = imageCache.get(src);
            if (!img) {
                img = new Image();
                img.onload = () => {
                    if (onload) onload();
                };
                img.src = src;
                imageCache.set(src, img);
            } else if (onload && !img.complete) {
                img.addEventListener('load', onload, { once: true });
            }
            touchImageCache(src);
            return img;
        }

        function getStrokeWidth(stroke) {
            return stroke.width;
        }

        function setStrokeCaps(ctx, tool) {
            if (tool === 'highlighter') {
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'round';
            } else {
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            }
        }

        function ensureHighlighterMask() {
            const width = A4_WIDTH * CANVAS_SCALE;
            const height = A4_HEIGHT * CANVAS_SCALE;
            if (highlighterMaskCanvas.width !== width || highlighterMaskCanvas.height !== height) {
                highlighterMaskCanvas.width = width;
                highlighterMaskCanvas.height = height;
            }
        }

        function addRoundedRectPath(ctx, x, y, width, height, radius) {
            const r = Math.max(0, Math.min(radius, width / 2, height / 2));
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + width - r, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + r);
            ctx.lineTo(x + width, y + height - r);
            ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
            ctx.lineTo(x + r, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawFixedHighlighterStroke(ctx, stroke) {
            if (!stroke || !stroke.points || stroke.points.length === 0) return;
            ensureHighlighterMask();

            const maskCtx = highlighterMaskCtx;
            maskCtx.setTransform(1, 0, 0, 1, 0, 0);
            maskCtx.clearRect(0, 0, highlighterMaskCanvas.width, highlighterMaskCanvas.height);
            maskCtx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
            maskCtx.globalCompositeOperation = 'source-over';
            maskCtx.globalAlpha = 1;
            maskCtx.fillStyle = stroke.color || '#ffde00';

            const thickness = Math.max(1, stroke.width || 12);
            const brushWidth = thickness;
            const brushHeight = thickness * 1.2;
            const halfW = brushWidth / 2;
            const halfH = brushHeight / 2;
            const radius = thickness * 0.28;
            const spacing = Math.max(0.5, Math.min(brushWidth, brushHeight) * 0.12);

            const points = stroke.points;
            const addStamp = (x, y) => {
                maskCtx.beginPath();
                addRoundedRectPath(maskCtx, x - halfW, y - halfH, brushWidth, brushHeight, radius);
                maskCtx.fill();
            };

            let prev = points[0];
            addStamp(prev.x, prev.y);

            for (let i = 1; i < points.length; i++) {
                const curr = points[i];
                const dx = curr.x - prev.x;
                const dy = curr.y - prev.y;
                const dist = Math.hypot(dx, dy);
                if (dist === 0) {
                    prev = curr;
                    continue;
                }
                const steps = Math.max(1, Math.ceil(dist / spacing));
                for (let s = 1; s <= steps; s++) {
                    const t = s / steps;
                    addStamp(prev.x + dx * t, prev.y + dy * t);
                }
                prev = curr;
            }

            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 0.35;
            ctx.drawImage(highlighterMaskCanvas, 0, 0, A4_WIDTH, A4_HEIGHT);
            ctx.restore();
        }

        function buildSmoothPath(ctx, points) {
            if (points.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            if (points.length === 2) {
                ctx.lineTo(points[1].x, points[1].y);
                return;
            }
            for (let i = 1; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                const mid = {
                    x: (current.x + next.x) / 2,
                    y: (current.y + next.y) / 2
                };
                ctx.quadraticCurveTo(current.x, current.y, mid.x, mid.y);
            }
            const last = points[points.length - 1];
            ctx.lineTo(last.x, last.y);
        }

        function drawHighlighterCaps(ctx, stroke) {
            const points = stroke.points;
            if (!points || points.length < 2) return;
            const radius = Math.max(1, stroke.width * 0.16);
            ctx.save();
            ctx.globalAlpha *= 0.45;
            ctx.fillStyle = stroke.color;
            ctx.beginPath();
            ctx.arc(points[0].x, points[0].y, radius, 0, Math.PI * 2);
            ctx.arc(points[points.length - 1].x, points[points.length - 1].y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawSmoothStroke(ctx, stroke) {
            if (!stroke || !stroke.points || stroke.points.length === 0) return;
            if (stroke.tool === 'highlighter') {
                drawFixedHighlighterStroke(ctx, stroke);
                return;
            }
            if (stroke.points.length < 2) return;
            setupContext(ctx, stroke.tool, stroke.color, stroke.width);
            setStrokeCaps(ctx, stroke.tool);
            ctx.lineWidth = getStrokeWidth(stroke);

            const points = stroke.points;
            if (points.length === 2) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.stroke();
                return;
            }

            const p0 = points[0];
            const p1 = points[1];
            let prevMid = {
                x: (p0.x + p1.x) / 2,
                y: (p0.y + p1.y) / 2
            };

            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(prevMid.x, prevMid.y);
            ctx.stroke();

            for (let i = 1; i < points.length - 1; i++) {
                const current = points[i];
                const next = points[i + 1];
                const mid = {
                    x: (current.x + next.x) / 2,
                    y: (current.y + next.y) / 2
                };
                ctx.beginPath();
                ctx.moveTo(prevMid.x, prevMid.y);
                ctx.quadraticCurveTo(current.x, current.y, mid.x, mid.y);
                ctx.stroke();
                prevMid = mid;
            }

            const last = points[points.length - 1];
            ctx.beginPath();
            ctx.moveTo(prevMid.x, prevMid.y);
            ctx.lineTo(last.x, last.y);
            ctx.stroke();
        }

        function drawImagesOnContext(ctx, page, pageIndex, onload) {
            if (!page || !Array.isArray(page.images) || page.images.length === 0) return;
            page.images.forEach(image => {
                if (!image || !image.src) return;
                const img = getCachedImage(image.src, onload ? () => onload(pageIndex) : null);
                if (!img || !img.complete) return;
                ctx.save();
                ctx.translate(image.x, image.y);
                ctx.rotate(image.rotation || 0);
                ctx.drawImage(
                    img,
                    -image.width / 2,
                    -image.height / 2,
                    image.width,
                    image.height
                );
                ctx.restore();
            });
        }

        // Setup context for different tools
        function setupContext(ctx, tool, color, width) {
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;

            if (tool === 'eraser-area') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = width;
                ctx.strokeStyle = 'rgba(0,0,0,1)';
            } else if (tool === 'highlighter') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 0.35;
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
            } else {
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
            }
        }

        // Redraw page with smooth quadratic curves
        function redrawPage(pageIndex) {
            const canvas = document.querySelector(`canvas[data-page="${pageIndex}"]`);
            const page = state.pages[pageIndex];
            if (!page) return;
            if (!canvas) {
                page.needsRedraw = true;
                return;
            }
            if (!isPageLoaded(page)) {
                page.needsRedraw = true;
                applyPagePreview(pageIndex);
                ensurePageDataLoaded(pageIndex);
                return;
            }

            const ctx = canvas.getContext('2d');
            ctx.save();
            ctx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
            ctx.clearRect(0, 0, A4_WIDTH, A4_HEIGHT);

            // Draw baked background if available (contains old strokes)
            if (page.bakedBackground) {
                const bakedImg = getCachedImage(page.bakedBackground, () => redrawPage(pageIndex));
                if (bakedImg.complete) {
                    ctx.drawImage(bakedImg, 0, 0, A4_WIDTH, A4_HEIGHT);
                }
            }

            drawImagesOnContext(ctx, page, pageIndex, redrawPage);

            for (const stroke of page.strokes) {
                const minPoints = stroke.tool === 'highlighter' ? 1 : 2;
                if (!stroke.points || stroke.points.length < minPoints) continue;
                if (stroke.tool === 'eraser-stroke') continue;
                drawSmoothStroke(ctx, stroke);
            }

            ctx.restore();
            page.needsRedraw = false;
        }

        // Render all pages
        function renderAllPages() {
            clearSelection();
            canvasContainer.innerHTML = '';
            canvasContainer.appendChild(addPageIndicator);
            activePageIndices.clear();
            state.pages.forEach((_, index) => {
                createPageElement(index, false, false);
            });
            updateAddPageIndicator();
            const maxIndex = Math.max(0, state.pages.length - 1);
            state.activePageIndex = Math.min(Math.max(0, state.activePageIndex || 0), maxIndex);
            scheduleVisiblePageUpdate(true);
        }

        function bakeLegacyEraserAreaStrokes() {
            let changed = false;
            state.pages.forEach((page, pageIndex) => {
                if (!page || !Array.isArray(page.strokes)) return;
                const erasers = page.strokes.filter(stroke => stroke.tool === 'eraser-area' && stroke.points && stroke.points.length);
                if (erasers.length === 0) return;
                changed = true;

                page.strokes = page.strokes.filter(stroke => !(stroke.tool && stroke.tool.startsWith('eraser')));
                erasers.forEach(stroke => {
                    const radius = (stroke.width || state.eraserWidth) / 2;
                    stroke.points.forEach(pt => {
                        eraseAreaAtPoint(pageIndex, pt.x, pt.y, radius, { deferRedraw: true });
                    });
                });
            });
            if (changed) {
                markAllPagesDirty();
                scheduleSave(true);
            }
        }

        function syncEraserMenuState() {
            if (!eraserToggle) return;
            eraserToggle.checked = state.eraserMode === 'stroke';
            document.querySelectorAll('#eraser-menu .size-btn[data-eraser-size]').forEach(btn => {
                const size = parseFloat(btn.dataset.eraserSize);
                btn.classList.toggle('active', size === state.eraserWidth);
            });
        }

        function positionEraserMenu() {
            if (!eraserMenu || !eraserButton) return;
            const btnRect = eraserButton.getBoundingClientRect();
            const menuRect = eraserMenu.getBoundingClientRect();
            const margin = 12;
            const header = document.querySelector('header');
            const headerHeight = header ? header.getBoundingClientRect().height : 60;
            let left = btnRect.right + 12;
            let top = btnRect.top + (btnRect.height - menuRect.height) / 2;

            if (toolbar.classList.contains('horizontal')) {
                left = btnRect.left + (btnRect.width - menuRect.width) / 2;
                top = btnRect.top - menuRect.height - 12;
            }

            left = Math.max(margin, Math.min(left, window.innerWidth - menuRect.width - margin));
            top = Math.max(headerHeight + margin, Math.min(top, window.innerHeight - menuRect.height - margin));

            eraserMenu.style.left = `${left}px`;
            eraserMenu.style.top = `${top}px`;
        }

        function openEraserMenu() {
            if (!eraserMenu) return;
            syncEraserMenuState();
            eraserMenu.classList.add('visible');
            eraserMenu.setAttribute('aria-hidden', 'false');
            requestAnimationFrame(positionEraserMenu);
        }

        function closeEraserMenu() {
            if (!eraserMenu) return;
            eraserMenu.classList.remove('visible');
            eraserMenu.setAttribute('aria-hidden', 'true');
        }

        function toggleEraserMenu() {
            if (!eraserMenu) return;
            if (eraserMenu.classList.contains('visible')) {
                closeEraserMenu();
            } else {
                openEraserMenu();
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Tool buttons
            toolbar.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (state.isReadOnly) return;
                    toolbar.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const nextTool = btn.dataset.tool;
                    if (nextTool === 'eraser') {
                        const isEraserActive = state.currentTool === 'eraser-area' || state.currentTool === 'eraser-stroke';
                        if (isEraserActive) {
                            toggleEraserMenu();
                            return;
                        }
                    }

                    if (nextTool !== 'lasso') {
                        clearSelection();
                    }
                    if (nextTool === 'eraser') {
                        state.currentTool = state.eraserMode === 'stroke' ? 'eraser-stroke' : 'eraser-area';
                    } else {
                        state.currentTool = nextTool;
                        if (btn.dataset.color) state.currentColor = btn.dataset.color;
                        if (btn.dataset.width) state.currentWidth = parseFloat(btn.dataset.width);
                    }
                    if (nextTool !== 'eraser') {
                        closeEraserMenu();
                    }
                    rememberNonEraserTool(state.currentTool);
                });
            });

            if (driveLoginBtn) {
                driveLoginBtn.addEventListener('click', signInDrive);
            }
            if (driveNewBtn) {
                driveNewBtn.addEventListener('click', createNewDriveDocument);
            }
            if (driveMenuRefreshBtn) {
                driveMenuRefreshBtn.addEventListener('click', () => {
                    closeDriveProfileMenus();
                    refreshDriveFiles();
                });
            }
            if (driveMenuLogoutBtn) {
                driveMenuLogoutBtn.addEventListener('click', () => {
                    closeDriveProfileMenus();
                    signOutDrive();
                });
            }
            if (driveMenuRefreshBtnEditor) {
                driveMenuRefreshBtnEditor.addEventListener('click', () => {
                    closeDriveProfileMenus();
                    refreshDriveFiles();
                });
            }
            if (driveMenuLogoutBtnEditor) {
                driveMenuLogoutBtnEditor.addEventListener('click', () => {
                    closeDriveProfileMenus();
                    signOutDrive();
                });
            }
            if (folderPickerCancel) {
                folderPickerCancel.addEventListener('click', closeFolderPicker);
            }
            if (folderPickerConfirm) {
                folderPickerConfirm.addEventListener('click', confirmFolderPicker);
            }
            if (folderPickerModal) {
                folderPickerModal.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'modal-folder-picker') {
                        closeFolderPicker();
                    }
                });
            }
            if (driveBinBtn) {
                driveBinBtn.addEventListener('click', openDriveBinModal);
            }
            if (driveBinClose) {
                driveBinClose.addEventListener('click', closeDriveBinModal);
            }
            if (driveBinModal) {
                driveBinModal.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'modal-drive-bin') {
                        closeDriveBinModal();
                    }
                });
            }
            if (folderPickerNameInput) {
                folderPickerNameInput.addEventListener('input', updateFolderPickerConfirmState);
                folderPickerNameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        confirmFolderPicker();
                    }
                });
            }
            if (trashCancelBtn) {
                trashCancelBtn.addEventListener('click', closeTrashModal);
            }
            if (trashModal) {
                trashModal.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'modal-trash-file') {
                        closeTrashModal();
                    }
                });
            }
            if (driveProfileBtn) {
                driveProfileBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleDriveProfileMenu(driveProfileMenu, driveProfileBtn);
                });
            }
            if (driveProfileBtnEditor) {
                driveProfileBtnEditor.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleDriveProfileMenu(driveProfileMenuEditor, driveProfileBtnEditor);
                });
            }
            if (themeToggle) {
                themeToggle.addEventListener('change', () => {
                    const next = themeToggle.checked ? 'dark' : 'light';
                    applyTheme(next, true);
                });
            }
            if (themeToggleEditor) {
                themeToggleEditor.addEventListener('change', () => {
                    const next = themeToggleEditor.checked ? 'dark' : 'light';
                    applyTheme(next, true);
                });
            }
            if (driveHomeBtn) {
                const goHome = () => {
                    showDriveHome();
                    refreshDriveFiles();
                };
                driveHomeBtn.addEventListener('click', (e) => {
                    if (docTitleEl && docTitleEl.contains(e.target)) return;
                    goHome();
                });
                driveHomeBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        goHome();
                    }
                });
            }
            if (docTitleEl) {
                docTitleEl.addEventListener('focus', () => {
                    if (state.isReadOnly) {
                        docTitleEl.blur();
                        return;
                    }
                    beginDocTitleEdit();
                });
                docTitleEl.addEventListener('blur', () => {
                    if (state.isReadOnly) return;
                    if (!docTitleEditing) return;
                    finishDocTitleEdit(true);
                });
                docTitleEl.addEventListener('keydown', (e) => {
                    if (state.isReadOnly) return;
                    e.stopPropagation();
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        docTitleEl.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        finishDocTitleEdit(false);
                        docTitleEl.blur();
                    }
                });
                docTitleEl.addEventListener('pointerdown', (e) => {
                    e.stopPropagation();
                });
                docTitleEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (state.isReadOnly) {
                        setReadOnlyMode(false, { user: true });
                        requestAnimationFrame(() => {
                            docTitleEl.focus();
                        });
                    }
                });
            }
            if (driveProfileAvatar) {
                driveProfileAvatar.addEventListener('error', () => {
                    driveProfileAvatar.src = DEFAULT_AVATAR;
                });
            }
            if (driveProfileAvatarMenu) {
                driveProfileAvatarMenu.addEventListener('error', () => {
                    driveProfileAvatarMenu.src = DEFAULT_AVATAR;
                });
            }
            if (driveProfileAvatarEditor) {
                driveProfileAvatarEditor.addEventListener('error', () => {
                    driveProfileAvatarEditor.src = DEFAULT_AVATAR;
                });
            }
            if (driveProfileAvatarMenuEditor) {
                driveProfileAvatarMenuEditor.addEventListener('error', () => {
                    driveProfileAvatarMenuEditor.src = DEFAULT_AVATAR;
                });
            }
            document.addEventListener('click', (e) => {
                if (activeBinMenu && !activeBinMenu.contains(e.target)) {
                    closeBinItemMenu();
                }
                if (activeDriveCardMenu && !activeDriveCardMenu.contains(e.target)) {
                    closeDriveCardMenu();
                }
                const profileMenus = [driveProfileMenu, driveProfileMenuEditor].filter(Boolean);
                const profileButtons = [driveProfileBtn, driveProfileBtnEditor].filter(Boolean);
                const clickedInsideMenu = profileMenus.some(menu => menu.contains(e.target));
                const clickedButton = profileButtons.some(btn => btn.contains(e.target));
                if (clickedInsideMenu || clickedButton) return;
                closeDriveProfileMenus();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeFolderPicker();
                    closeTrashModal();
                    closeDriveBinModal();
                    closeBinItemMenu();
                    closeDriveProfileMenus();
                }
            });
            if (driveBackBtn) {
                driveBackBtn.addEventListener('click', () => {
                    if (driveFolderStack.length <= 1) return;
                    driveFolderStack.pop();
                    driveCurrentFolderId = driveFolderStack[driveFolderStack.length - 1].id;
                    renderDriveBreadcrumbs();
                    if (driveStatusEl) driveStatusEl.textContent = 'Loading folder...';
                    refreshDriveFolderContents();
                });
            }
            if (driveSearchInput) {
                let driveSearchTimeout = null;
                driveSearchInput.addEventListener('input', () => {
                    clearTimeout(driveSearchTimeout);
                    driveSearchTimeout = setTimeout(() => {
                        refreshDriveFiles();
                    }, 250);
                });
            }

            document.querySelectorAll('#eraser-menu .size-btn[data-eraser-size]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (state.isReadOnly) return;
                    document.querySelectorAll('#eraser-menu .size-btn[data-eraser-size]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.eraserWidth = parseFloat(btn.dataset.eraserSize);
                });
            });

            if (eraserToggle) {
                eraserToggle.addEventListener('change', () => {
                    if (state.isReadOnly) return;
                    state.eraserMode = eraserToggle.checked ? 'stroke' : 'area';
                    if (state.currentTool === 'eraser-area' || state.currentTool === 'eraser-stroke') {
                        state.currentTool = state.eraserMode === 'stroke' ? 'eraser-stroke' : 'eraser-area';
                    }
                });
            }

            if (modeToggleBtn) {
                modeToggleBtn.addEventListener('click', () => {
                    setReadOnlyMode(!state.isReadOnly, { user: true });
                });
            }


            document.addEventListener('pointerdown', (e) => {
                if (!eraserMenu || !eraserMenu.classList.contains('visible')) return;
                if (eraserMenu.contains(e.target)) return;
                if (eraserButton && (e.target === eraserButton || eraserButton.contains(e.target))) return;
                closeEraserMenu();
            });

            window.addEventListener('resize', () => {
                if (eraserMenu && eraserMenu.classList.contains('visible')) {
                    positionEraserMenu();
                }
                resetResetSlider();
                preserveViewOnResize();
            });

            // Export/Import PDF
            document.getElementById('btn-export-pdf').addEventListener('click', openExportModal);
            document.getElementById('btn-import-pdf').addEventListener('click', () => {
                if (state.isReadOnly) return;
                pdfInput.click();
            });
            pdfInput.addEventListener('change', importPDF);
            document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
            if (driveFullscreenBtn) {
                driveFullscreenBtn.addEventListener('click', toggleFullscreen);
            }
            const resetBtn = document.getElementById('btn-reset-document');
            if (resetBtn) {
                resetBtn.addEventListener('click', openResetModal);
            }

            // Undo/Redo buttons
            document.getElementById('btn-undo').addEventListener('click', () => {
                if (state.isReadOnly) return;
                undo();
            });
            document.getElementById('btn-redo').addEventListener('click', () => {
                if (state.isReadOnly) return;
                redo();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (state.isReadOnly) return;
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                } else if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    redo();
                }
            });

            // Pages panel
            document.getElementById('btn-edit-pages').addEventListener('click', openPagesPanel);
            document.getElementById('panel-close').addEventListener('click', closePagesPanel);
            document.getElementById('panel-overlay').addEventListener('click', closePagesPanel);

            // Delete modal
            document.getElementById('modal-delete-cancel').addEventListener('click', closeDeleteModal);
            document.getElementById('modal-delete-confirm').addEventListener('click', confirmDeletePage);
            document.getElementById('modal-delete-page').addEventListener('click', (e) => {
                if (e.target.id === 'modal-delete-page') closeDeleteModal();
            });
            document.getElementById('modal-reset-document').addEventListener('click', (e) => {
                if (e.target.id === 'modal-reset-document') closeResetModal();
            });
            document.getElementById('modal-export-cancel').addEventListener('click', closeExportModal);
            document.getElementById('modal-export-confirm').addEventListener('click', confirmExportModal);
            document.getElementById('modal-export-pdf').addEventListener('click', (e) => {
                if (e.target.id === 'modal-export-pdf') closeExportModal();
            });
            const exportInput = document.getElementById('export-filename');
            if (exportInput) {
                exportInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        confirmExportModal();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        closeExportModal();
                    }
                });
            }
            setupResetSlider();
            setupTrashSlider();

            // Viewport pan/zoom with touch and mouse
            canvasViewport.addEventListener('pointerdown', handleViewportPointerDown);
            canvasViewport.addEventListener('pointermove', handleViewportPointerMove);
            canvasViewport.addEventListener('pointerup', handleViewportPointerUp);
            canvasViewport.addEventListener('pointercancel', handleViewportPointerUp);
            canvasViewport.addEventListener('pointerleave', handleViewportPointerUp);
            document.addEventListener('pointermove', onSelectionPointerMove);
            document.addEventListener('pointerup', onSelectionPointerUp);

            // Mouse wheel for scroll and zoom
            canvasViewport.addEventListener('wheel', handleWheel, { passive: false });

            // Drag & drop images
            canvasViewport.addEventListener('dragover', handleImageDragOver);
            canvasViewport.addEventListener('drop', handleImageDrop);

            // Setup toolbar dragging
            setupToolbarDrag();

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);
            handleFullscreenChange();

            window.addEventListener('beforeunload', () => {
                flushOnClose();
            });

            window.addEventListener('pagehide', () => {
                flushOnClose();
            });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    flushOnClose();
                }
            });
        }

        function isFullscreenActive() {
            return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
        }

        function setFullscreenButtonState(button, isActive) {
            if (!button) return;
            const label = isActive ? 'Exit fullscreen' : 'Fullscreen';
            button.title = label;
            button.setAttribute('aria-label', label);
            button.classList.toggle('active', isActive);
            button.innerHTML = isActive ? FULLSCREEN_ICON_EXIT : FULLSCREEN_ICON_ENTER;
        }

        function updateFullscreenButton() {
            const isActive = !!isFullscreenActive();
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            setFullscreenButtonState(fullscreenBtn, isActive);
            setFullscreenButtonState(driveFullscreenBtn, isActive);
        }

        function handleFullscreenChange() {
            updateFullscreenButton();
            // Allow layout to settle before recalculating layout-dependent positions
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 50);
        }

        function toggleFullscreen() {
            const root = document.documentElement;
            if (isFullscreenActive()) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                return;
            }
            if (root.requestFullscreen) {
                root.requestFullscreen();
            } else if (root.webkitRequestFullscreen) {
                root.webkitRequestFullscreen();
            } else if (root.msRequestFullscreen) {
                root.msRequestFullscreen();
            }
        }

        function getContentHeight() {
            const pageCount = state.pages.length;
            const gap = PAGE_GAP;
            const padding = PAGE_PADDING;
            if (pageCount === 0) return 0;
            return padding * 2 + pageCount * A4_HEIGHT + Math.max(0, pageCount - 1) * gap;
        }

        function getPageBounds() {
            const pageCount = state.pages.length || 1;
            const gap = PAGE_GAP;
            const padding = PAGE_PADDING;
            const height = pageCount * A4_HEIGHT + Math.max(0, pageCount - 1) * gap;
            return {
                left: padding,
                top: padding,
                right: padding + A4_WIDTH,
                bottom: padding + height
            };
        }

        function clampPanToVisible() {
            const rect = canvasViewport.getBoundingClientRect();
            if (!rect.width || !rect.height) return;
            const bounds = getPageBounds();
            const minPanX = MIN_PAGE_VISIBLE - bounds.right * state.zoom;
            const maxPanX = rect.width - MIN_PAGE_VISIBLE - bounds.left * state.zoom;
            const minPanY = MIN_PAGE_VISIBLE - bounds.bottom * state.zoom;
            const maxPanY = rect.height - MIN_PAGE_VISIBLE - bounds.top * state.zoom;

            if (minPanX > maxPanX) {
                state.panX = (minPanX + maxPanX) / 2;
            } else {
                state.panX = Math.max(minPanX, Math.min(state.panX, maxPanX));
            }

            if (minPanY > maxPanY) {
                state.panY = (minPanY + maxPanY) / 2;
            } else {
                state.panY = Math.max(minPanY, Math.min(state.panY, maxPanY));
            }
        }

        function getBottomLimit() {
            const viewportHeight = canvasViewport.getBoundingClientRect().height;
            const totalHeight = getContentHeight() * state.zoom;
            const minPanY = viewportHeight - OVERSCROLL_MARGIN - totalHeight;
            return { minPanY };
        }

        function updateAddPageIndicator() {
            if (!addPageIndicator) return;
            if (state.isReadOnly) {
                addPageIndicator.style.opacity = 0;
                return;
            }
            const pageCount = state.pages.length;
            if (pageCount === 0) {
                addPageIndicator.style.opacity = 0;
                return;
            }
            const gap = PAGE_GAP;
            const padding = PAGE_PADDING;
            const bottom = padding + pageCount * A4_HEIGHT + Math.max(0, pageCount - 1) * gap;
            addPageIndicator.style.left = '50%';
            addPageIndicator.style.top = (bottom + 20) + 'px';
            addPageIndicator.style.transform = 'translateX(-50%)';
            const viewportHeight = canvasViewport.getBoundingClientRect().height;
            const bottomInView = state.panY + getContentHeight() * state.zoom;
            const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;
            const progress = Math.min(1, state.overscrollY / OVERSCROLL_THRESHOLD);
            let opacity = 0;
            if (state.overscrollY > 0) {
                opacity = Math.min(1, 0.2 + progress * 0.8);
                if (!canCreate) {
                    opacity *= 0.6;
                }
            }
            addPageIndicator.style.opacity = opacity.toString();
        }

        function animatePanTo(targetY) {
            canvasContainer.style.transition = 'transform 0.35s ease';
            state.panY = targetY;
            updateTransform();
            setTimeout(() => {
                canvasContainer.style.transition = '';
            }, 360);
        }

        function applyVerticalPan(dy) {
            if (dy === 0) return;
            if (state.isReadOnly) {
                const { minPanY } = getBottomLimit();
                state.panY = Math.max(minPanY, state.panY + dy);
                state.overscrollY = 0;
                state.pendingPageCreate = false;
                state.pageCreateLocked = false;
                updateAddPageIndicator();
                return;
            }
            const { minPanY } = getBottomLimit();
            const nextPanY = state.panY + dy;

            if (dy < 0 && nextPanY < minPanY) {
                const excess = minPanY - nextPanY;
                const viewportHeight = canvasViewport.getBoundingClientRect().height;
                const requiredOverscroll = Math.max(0, (viewportHeight * (1 - CREATE_PAGE_MIN_BOTTOM_RATIO) - OVERSCROLL_MARGIN) / OVERSCROLL_FRICTION);
                const maxOverscroll = Math.max(OVERSCROLL_THRESHOLD * 3, requiredOverscroll * 1.1);
                state.overscrollY = Math.min(maxOverscroll, state.overscrollY + excess);
                state.panY = minPanY - state.overscrollY * OVERSCROLL_FRICTION;

                const bottomInView = state.panY + getContentHeight() * state.zoom;
                const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;

                state.pendingPageCreate = state.overscrollY >= OVERSCROLL_THRESHOLD && canCreate;
                state.pageCreateLocked = state.pendingPageCreate;
                updateAddPageIndicator();
                if (overscrollResetTimeout) {
                    clearTimeout(overscrollResetTimeout);
                }
                overscrollResetTimeout = setTimeout(() => {
                    if (state.overscrollY > 0) {
                        const reset = getBottomLimit();
                        state.overscrollY = 0;
                        state.panY = Math.max(state.panY, reset.minPanY);
                        state.pendingPageCreate = false;
                        state.pageCreateLocked = false;
                        updateAddPageIndicator();
                        updateTransform();
                    }
                }, 600);
                return;
            }

            if (dy > 0 && state.overscrollY > 0) {
                const remaining = Math.max(0, dy - state.overscrollY);
                state.overscrollY = Math.max(0, state.overscrollY - dy);
                state.panY = minPanY - state.overscrollY * OVERSCROLL_FRICTION;
                if (remaining > 0) {
                    state.panY += remaining;
                }
                const viewportHeight = canvasViewport.getBoundingClientRect().height;
                const bottomInView = state.panY + getContentHeight() * state.zoom;
                const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;
                state.pendingPageCreate = state.overscrollY >= OVERSCROLL_THRESHOLD && canCreate;
                state.pageCreateLocked = state.pendingPageCreate;
                updateAddPageIndicator();
                return;
            }

            state.panY = nextPanY;
            state.pendingPageCreate = false;
            state.pageCreateLocked = false;
            updateAddPageIndicator();
        }

        function stopInertia(triggerUpdate = false) {
            if (state.inertiaFrame) {
                cancelAnimationFrame(state.inertiaFrame);
                state.inertiaFrame = null;
            }
            state.panVelocityX = 0;
            state.panVelocityY = 0;
            state.lastPanTime = 0;
            if (triggerUpdate) {
                scheduleVisiblePageUpdate(true);
            }
        }

        function startInertia() {
            if (state.inertiaFrame) return;
            let lastTime = performance.now();
            state.inertiaFrame = requestAnimationFrame(function step(time) {
                const dt = Math.max(1, time - lastTime);
                lastTime = time;

                const decay = Math.pow(TOUCH_INERTIA_DECAY, dt / 16.67);
                state.panVelocityX *= decay;
                state.panVelocityY *= decay;

                if (Math.abs(state.panVelocityX) < TOUCH_INERTIA_STOP && Math.abs(state.panVelocityY) < TOUCH_INERTIA_STOP) {
                    stopInertia(true);
                    return;
                }

                const dx = state.panVelocityX * dt;
                const dy = state.panVelocityY * dt;

                if (state.inertiaLock === 'vertical') {
                    applyVerticalPan(dy);
                } else if (state.inertiaLock === 'horizontal') {
                    state.panX += dx;
                } else {
                    state.panX += dx;
                    applyVerticalPan(dy);
                }

                updateTransform();
                state.inertiaFrame = requestAnimationFrame(step);
            });
        }

        // Toolbar dragging functionality
        function setupToolbarDrag() {
            const toolbarHandle = document.getElementById('toolbar-handle');
            let isDragging = false;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let snapTimeout = null;

            function getHeaderHeight() {
                const header = document.querySelector('header');
                return header ? header.getBoundingClientRect().height : 60;
            }

            function getToolbarSize() {
                const rect = toolbar.getBoundingClientRect();
                return { width: rect.width, height: rect.height };
            }

            function getToolbarLimits(toolbarSize, margin) {
                const headerHeight = getHeaderHeight();
                const minTop = headerHeight + margin;
                const maxTop = Math.max(minTop, window.innerHeight - toolbarSize.height - margin);
                const minLeft = margin;
                const maxLeft = Math.max(minLeft, window.innerWidth - toolbarSize.width - margin);
                return { minTop, maxTop, minLeft, maxLeft };
            }

            function updateToolbarScale(margin) {
                const headerHeight = getHeaderHeight();
                const availableHeight = window.innerHeight - headerHeight - margin;
                const availableWidth = window.innerWidth - margin * 2;
                const baseWidth = toolbar.offsetWidth;
                const baseHeight = toolbar.offsetHeight;
                if (!baseWidth || !baseHeight) return;
                const scale = Math.min(1, availableHeight / baseHeight, availableWidth / baseWidth);
                const safeScale = Number.isFinite(scale) ? Math.max(0.1, scale) : 1;
                toolbar.style.setProperty('--toolbar-scale', safeScale.toString());
            }

            function snapToolbar() {
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const rect = toolbar.getBoundingClientRect();
                const wasHorizontal = toolbar.classList.contains('horizontal');

                const margin = 15;
                const snapThreshold = 80;

                // Calculate distances to edges (within editing zone)
                const distLeft = rect.left;
                const distRight = viewportWidth - rect.right;
                const distBottom = viewportHeight - rect.bottom;

                // Find the closest edge
                const minDist = Math.min(distLeft, distRight, distBottom);

                toolbar.classList.add('snapping');
                toolbar.style.setProperty('--toolbar-translate', '0px');

                if (minDist === distBottom && distBottom < snapThreshold) {
                    // Snap to bottom (horizontal)
                    toolbar.classList.add('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    const desiredLeft = (viewportWidth - toolbarSize.width) / 2;
                    const clampedLeft = Math.max(limits.minLeft, Math.min(desiredLeft, limits.maxLeft));
                    const desiredTop = viewportHeight - toolbarSize.height - margin;
                    const clampedTop = Math.max(limits.minTop, Math.min(desiredTop, limits.maxTop));
                    toolbar.style.left = clampedLeft + 'px';
                    toolbar.style.top = clampedTop + 'px';
                    toolbar.style.right = 'auto';
                    toolbar.style.bottom = 'auto';
                } else if (minDist === distLeft && distLeft < snapThreshold) {
                    // Snap to left (vertical)
                    toolbar.classList.remove('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    toolbar.style.left = limits.minLeft + 'px';
                    toolbar.style.top = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop)) + 'px';
                    toolbar.style.bottom = 'auto';
                    toolbar.style.right = 'auto';
                } else if (minDist === distRight && distRight < snapThreshold) {
                    // Snap to right (vertical)
                    toolbar.classList.remove('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    toolbar.style.left = 'auto';
                    toolbar.style.right = limits.minLeft + 'px';
                    toolbar.style.top = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop)) + 'px';
                    toolbar.style.bottom = 'auto';
                } else {
                    // No snap, just constrain to editing area
                    toolbar.classList.remove('horizontal');
                    updateToolbarScale(margin);
                    const toolbarSize = getToolbarSize();
                    const limits = getToolbarLimits(toolbarSize, margin);
                    toolbar.style.left = Math.max(limits.minLeft, Math.min(rect.left, limits.maxLeft)) + 'px';
                    toolbar.style.top = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop)) + 'px';
                    toolbar.style.bottom = 'auto';
                    toolbar.style.right = 'auto';
                }

                const isHorizontal = toolbar.classList.contains('horizontal');
                if (wasHorizontal !== isHorizontal) {
                    toolbar.classList.remove('toolbar-tilt-forward', 'toolbar-tilt-back');
                    void toolbar.offsetWidth;
                    const tiltClass = isHorizontal ? 'toolbar-tilt-back' : 'toolbar-tilt-forward';
                    toolbar.classList.add(tiltClass);
                    setTimeout(() => {
                        toolbar.classList.remove(tiltClass);
                    }, 360);
                }

                if (snapTimeout) {
                    clearTimeout(snapTimeout);
                }
                snapTimeout = setTimeout(() => {
                    toolbar.classList.remove('snapping');
                    snapTimeout = null;
                }, 200);
            }

            function onPointerDown(e) {
                if (e.target !== toolbarHandle && !toolbarHandle.contains(e.target)) return;

                if (snapTimeout) {
                    clearTimeout(snapTimeout);
                    snapTimeout = null;
                }
                toolbar.classList.remove('snapping');
                toolbar.style.transition = 'none';

                isDragging = true;
                updateToolbarScale(10);
                const rect = toolbar.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;

                // Reset any transform after reading current position to avoid jumps
                toolbar.style.setProperty('--toolbar-translate', '0px');

                // Set explicit positioning
                toolbar.style.bottom = 'auto';
                toolbar.style.left = rect.left + 'px';
                toolbar.style.top = rect.top + 'px';
                toolbar.style.right = 'auto';

                toolbarHandle.style.cursor = 'grabbing';
                if (toolbarHandle.setPointerCapture) {
                    toolbarHandle.setPointerCapture(e.pointerId);
                }
                e.preventDefault();
            }

            function onPointerMove(e) {
                if (!isDragging) return;

                const margin = 10;
                const toolbarSize = getToolbarSize();
                const limits = getToolbarLimits(toolbarSize, margin);

                const rawLeft = e.clientX - dragOffsetX;
                const rawTop = e.clientY - dragOffsetY;

                // Constrain to editing area (below header)
                const newLeft = Math.max(limits.minLeft, Math.min(rawLeft, limits.maxLeft));
                const newTop = Math.max(limits.minTop, Math.min(rawTop, limits.maxTop));

                toolbar.style.left = newLeft + 'px';
                toolbar.style.top = newTop + 'px';
                toolbar.style.right = 'auto';
                toolbar.style.bottom = 'auto';
            }

            function onPointerUp(e) {
                if (!isDragging) return;
                isDragging = false;
                toolbarHandle.style.cursor = 'grab';
                if (toolbarHandle.releasePointerCapture) {
                    toolbarHandle.releasePointerCapture(e.pointerId);
                }
                toolbar.style.transition = '';
                snapToolbar();
            }

            toolbarHandle.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);

            // Handle window resize
            window.addEventListener('resize', () => {
                const margin = 10;
                updateToolbarScale(margin);
                const rect = toolbar.getBoundingClientRect();
                const toolbarSize = getToolbarSize();
                const limits = getToolbarLimits(toolbarSize, margin);
                const nextLeft = Math.max(limits.minLeft, Math.min(rect.left, limits.maxLeft));
                const nextTop = Math.max(limits.minTop, Math.min(rect.top, limits.maxTop));
                toolbar.style.left = nextLeft + 'px';
                toolbar.style.top = nextTop + 'px';
                toolbar.style.right = 'auto';
                toolbar.style.bottom = 'auto';
                toolbar.style.setProperty('--toolbar-translate', '0px');
            });

            // Normalize initial position to avoid transform jumps on first drag
            requestAnimationFrame(() => {
                updateToolbarScale(10);
                const rect = toolbar.getBoundingClientRect();
                toolbar.style.left = rect.left + 'px';
                toolbar.style.top = rect.top + 'px';
                toolbar.style.right = 'auto';
                toolbar.style.bottom = 'auto';
                toolbar.style.setProperty('--toolbar-translate', '0px');
            });
        }

        // Wheel handler for PC - scroll and zoom
        function handleWheel(e) {
            e.preventDefault();
            
            if (e.ctrlKey || e.metaKey) {
                // Zoom with Ctrl+wheel or pinch on trackpad
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.min(Math.max(0.5, state.zoom * zoomFactor), 3);
                
                // Zoom centered on mouse position
                const rect = canvasViewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate point in content coordinates
                const contentX = (mouseX - state.panX) / state.zoom;
                const contentY = (mouseY - state.panY) / state.zoom;
                
                // Update zoom
                state.zoom = newZoom;
                
                // Adjust pan to keep the point under the mouse
                state.panX = mouseX - contentX * state.zoom;
                state.panY = mouseY - contentY * state.zoom;
                
                updateTransform();
            } else {
                // Scroll with wheel
                state.panX -= e.deltaX;
                applyVerticalPan(-e.deltaY);
                updateTransform();
            }
            if (wheelReleaseTimeout) {
                clearTimeout(wheelReleaseTimeout);
            }
            wheelReleaseTimeout = setTimeout(() => {
                state.pageCreateLocked = false;
            }, 300);
        }

        // Viewport pointer handlers for pan/zoom
        function handleViewportPointerDown(e) {
            // Pen is handled by canvas
            if (e.pointerType === 'pen') {
                if (handlePenBackgroundDoubleTap(e)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                return;
            }
            stopInertia();
            if (state.currentTool === 'lasso' && state.selection.pageIndex !== null) {
                const selectionBox = document.querySelector(`.selection-box[data-page="${state.selection.pageIndex}"]`);
                if (selectionBox && !selectionBox.classList.contains('hidden')) {
                    if (!selectionBox.contains(e.target)) {
                        clearSelection();
                    }
                }
            }
            
            // For mouse, only start pan on middle button or when not on canvas
            if (e.pointerType === 'mouse') {
                // Left click drag to pan
                state.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
                state.isPanning = true;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                canvasViewport.style.cursor = 'grabbing';
                return;
            }
            
            // Touch handling
            state.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

            if (state.activePointers.size === 2) {
                // Store pinch center for zoom
                const points = Array.from(state.activePointers.values());
                state.pinchCenterX = (points[0].clientX + points[1].clientX) / 2;
                state.pinchCenterY = (points[0].clientY + points[1].clientY) / 2;
                state.initialPinchDist = getPointerDistance();
                state.initialScale = state.zoom;
                state.initialPanX = state.panX;
                state.initialPanY = state.panY;
                state.scrollLocked = false;
                state.panVelocityX = 0;
                state.panVelocityY = 0;
                state.lastPanTime = 0;
            } else if (state.activePointers.size === 1) {
                state.isPanning = true;
                state.scrollLocked = false;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                state.panStartX = e.clientX;
                state.panStartY = e.clientY;
                state.panVelocityX = 0;
                state.panVelocityY = 0;
                state.lastPanTime = performance.now();
            }
        }

        function handleViewportPointerMove(e) {
            // Pen is handled by canvas
            if (e.pointerType === 'pen') return;
            if (!state.activePointers.has(e.pointerId)) return;
            
            state.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

            // Mouse drag
            if (e.pointerType === 'mouse' && state.isPanning) {
                const dx = e.clientX - state.lastPanX;
                const dy = e.clientY - state.lastPanY;
                state.panX += dx;
                applyVerticalPan(dy);
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                updateTransform();
                return;
            }

            // Touch pinch zoom
            if (state.activePointers.size === 2) {
                const currentDist = getPointerDistance();
                if (state.initialPinchDist > 0) {
                    const scaleFactor = currentDist / state.initialPinchDist;
                    const newZoom = Math.min(Math.max(0.5, state.initialScale * scaleFactor), 3);
                    
                    // Get current pinch center
                    const points = Array.from(state.activePointers.values());
                    const currentCenterX = (points[0].clientX + points[1].clientX) / 2;
                    const currentCenterY = (points[0].clientY + points[1].clientY) / 2;
                    
                    // Calculate the point in content space at the original pinch center
                    const rect = canvasViewport.getBoundingClientRect();
                    const contentX = (state.pinchCenterX - rect.left - state.initialPanX) / state.initialScale;
                    const contentY = (state.pinchCenterY - rect.top - state.initialPanY) / state.initialScale;
                    
                    // Update zoom
                    state.zoom = newZoom;
                    
                    // Adjust pan to keep the content point under the current pinch center
                    state.panX = currentCenterX - rect.left - contentX * state.zoom;
                    state.panY = currentCenterY - rect.top - contentY * state.zoom;
                    
                    updateTransform();
                }
            } else if (state.activePointers.size === 1 && state.isPanning) {
                // Single finger pan
                const dx = e.clientX - state.lastPanX;
                const dy = e.clientY - state.lastPanY;
                
                // Check if we should lock to vertical scroll
                if (!state.scrollLocked) {
                    const totalDx = Math.abs(e.clientX - state.panStartX);
                    const totalDy = Math.abs(e.clientY - state.panStartY);
                    
                    if (totalDx > 10 || totalDy > 10) {
                        if (totalDy > totalDx * 2) {
                            state.scrollLocked = 'vertical';
                        } else if (totalDx > totalDy * 2) {
                            state.scrollLocked = 'horizontal';
                        } else {
                            state.scrollLocked = 'free';
                        }
                    }
                }

                // Apply movement based on lock
                if (state.scrollLocked === 'vertical') {
                    applyVerticalPan(dy);
                } else if (state.scrollLocked === 'horizontal') {
                    state.panX += dx;
                } else {
                    state.panX += dx;
                    applyVerticalPan(dy);
                }

                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                const now = performance.now();
                const dt = Math.max(1, now - (state.lastPanTime || now));
                const vx = dx / dt;
                const vy = dy / dt;
                state.panVelocityX = state.panVelocityX * 0.8 + vx * 0.2;
                state.panVelocityY = state.panVelocityY * 0.8 + vy * 0.2;
                state.lastPanTime = now;
                updateTransform();
            }
        }

        function handleViewportPointerUp(e) {
            if (e.pointerType === 'pen') return;
            state.activePointers.delete(e.pointerId);
            const finalizePageCreation = () => {
                if (state.isReadOnly) {
                    state.pendingPageCreate = false;
                    state.pageCreateLocked = false;
                    state.overscrollY = 0;
                    updateAddPageIndicator();
                    return;
                }
                const viewportHeight = canvasViewport.getBoundingClientRect().height;
                const bottomInView = state.panY + getContentHeight() * state.zoom;
                const canCreate = bottomInView < viewportHeight * CREATE_PAGE_MIN_BOTTOM_RATIO;
                if (state.pendingPageCreate && state.overscrollY >= OVERSCROLL_THRESHOLD && canCreate) {
                    const prevLimit = getBottomLimit();
                    addPage(null, true);
                    state.overscrollY = 0;
                    updateAddPageIndicator();
                    animatePanTo(prevLimit.minPanY);
                }
                state.pendingPageCreate = false;
            };

            if (e.pointerType === 'mouse') {
                state.isPanning = false;
                canvasViewport.style.cursor = '';
                finalizePageCreation();
                state.pageCreateLocked = false;
                stopInertia();
                if (state.overscrollY > 0) {
                    const reset = getBottomLimit();
                    state.overscrollY = 0;
                    state.panY = Math.max(state.panY, reset.minPanY);
                    updateTransform();
                }
                scheduleVisiblePageUpdate(true);
                return;
            }

            if (state.activePointers.size < 2) {
                state.initialPinchDist = 0;
            }
            if (state.activePointers.size === 1) {
                const remaining = Array.from(state.activePointers.values())[0];
                if (remaining) {
                    state.isPanning = true;
                    state.scrollLocked = false;
                    state.lastPanX = remaining.clientX;
                    state.lastPanY = remaining.clientY;
                    state.panStartX = remaining.clientX;
                    state.panStartY = remaining.clientY;
                }
            }
            if (state.activePointers.size === 0) {
                state.isPanning = false;
                const finalLock = state.scrollLocked || 'free';
                state.scrollLocked = false;
                finalizePageCreation();
                state.pageCreateLocked = false;
                if (state.overscrollY === 0) {
                    const speed = Math.hypot(state.panVelocityX, state.panVelocityY);
                    if (speed > TOUCH_INERTIA_STOP) {
                        state.inertiaLock = finalLock;
                        startInertia();
                    } else {
                        scheduleVisiblePageUpdate(true);
                    }
                } else {
                    scheduleVisiblePageUpdate(true);
                }
            }
            if (state.overscrollY > 0) {
                const reset = getBottomLimit();
                state.overscrollY = 0;
                state.panY = Math.max(state.panY, reset.minPanY);
                updateTransform();
                scheduleVisiblePageUpdate(true);
            }
        }

        function getPointerDistance() {
            const points = Array.from(state.activePointers.values());
            if (points.length < 2) return 0;
            const dx = points[0].clientX - points[1].clientX;
            const dy = points[0].clientY - points[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function preserveViewOnResize() {
            const rect = canvasViewport.getBoundingClientRect();
            if (!rect.width || !rect.height) return;
            const anchorX = (rect.width / 2 - state.panX) / state.zoom;
            const anchorY = (rect.height / 2 - state.panY) / state.zoom;
            requestAnimationFrame(() => {
                const nextRect = canvasViewport.getBoundingClientRect();
                state.panX = nextRect.width / 2 - anchorX * state.zoom;
                state.panY = nextRect.height / 2 - anchorY * state.zoom;
                state.overscrollY = 0;
                state.pendingPageCreate = false;
                state.pageCreateLocked = false;
                updateAddPageIndicator();
                updateTransform();
            });
        }

        function updateTransform() {
            clampPanToVisible();
            canvasContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            scheduleViewSave();
            scheduleVisiblePageUpdate();
        }

        function setZoom(newZoom) {
            state.zoom = Math.max(0.5, Math.min(3, newZoom));
            updateTransform();
        }

        // Pages Panel
        function openPagesPanel() {
            if (state.isReadOnly) return;
            renderPagesList();
            document.getElementById('pages-panel').classList.add('visible');
            document.getElementById('panel-overlay').classList.add('visible');
        }

        function closePagesPanel() {
            document.getElementById('pages-panel').classList.remove('visible');
            document.getElementById('panel-overlay').classList.remove('visible');
        }

        function renderPagesList() {
            const pagesList = document.getElementById('pages-list');
            pagesList.innerHTML = '';

            state.pages.forEach((page, index) => {
                const item = document.createElement('div');
                item.className = 'page-item';
                const strokeCount = getVisibleStrokeCount(page);
                const isPdfBackground = page.backgroundSource === 'pdf' || Number.isFinite(page.pdfPageIndex);
                item.innerHTML = `
                    <div class="page-thumbnail">
                        <canvas id="thumb-${index}" width="50" height="70"></canvas>
                    </div>
                    <div class="page-info">
                        <h3>Page ${index + 1}</h3>
                        <p>${strokeCount} stroke${strokeCount !== 1 ? 's' : ''}${isPdfBackground ? ' - PDF' : ''}</p>
                    </div>
                    <div class="page-actions">
                        <button class="page-action-btn" data-action="goto" data-page="${index}" title="Go to page">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                            </svg>
                        </button>
                        <button class="page-action-btn delete" data-action="delete" data-page="${index}" title="Delete" ${state.pages.length === 1 ? 'disabled style="opacity:0.3;pointer-events:none;"' : ''}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                `;
                pagesList.appendChild(item);

                generateThumbnail(index);

                item.querySelector('[data-action="goto"]').addEventListener('click', () => {
                    goToPage(index);
                    closePagesPanel();
                });

                const deleteBtn = item.querySelector('[data-action="delete"]');
                if (state.pages.length > 1) {
                    deleteBtn.addEventListener('click', () => openDeleteModal(index));
                }
            });
        }

        function generateThumbnail(pageIndex) {
            const thumbCanvas = document.getElementById(`thumb-${pageIndex}`);
            if (!thumbCanvas) return;

            const ctx = thumbCanvas.getContext('2d');
            const page = state.pages[pageIndex];
            if (!page) return;

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 50, 70);

            if (page.unloaded && page.preview) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 50, 70);
                };
                img.src = page.preview;
                return;
            }

            // Draw background image if exists
            if (page.backgroundImage) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 50, 70);
                    drawThumbnailStrokes(ctx, page, pageIndex);
                };
                img.src = page.backgroundImage;
            } else if (page.pdfPageIndex) {
                ctx.fillStyle = '#f2f2f2';
                ctx.fillRect(2, 2, 46, 66);
                ctx.strokeStyle = '#d0d0d0';
                ctx.strokeRect(2, 2, 46, 66);
                ctx.fillStyle = '#9a9a9a';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('PDF', 25, 38);
                drawThumbnailStrokes(ctx, page, pageIndex);
            } else {
                ctx.strokeStyle = '#ffde00';
                ctx.lineWidth = 1;
                ctx.strokeRect(2, 2, 46, 66);
                drawThumbnailStrokes(ctx, page, pageIndex);
            }
        }

        function drawThumbnailStrokes(ctx, page, pageIndex) {
            const scaleX = 50 / A4_WIDTH;
            const scaleY = 70 / A4_HEIGHT;

            ctx.save();
            ctx.scale(scaleX, scaleY);
            drawImagesOnContext(ctx, page, pageIndex, generateThumbnail);

            if (!Array.isArray(page.strokes)) {
                ctx.restore();
                return;
            }
            for (const stroke of page.strokes) {
                const minPoints = stroke.tool === 'highlighter' ? 1 : 2;
                if (!stroke.points || stroke.points.length < minPoints) continue;
                if (stroke.tool === 'eraser-stroke') continue;
                drawSmoothStroke(ctx, stroke);
            }

            ctx.restore();
        }

        function getVisibleStrokeCount(page) {
            if (!page) return 0;
            if (!Array.isArray(page.strokes)) {
                return typeof page.strokeCount === 'number' ? page.strokeCount : 0;
            }
            return page.strokes.filter(stroke => !(stroke.tool && stroke.tool.startsWith('eraser'))).length;
        }

        function goToPage(pageIndex) {
            const pageWrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (pageWrapper) {
                const rect = pageWrapper.getBoundingClientRect();
                const viewportRect = canvasViewport.getBoundingClientRect();
                state.panY = -(pageIndex * (A4_HEIGHT + PAGE_GAP) * state.zoom) + viewportRect.height / 2 - (A4_HEIGHT * state.zoom) / 2;
                state.panX = viewportRect.width / 2 - (A4_WIDTH * state.zoom) / 2 - PAGE_PADDING;
                updateTransform();
                state.activePageIndex = pageIndex;
                scheduleVisiblePageUpdate(true);
            }
        }

        // Delete page
        let pageToDelete = null;

        function openDeleteModal(pageIndex) {
            if (state.isReadOnly) return;
            pageToDelete = pageIndex;
            document.getElementById('delete-page-number').textContent = pageIndex + 1;
            document.getElementById('modal-delete-page').classList.add('visible');
        }

        function closeDeleteModal() {
            pageToDelete = null;
            document.getElementById('modal-delete-page').classList.remove('visible');
        }

        async function confirmDeletePage() {
            if (state.isReadOnly) {
                closeDeleteModal();
                return;
            }
            if (pageToDelete === null || state.pages.length <= 1) {
                closeDeleteModal();
                return;
            }
            const removedPage = state.pages[pageToDelete];
            if (removedPage?.backgroundSource === 'pdf' && removedPage.backgroundImage && removedPage.backgroundImage.startsWith('blob:')) {
                URL.revokeObjectURL(removedPage.backgroundImage);
            }
            await flushDirtyPages();
            state.pages.splice(pageToDelete, 1);
            reindexLocalCachesAfterDelete(pageToDelete);
            await reindexPagesAfterDelete(pageToDelete, state.pages.length);
            renderAllPages();
            const lastIndex = state.pages.length - 1;
            if (lastIndex >= 0) {
                goToPage(lastIndex);
            }
            scheduleSave(true);
            renderPagesList();
            closeDeleteModal();
            showStatus('Page deleted', { preserveState: true });
        }

        // Reset document
        function openResetModal() {
            if (state.isReadOnly) return;
            resetResetSlider();
            document.getElementById('modal-reset-document').classList.add('visible');
        }

        function closeResetModal() {
            document.getElementById('modal-reset-document').classList.remove('visible');
            resetResetSlider();
        }

        async function confirmResetDocument() {
            if (state.isReadOnly) return;
            closeResetModal();
            clearSelection();
            state.selectionTransform = null;
            resetPdfState();
            await clearPageStore();
            pageDirty.clear();
            pageAccess.clear();
            pageLoadQueue.clear();
            legacyPagesCache = null;
            imageCache.clear();
            imageCacheUsage.clear();
            state.pages = [{
                strokes: [],
                backgroundImage: null,
                backgroundSource: 'template',
                pdfPageIndex: null,
                images: [],
                needsRedraw: true,
                preview: null,
                strokeCount: 0,
                unloaded: false
            }];
            state.history = [];
            state.historyIndex = -1;
            updateHistoryButtons();
            renderAllPages();
            scheduleSave(true, 0);
            renderPagesList();
            centerViewOnTop();
            showStatus('New document', { preserveState: true });
        }

        const resetSliderState = {
            slider: null,
            handle: null,
            fill: null,
            isDragging: false,
            maxX: 0,
            handleWidth: 44,
            padding: 4,
            currentX: 0
        };

        const trashSliderState = {
            slider: null,
            handle: null,
            fill: null,
            isDragging: false,
            maxX: 0,
            handleWidth: 44,
            padding: 4,
            currentX: 0
        };

        function setupResetSlider() {
            const slider = document.getElementById('reset-slider');
            const handle = document.getElementById('reset-slider-handle');
            const fill = document.getElementById('reset-slider-fill');
            if (!slider || !handle || !fill) return;

            resetSliderState.slider = slider;
            resetSliderState.handle = handle;
            resetSliderState.fill = fill;

            slider.addEventListener('pointerdown', (e) => {
                if (e.button !== undefined && e.button !== 0) return;
                startResetSliderDrag(e);
            });
            slider.addEventListener('pointermove', onResetSliderDrag);
            slider.addEventListener('pointerup', endResetSliderDrag);
            slider.addEventListener('pointercancel', endResetSliderDrag);
            slider.addEventListener('lostpointercapture', endResetSliderDrag);
        }

        function setupTrashSlider() {
            const slider = document.getElementById('trash-slider');
            const handle = document.getElementById('trash-slider-handle');
            const fill = document.getElementById('trash-slider-fill');
            if (!slider || !handle || !fill) return;

            trashSliderState.slider = slider;
            trashSliderState.handle = handle;
            trashSliderState.fill = fill;

            slider.addEventListener('pointerdown', (e) => {
                if (e.button !== undefined && e.button !== 0) return;
                startTrashSliderDrag(e);
            });
            slider.addEventListener('pointermove', onTrashSliderDrag);
            slider.addEventListener('pointerup', endTrashSliderDrag);
            slider.addEventListener('pointercancel', endTrashSliderDrag);
            slider.addEventListener('lostpointercapture', endTrashSliderDrag);
        }

        function updateResetSliderMetrics() {
            const slider = resetSliderState.slider;
            const handle = resetSliderState.handle;
            if (!slider || !handle) return;
            const rect = slider.getBoundingClientRect();
            const handleRect = handle.getBoundingClientRect();
            resetSliderState.handleWidth = handleRect.width || 44;
            resetSliderState.maxX = Math.max(0, rect.width - resetSliderState.handleWidth - resetSliderState.padding * 2);
        }

        function updateTrashSliderMetrics() {
            const slider = trashSliderState.slider;
            const handle = trashSliderState.handle;
            if (!slider || !handle) return;
            const rect = slider.getBoundingClientRect();
            const handleRect = handle.getBoundingClientRect();
            trashSliderState.handleWidth = handleRect.width || 44;
            trashSliderState.maxX = Math.max(0, rect.width - trashSliderState.handleWidth - trashSliderState.padding * 2);
        }

        function setResetSliderPosition(x, animate = true) {
            const slider = resetSliderState.slider;
            const handle = resetSliderState.handle;
            const fill = resetSliderState.fill;
            if (!slider || !handle || !fill) return;
            updateResetSliderMetrics();
            const clamped = Math.max(0, Math.min(x, resetSliderState.maxX));
            resetSliderState.currentX = clamped;
            slider.classList.toggle('dragging', !animate);
            handle.style.transform = `translateX(${clamped}px)`;
            const fillWidth = clamped + resetSliderState.handleWidth / 2 + resetSliderState.padding;
            fill.style.width = `${fillWidth}px`;
        }

        function setTrashSliderPosition(x, animate = true) {
            const slider = trashSliderState.slider;
            const handle = trashSliderState.handle;
            const fill = trashSliderState.fill;
            if (!slider || !handle || !fill) return;
            updateTrashSliderMetrics();
            const clamped = Math.max(0, Math.min(x, trashSliderState.maxX));
            trashSliderState.currentX = clamped;
            slider.classList.toggle('dragging', !animate);
            handle.style.transform = `translateX(${clamped}px)`;
            const fillWidth = clamped + trashSliderState.handleWidth / 2 + trashSliderState.padding;
            fill.style.width = `${fillWidth}px`;
        }

        function resetResetSlider() {
            const slider = resetSliderState.slider;
            if (slider) {
                slider.classList.remove('complete');
            }
            setResetSliderPosition(0, true);
        }

        function resetTrashSlider() {
            const slider = trashSliderState.slider;
            if (slider) {
                slider.classList.remove('complete');
            }
            setTrashSliderPosition(0, true);
        }

        function startResetSliderDrag(e) {
            const slider = resetSliderState.slider;
            const handle = resetSliderState.handle;
            if (!slider || !handle) return;
            resetSliderState.isDragging = true;
            slider.classList.remove('complete');
            slider.classList.add('dragging');
            slider.setPointerCapture(e.pointerId);
            updateResetSliderMetrics();
            const sliderRect = slider.getBoundingClientRect();
            const handleRect = handle.getBoundingClientRect();
            const pointerOffset = e.clientX - handleRect.left;
            resetSliderState.dragOffset = Math.min(Math.max(pointerOffset, 0), handleRect.width);
            const initialX = e.clientX - sliderRect.left - resetSliderState.padding - resetSliderState.dragOffset;
            setResetSliderPosition(initialX, false);
        }

        function startTrashSliderDrag(e) {
            const slider = trashSliderState.slider;
            const handle = trashSliderState.handle;
            if (!slider || !handle) return;
            trashSliderState.isDragging = true;
            slider.classList.remove('complete');
            slider.classList.add('dragging');
            slider.setPointerCapture(e.pointerId);
            updateTrashSliderMetrics();
            const sliderRect = slider.getBoundingClientRect();
            const handleRect = handle.getBoundingClientRect();
            const pointerOffset = e.clientX - handleRect.left;
            trashSliderState.dragOffset = Math.min(Math.max(pointerOffset, 0), handleRect.width);
            const initialX = e.clientX - sliderRect.left - trashSliderState.padding - trashSliderState.dragOffset;
            setTrashSliderPosition(initialX, false);
        }

        function onResetSliderDrag(e) {
            if (!resetSliderState.isDragging) return;
            const slider = resetSliderState.slider;
            if (!slider) return;
            const sliderRect = slider.getBoundingClientRect();
            const nextX = e.clientX - sliderRect.left - resetSliderState.padding - resetSliderState.dragOffset;
            setResetSliderPosition(nextX, false);
        }

        function onTrashSliderDrag(e) {
            if (!trashSliderState.isDragging) return;
            const slider = trashSliderState.slider;
            if (!slider) return;
            const sliderRect = slider.getBoundingClientRect();
            const nextX = e.clientX - sliderRect.left - trashSliderState.padding - trashSliderState.dragOffset;
            setTrashSliderPosition(nextX, false);
        }

        function endResetSliderDrag() {
            if (!resetSliderState.isDragging) return;
            resetSliderState.isDragging = false;
            const slider = resetSliderState.slider;
            if (!slider) return;
            slider.classList.remove('dragging');
            const threshold = resetSliderState.maxX * 0.9;
            if (resetSliderState.currentX >= threshold) {
                slider.classList.add('complete');
                setResetSliderPosition(resetSliderState.maxX, true);
                setTimeout(() => {
                    confirmResetDocument();
                }, 120);
            } else {
                resetResetSlider();
            }
        }

        function endTrashSliderDrag() {
            if (!trashSliderState.isDragging) return;
            trashSliderState.isDragging = false;
            const slider = trashSliderState.slider;
            if (!slider) return;
            slider.classList.remove('dragging');
            const threshold = trashSliderState.maxX * 0.9;
            if (trashSliderState.currentX >= threshold) {
                slider.classList.add('complete');
                setTrashSliderPosition(trashSliderState.maxX, true);
                setTimeout(() => {
                    confirmTrashFile();
                }, 120);
            } else {
                resetTrashSlider();
            }
        }

        function saveViewState() {
            try {
                const data = JSON.stringify({
                    panX: state.panX,
                    panY: state.panY,
                    zoom: state.zoom
                });
                localStorage.setItem(VIEW_STORAGE_KEY, data);
            } catch (e) {
                console.error('Failed to save view state:', e);
            }
        }

        function scheduleViewSave() {
            clearTimeout(viewSaveTimeout);
            viewSaveTimeout = setTimeout(() => {
                saveViewState();
            }, VIEW_SAVE_DELAY);
        }

        function loadViewState() {
            try {
                const data = localStorage.getItem(VIEW_STORAGE_KEY);
                if (!data) return null;
                const parsed = JSON.parse(data);
                if (!parsed) return null;
                const hasNumbers = ['panX', 'panY', 'zoom'].every(key => typeof parsed[key] === 'number');
                if (!hasNumbers) return null;
                return parsed;
            } catch (e) {
                console.error('Failed to load view state:', e);
                return null;
            }
        }

        function saveViewMode(mode) {
            try {
                localStorage.setItem(VIEW_MODE_KEY, mode);
            } catch (e) {
                console.error('Failed to save view mode:', e);
            }
        }

        function loadViewMode() {
            try {
                return localStorage.getItem(VIEW_MODE_KEY);
            } catch (e) {
                console.error('Failed to load view mode:', e);
                return null;
            }
        }

        function saveDriveTokenToStorage(token, expiry) {
            try {
                const payload = JSON.stringify({ token, expiry });
                localStorage.setItem(DRIVE_TOKEN_KEY, payload);
                localStorage.setItem(DRIVE_REMEMBER_KEY, '1');
            } catch (e) {
                console.error('Failed to save Drive token:', e);
            }
        }

        function clearDriveTokenStorage() {
            try {
                localStorage.removeItem(DRIVE_TOKEN_KEY);
            } catch (e) {
                console.error('Failed to clear Drive token:', e);
            }
        }

        function loadDriveTokenFromStorage() {
            try {
                const raw = localStorage.getItem(DRIVE_TOKEN_KEY);
                if (!raw) return false;
                const parsed = JSON.parse(raw);
                if (!parsed || !parsed.token || !parsed.expiry) return false;
                if (Date.now() >= parsed.expiry - 60000) {
                    clearDriveTokenStorage();
                    return false;
                }
                driveAccessToken = parsed.token;
                driveTokenExpiry = parsed.expiry;
                return true;
            } catch (e) {
                console.error('Failed to load Drive token:', e);
                return false;
            }
        }

        function saveDriveSession() {
            try {
                const payload = {
                    fileId: state.driveFileId,
                    fileName: state.driveFileName,
                    exportName: state.exportName,
                    autosave: state.driveAutosave
                };
                localStorage.setItem(DRIVE_SESSION_KEY, JSON.stringify(payload));
            } catch (e) {
                console.error('Failed to save Drive session:', e);
            }
        }

        function clearDriveSession() {
            try {
                localStorage.removeItem(DRIVE_SESSION_KEY);
            } catch (e) {
                console.error('Failed to clear Drive session:', e);
            }
        }

        function loadDriveSession() {
            try {
                const raw = localStorage.getItem(DRIVE_SESSION_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!parsed) return;
                state.driveFileId = parsed.fileId || null;
                state.driveFileName = parsed.fileName || null;
                if (parsed.exportName) {
                    state.exportName = parsed.exportName;
                }
                state.driveAutosave = !!parsed.autosave || !!parsed.fileId;
            } catch (e) {
                console.error('Failed to load Drive session:', e);
            }
        }

        function applyViewState(viewState) {
            if (!viewState) return false;
            state.zoom = Math.max(0.5, Math.min(3, viewState.zoom));
            state.panX = viewState.panX;
            state.panY = viewState.panY;
            state.overscrollY = 0;
            state.pendingPageCreate = false;
            state.pageCreateLocked = false;
            updateAddPageIndicator();
            updateTransform();
            return true;
        }

        function formatTime(timestamp) {
            if (!timestamp) return '--:--';
            const now = Date.now();
            const diffMs = Math.max(0, now - timestamp);
            const diffMin = Math.floor(diffMs / 60000);
            if (diffMin < 15) {
                if (diffMin < 1) return '<1 min ago';
                return diffMin === 1 ? '1 min ago' : `${diffMin} mins ago`;
            }
            return new Date(timestamp).toLocaleTimeString(undefined, {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function updateSaveTimestamp() {
            const timestampEl = document.getElementById('save-timestamp');
            if (!timestampEl) return;
            const label = state.lastSavedAt ? `Last edit: ${formatTime(state.lastSavedAt)}` : 'Last edit: --:--';
            timestampEl.textContent = label;
        }

        function openNotebookDb() {
            if (!('indexedDB' in window)) return Promise.resolve(null);
            return new Promise((resolve) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = () => {
                    const db = request.result;
                    if (!db.objectStoreNames.contains(DB_STORE)) {
                        db.createObjectStore(DB_STORE, { keyPath: 'key' });
                    }
                    if (!db.objectStoreNames.contains(PAGE_STORE)) {
                        db.createObjectStore(PAGE_STORE);
                    }
                };
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => {
                    console.error('Failed to open IndexedDB:', request.error);
                    resolve(null);
                };
            });
        }

        async function saveToIndexedDb(data, savedAt) {
            const db = await openNotebookDb();
            if (!db) return false;
            return new Promise((resolve) => {
                const tx = db.transaction(DB_STORE, 'readwrite');
                tx.oncomplete = () => {
                    db.close();
                    resolve(true);
                };
                tx.onerror = () => {
                    console.error('Failed to save to IndexedDB:', tx.error);
                    db.close();
                    resolve(false);
                };
                const store = tx.objectStore(DB_STORE);
                store.put({
                    key: DB_KEY,
                    data,
                    savedAt,
                    version: 2
                });
            });
        }

        async function loadFromIndexedDb() {
            const db = await openNotebookDb();
            if (!db) return null;
            return new Promise((resolve) => {
                const tx = db.transaction(DB_STORE, 'readonly');
                tx.oncomplete = () => db.close();
                tx.onerror = () => db.close();
                const store = tx.objectStore(DB_STORE);
                const request = store.get(DB_KEY);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = () => resolve(null);
            });
        }

        function sanitizePageForStorage(page) {
            return {
                strokes: Array.isArray(page.strokes) ? page.strokes : [],
                images: Array.isArray(page.images) ? page.images : [],
                backgroundImage: page.backgroundSource === 'pdf' ? null : (page.backgroundImage || null),
                backgroundSource: page.backgroundSource || (page.pdfPageIndex ? 'pdf' : (page.backgroundImage ? 'custom' : 'template')),
                pdfPageIndex: Number.isFinite(page.pdfPageIndex) ? page.pdfPageIndex : null
            };
        }

        function buildPageMeta(page) {
            const strokeCount = Array.isArray(page.strokes)
                ? getVisibleStrokeCount(page)
                : (typeof page.strokeCount === 'number' ? page.strokeCount : 0);
            return {
                backgroundImage: page.backgroundSource === 'pdf' ? null : (page.backgroundImage || null),
                backgroundSource: page.backgroundSource || (page.pdfPageIndex ? 'pdf' : (page.backgroundImage ? 'custom' : 'template')),
                pdfPageIndex: Number.isFinite(page.pdfPageIndex) ? page.pdfPageIndex : null,
                preview: page.preview || null,
                strokeCount
            };
        }

        async function savePageToIndexedDb(pageIndex, page) {
            const db = await openNotebookDb();
            if (!db) return false;
            return new Promise((resolve) => {
                const tx = db.transaction(PAGE_STORE, 'readwrite');
                tx.oncomplete = () => {
                    db.close();
                    resolve(true);
                };
                tx.onerror = () => {
                    console.error('Failed to save page to IndexedDB:', tx.error);
                    db.close();
                    resolve(false);
                };
                const store = tx.objectStore(PAGE_STORE);
                store.put(sanitizePageForStorage(page), pageIndex);
            });
        }

        async function loadPageFromIndexedDb(pageIndex) {
            const db = await openNotebookDb();
            if (!db) return null;
            return new Promise((resolve) => {
                const tx = db.transaction(PAGE_STORE, 'readonly');
                tx.oncomplete = () => db.close();
                tx.onerror = () => db.close();
                const store = tx.objectStore(PAGE_STORE);
                const request = store.get(pageIndex);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = () => resolve(null);
            });
        }

        async function deletePageFromIndexedDb(pageIndex) {
            const db = await openNotebookDb();
            if (!db) return false;
            return new Promise((resolve) => {
                const tx = db.transaction(PAGE_STORE, 'readwrite');
                tx.oncomplete = () => {
                    db.close();
                    resolve(true);
                };
                tx.onerror = () => {
                    db.close();
                    resolve(false);
                };
                const store = tx.objectStore(PAGE_STORE);
                store.delete(pageIndex);
            });
        }

        async function clearPageStore() {
            const db = await openNotebookDb();
            if (!db) return false;
            return new Promise((resolve) => {
                const tx = db.transaction(PAGE_STORE, 'readwrite');
                tx.oncomplete = () => {
                    db.close();
                    resolve(true);
                };
                tx.onerror = () => {
                    db.close();
                    resolve(false);
                };
                const store = tx.objectStore(PAGE_STORE);
                store.clear();
            });
        }

        async function reindexPagesAfterDelete(startIndex, totalPages) {
            const db = await openNotebookDb();
            if (!db) return false;
            return new Promise((resolve) => {
                const tx = db.transaction(PAGE_STORE, 'readwrite');
                tx.oncomplete = () => {
                    db.close();
                    resolve(true);
                };
                tx.onerror = () => {
                    db.close();
                    resolve(false);
                };
                const store = tx.objectStore(PAGE_STORE);
                const lastIndex = totalPages;
                let current = startIndex;
                const moveNext = () => {
                    if (current > lastIndex) {
                        return;
                    }
                    if (current === lastIndex) {
                        store.delete(lastIndex);
                        return;
                    }
                    const request = store.get(current + 1);
                    request.onsuccess = () => {
                        const data = request.result;
                        if (data) {
                            store.put(data, current);
                        } else {
                            store.delete(current);
                        }
                        current += 1;
                        moveNext();
                    };
                    request.onerror = () => {
                        current += 1;
                        moveNext();
                    };
                };
                moveNext();
            });
        }

        function reindexLocalCachesAfterDelete(startIndex) {
            const nextDirty = new Set();
            pageDirty.forEach(index => {
                if (index === startIndex) return;
                nextDirty.add(index > startIndex ? index - 1 : index);
            });
            pageDirty.clear();
            nextDirty.forEach(index => pageDirty.add(index));

            const nextAccess = new Map();
            pageAccess.forEach((value, index) => {
                if (index === startIndex) return;
                nextAccess.set(index > startIndex ? index - 1 : index, value);
            });
            pageAccess.clear();
            nextAccess.forEach((value, index) => pageAccess.set(index, value));

            if (Number.isFinite(state.activePageIndex)) {
                if (state.activePageIndex === startIndex) {
                    state.activePageIndex = Math.max(0, state.activePageIndex - 1);
                } else if (state.activePageIndex > startIndex) {
                    state.activePageIndex -= 1;
                }
            }

            pageLoadQueue.clear();
        }

        function touchPageAccess(pageIndex) {
            pageAccess.set(pageIndex, Date.now());
        }

        function applyPagePreview(pageIndex) {
            const page = state.pages[pageIndex];
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (!wrapper) return;
            if (page && page.preview) {
                wrapper.style.backgroundImage = `url("${page.preview}")`;
                wrapper.style.backgroundSize = 'cover';
                wrapper.style.backgroundRepeat = 'no-repeat';
                wrapper.style.backgroundPosition = 'center';
            } else {
                wrapper.style.backgroundImage = '';
            }
        }

        function renderPagePreview(pageIndex) {
            const page = state.pages[pageIndex];
            if (!page || !Array.isArray(page.strokes)) return null;
            const scale = PAGE_PREVIEW_SCALE;
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = Math.max(1, Math.floor(A4_WIDTH * scale));
            previewCanvas.height = Math.max(1, Math.floor(A4_HEIGHT * scale));
            const ctx = previewCanvas.getContext('2d');
            ctx.scale(scale, scale);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, A4_WIDTH, A4_HEIGHT);
            if (page.backgroundImage) {
                const img = new Image();
                img.src = page.backgroundImage;
                if (img.complete) {
                    ctx.drawImage(img, 0, 0, A4_WIDTH, A4_HEIGHT);
                }
            }
            if (page.bakedBackground) {
                const bakedImg = getCachedImage(page.bakedBackground);
                if (bakedImg.complete) {
                    ctx.drawImage(bakedImg, 0, 0, A4_WIDTH, A4_HEIGHT);
                }
            }
            drawImagesOnContext(ctx, page, pageIndex);
            for (const stroke of page.strokes) {
                const minPoints = stroke.tool === 'highlighter' ? 1 : 2;
                if (!stroke.points || stroke.points.length < minPoints) continue;
                if (stroke.tool === 'eraser-stroke') continue;
                drawSmoothStroke(ctx, stroke);
            }
            return previewCanvas.toDataURL('image/jpeg', 0.6);
        }

        function serializePayload(payload) {
            try {
                return JSON.stringify(payload);
            } catch (e) {
                console.error('Failed to serialize payload:', e);
                return null;
            }
        }

        function saveToLocalStorage(data) {
            try {
                localStorage.setItem(DATA_STORAGE_KEY, data);
                return true;
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
                return false;
            }
        }

        function buildMetaPayload(savedAt) {
            return {
                pages: state.pages.map(page => buildPageMeta(page)),
                version: 3,
                savedAt
            };
        }

        async function flushDirtyPages() {
            if (pageDirty.size === 0) return true;
            const dirty = Array.from(pageDirty);
            for (const pageIndex of dirty) {
                const page = state.pages[pageIndex];
                if (!page || page.unloaded) {
                    pageDirty.delete(pageIndex);
                    continue;
                }
                page.strokeCount = getVisibleStrokeCount(page);
                await savePageToIndexedDb(pageIndex, page);
                pageDirty.delete(pageIndex);
            }
            return true;
        }

        async function saveToStorage() {
            const savedAt = Date.now();
            const payload = buildMetaPayload(savedAt);
            const data = serializePayload(payload);
            if (!data) return { ok: false, savedAt: null };

            const localOk = saveToLocalStorage(data);
            const dbOk = await saveToIndexedDb(data, savedAt);
            await flushDirtyPages();
            const ok = localOk || dbOk;

            if (ok) {
                state.lastSavedAt = savedAt;
                updateSaveTimestamp();
            }

            return { ok, savedAt };
        }

        async function loadFromStorage() {
            let localPayload = null;
            let idbPayload = null;
            let legacyPayload = null;
            legacyPagesCache = null;

            try {
                const data = localStorage.getItem(DATA_STORAGE_KEY);
                if (data) {
                    localPayload = JSON.parse(data);
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }

            if (!localPayload) {
                LEGACY_DATA_KEYS.forEach((key) => {
                    if (legacyPayload) return;
                    try {
                        const data = localStorage.getItem(key);
                        if (data) {
                            legacyPayload = JSON.parse(data);
                        }
                    } catch (err) {
                        console.error('Failed to load legacy payload:', err);
                    }
                });
            }

            try {
                const record = await loadFromIndexedDb();
                if (record && record.data) {
                    idbPayload = JSON.parse(record.data);
                }
            } catch (e) {
                console.error('Failed to load from IndexedDB:', e);
            }

            const candidates = [localPayload, idbPayload, legacyPayload].filter(Boolean);
            const best = candidates.reduce((acc, item) => {
                if (!acc) return item;
                const accTime = typeof acc.savedAt === 'number' ? acc.savedAt : 0;
                const itemTime = typeof item.savedAt === 'number' ? item.savedAt : 0;
                return itemTime >= accTime ? item : acc;
            }, null);

            if (best && Array.isArray(best.pages)) {
                const hasLegacyStrokes = best.pages.some(page => Array.isArray(page?.strokes));
                if (hasLegacyStrokes) {
                    await migrateLegacyPayload(best);
                } else {
                    state.pages = best.pages.map(page => ({
                        strokes: null,
                        images: null,
                        backgroundImage: page?.backgroundImage || null,
                        backgroundSource: page?.backgroundSource || (page?.pdfPageIndex ? 'pdf' : (page?.backgroundImage ? 'custom' : 'template')),
                        pdfPageIndex: Number.isFinite(page?.pdfPageIndex) ? page.pdfPageIndex : null,
                        preview: page?.preview || null,
                        strokeCount: typeof page?.strokeCount === 'number' ? page.strokeCount : 0,
                        unloaded: true,
                        needsRedraw: true
                    }));
                    state.lastSavedAt = typeof best.savedAt === 'number' ? best.savedAt : null;
                }
            } else {
                state.pages = [];
                state.lastSavedAt = null;
            }
            updateSaveTimestamp();
        }

        function normalizeLegacyPage(page) {
            const backgroundImage = page?.backgroundImage || null;
            const pdfPageIndex = Number.isFinite(page?.pdfPageIndex) ? page.pdfPageIndex : null;
            const backgroundSource = page?.backgroundSource
                || (pdfPageIndex ? 'pdf' : (backgroundImage ? 'custom' : 'template'));
            return {
                strokes: Array.isArray(page?.strokes) ? page.strokes : [],
                images: Array.isArray(page?.images) ? page.images : [],
                backgroundImage,
                backgroundSource,
                pdfPageIndex,
                needsRedraw: true,
                unloaded: false
            };
        }

        async function migrateLegacyPayload(payload) {
            const pages = Array.isArray(payload?.pages) ? payload.pages : [];
            await clearPageStore();
            pageDirty.clear();
            pageAccess.clear();
            pageLoadQueue.clear();
            state.lastSavedAt = typeof payload?.savedAt === 'number' ? payload.savedAt : null;
            legacyPagesCache = pages;
            state.pages = pages.map(page => {
                const meta = buildPageMeta(page);
                return {
                    strokes: null,
                    images: null,
                    backgroundImage: meta.backgroundImage,
                    backgroundSource: meta.backgroundSource,
                    pdfPageIndex: meta.pdfPageIndex,
                    preview: meta.preview || null,
                    strokeCount: meta.strokeCount || 0,
                    unloaded: true,
                    needsRedraw: true
                };
            });

            const keepCount = Math.min(MAX_ACTIVE_PAGES, pages.length);
            for (let i = 0; i < keepCount; i++) {
                const fullPage = normalizeLegacyPage(pages[i]);
                state.pages[i] = {
                    ...fullPage,
                    preview: state.pages[i].preview || null,
                    strokeCount: getVisibleStrokeCount(fullPage),
                    unloaded: false
                };
                await savePageToIndexedDb(i, fullPage);
                legacyPagesCache[i] = null;
                touchPageAccess(i);
            }

            let index = keepCount;
            const batchSize = 10;
            const migrateBatch = async () => {
                let count = 0;
                while (index < pages.length && count < batchSize) {
                    const fullPage = normalizeLegacyPage(pages[index]);
                    await savePageToIndexedDb(index, fullPage);
                    legacyPagesCache[index] = null;
                    count += 1;
                    index += 1;
                }
                if (index < pages.length) {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(migrateBatch, { timeout: 500 });
                    } else {
                        setTimeout(migrateBatch, 60);
                    }
                } else {
                    legacyPagesCache = null;
                    saveToStorage();
                }
            };

            if (index < pages.length) {
                migrateBatch();
            }
        }

        function isPageLoaded(page) {
            return !!(page && !page.unloaded && Array.isArray(page.strokes));
        }

        function clearPagePreview(pageIndex) {
            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageIndex}"]`);
            if (wrapper) {
                wrapper.style.backgroundImage = '';
            }
        }

        async function ensurePageDataLoaded(pageIndex, options = {}) {
            const page = state.pages[pageIndex];
            if (!page) return null;
            if (isPageLoaded(page)) {
                touchPageAccess(pageIndex);
                return page;
            }
            if (pageLoadQueue.has(pageIndex)) {
                return pageLoadQueue.get(pageIndex);
            }
            const loadPromise = (async () => {
                let data = await loadPageFromIndexedDb(pageIndex);
                if (!data && legacyPagesCache && legacyPagesCache[pageIndex]) {
                    data = normalizeLegacyPage(legacyPagesCache[pageIndex]);
                    legacyPagesCache[pageIndex] = null;
                    await savePageToIndexedDb(pageIndex, data);
                }
                if (!data) {
                    data = {
                        strokes: [],
                        images: [],
                        backgroundImage: page.backgroundImage || null,
                        backgroundSource: page.backgroundSource || (page.pdfPageIndex ? 'pdf' : (page.backgroundImage ? 'custom' : 'template')),
                        pdfPageIndex: Number.isFinite(page.pdfPageIndex) ? page.pdfPageIndex : null,
                        needsRedraw: true
                    };
                }
                const current = state.pages[pageIndex] || page;
                const pendingUnload = !!current.pendingUnload;
                const next = {
                    ...page,
                    ...data,
                    preview: page.preview || null,
                    strokeCount: typeof page.strokeCount === 'number' ? page.strokeCount : getVisibleStrokeCount(data),
                    unloaded: false,
                    pendingUnload
                };
                state.pages[pageIndex] = next;
                touchPageAccess(pageIndex);
                if (!options.keepLoaded && (next.pendingUnload || !activePageIndices.has(pageIndex))) {
                    await unloadPageData(pageIndex);
                    return state.pages[pageIndex];
                }
                clearPagePreview(pageIndex);
                const canvas = document.querySelector(`canvas.page-canvas[data-page="${pageIndex}"]`);
                if (canvas) {
                    applyPageBackground(pageIndex, canvas);
                    redrawPage(pageIndex);
                }
                return next;
            })();
            pageLoadQueue.set(pageIndex, loadPromise);
            loadPromise.finally(() => pageLoadQueue.delete(pageIndex));
            return loadPromise;
        }

        async function unloadPageData(pageIndex) {
            const page = state.pages[pageIndex];
            if (!isPageLoaded(page)) return;
            page.strokeCount = getVisibleStrokeCount(page);
            if (!page.preview) {
                const hasImages = Array.isArray(page.images) && page.images.length > 0;
                const hasStrokes = Array.isArray(page.strokes) && page.strokes.length > 0;
                const hasBackground = page.backgroundSource === 'pdf'
                    || !!page.backgroundImage
                    || !!page.bakedBackground;
                if (hasImages || hasStrokes || hasBackground) {
                    page.preview = renderPagePreview(pageIndex);
                }
            }
            if (page.backgroundSource === 'pdf' && page.backgroundImage && page.backgroundImage.startsWith('blob:')) {
                const bg = page.backgroundImage;
                imageCache.delete(bg);
                imageCacheUsage.delete(bg);
                URL.revokeObjectURL(bg);
                page.backgroundImage = null;
            }
            await savePageToIndexedDb(pageIndex, page);
            pageDirty.delete(pageIndex);
            page.strokes = null;
            page.images = null;
            if (page.bakedBackground) {
                imageCache.delete(page.bakedBackground);
                imageCacheUsage.delete(page.bakedBackground);
            }
            page.bakedBackground = null;
            page.unloaded = true;
            page.pendingUnload = false;
            applyPagePreview(pageIndex);
        }

        function markPageDirty(pageIndex) {
            if (!Number.isFinite(pageIndex)) return;
            if (pageIndex < 0 || pageIndex >= state.pages.length) return;
            pageDirty.add(pageIndex);
            scheduleDriveSync();
        }

        function markAllPagesDirty() {
            state.pages.forEach((page, index) => {
                if (page && !page.unloaded) {
                    pageDirty.add(index);
                }
            });
            scheduleDriveSync();
        }

        let saveInProgress = false;
        let saveQueued = false;

        function isDriveSyncPending() {
            return !!(state.driveAutosave && !state.isReadOnly && (driveDirty || driveSaveInProgress || driveSaveQueued));
        }

        function requestImmediateDriveSave() {
            if (state.isReadOnly || !state.driveAutosave) return;
            driveDirty = true;
            if (!driveAccessToken) return;
            clearDriveSyncTimers();
            queueDriveSave(true);
        }

        function scheduleSave(immediate = false, pageIndex = null) {
            if (state.isReadOnly) return;
            if (Number.isFinite(pageIndex)) {
                markPageDirty(pageIndex);
            }
            showStatus('Saving...', true);
            clearTimeout(state.saveTimeout);
            const now = Date.now();
            const lastSaved = typeof state.lastSavedAt === 'number' ? state.lastSavedAt : 0;
            const overdue = !lastSaved || (now - lastSaved >= MAX_SAVE_INTERVAL);
            if (immediate || overdue) {
                queueSave();
                scheduleDriveSync();
                return;
            }
            state.saveTimeout = setTimeout(() => {
                queueSave();
            }, 500);
            scheduleDriveSync();
        }

        async function queueSave() {
            if (state.isReadOnly) return;
            if (saveInProgress) {
                saveQueued = true;
                return;
            }
            saveInProgress = true;
            const result = await saveToStorage();
            if (result.ok) {
                if (isDriveSyncPending()) {
                    showStatus('Saving to Drive...', { saving: true, savedAt: result.savedAt });
                } else {
                    showStatus('Saved', { savedAt: result.savedAt });
                }
            } else {
                showStatus('Save failed', { error: true });
            }
            saveInProgress = false;
            if (saveQueued) {
                saveQueued = false;
                showStatus('Saving...', true);
                queueSave();
            }
        }

        function flushOnClose() {
            if (state.isReadOnly) return;
            saveViewState();
            const savedAt = Date.now();
            const payload = buildMetaPayload(savedAt);
            const data = serializePayload(payload);
            if (data) {
                saveToLocalStorage(data);
                saveToIndexedDb(data, savedAt);
            }
            state.lastSavedAt = savedAt;
            updateSaveTimestamp();
            flushDirtyPages();
            if (driveDirty) {
                queueDriveSave(true, { keepalive: true });
            }
        }

        function clearDriveSyncTimers() {
            clearTimeout(driveSaveTimeout);
            driveSaveTimeout = null;
            clearTimeout(driveSyncMaxTimeout);
            driveSyncMaxTimeout = null;
        }

        function scheduleDriveSync() {
            if (state.isReadOnly || !state.driveAutosave) return;
            driveDirty = true;
            if (!driveAccessToken) return;
            clearTimeout(driveSaveTimeout);
            driveSaveTimeout = setTimeout(() => {
                queueDriveSave(false);
            }, DRIVE_SYNC_IDLE_DELAY);
            if (!driveSyncMaxTimeout) {
                driveSyncMaxTimeout = setTimeout(() => {
                    queueDriveSave(true);
                }, DRIVE_SYNC_MAX_DELAY);
            }
        }

        async function ensureDriveFile(options = {}) {
            if (state.driveFileId) return state.driveFileId;
            await ensureDriveToken(false);
            const folderId = state.driveFolderId || await ensureDriveFolder();
            const fileName = `${sanitizeFilename(state.exportName || 'Untitled')}.pdf`;
            const pdfBlob = await buildPdfBlob();
            const metadata = {
                name: fileName,
                mimeType: 'application/pdf',
                parents: folderId && folderId !== 'root' ? [folderId] : undefined
            };
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            form.append('file', pdfBlob);
            const res = await driveFetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                body: form,
                keepalive: !!options.keepalive
            });
            const data = await res.json();
            state.driveFileId = data.id;
            state.driveFileName = data.name || fileName;
            updateDocTitle();
            saveDriveSession();
            return state.driveFileId;
        }

        async function createDriveFileInFolder(folderId, fileName, pdfBlob, options = {}) {
            const metadata = {
                name: fileName,
                mimeType: 'application/pdf',
                parents: folderId && folderId !== 'root' ? [folderId] : undefined
            };
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            form.append('file', pdfBlob);
            const res = await driveFetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                body: form,
                keepalive: !!options.keepalive
            });
            const data = await res.json();
            return data.id;
        }

        async function updateDriveFile(fileId, pdfBlob, options = {}) {
            await driveFetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/pdf' },
                body: pdfBlob,
                keepalive: !!options.keepalive
            });
        }

        async function queueDriveSave(force = false, options = {}) {
            if (state.isReadOnly || !state.driveAutosave) return;
            if (!driveDirty && !force) return;
            if (driveSaveInProgress) {
                driveSaveQueued = true;
                driveSaveQueuedForce = driveSaveQueuedForce || force;
                driveSaveQueuedKeepalive = driveSaveQueuedKeepalive || !!options.keepalive;
                return;
            }
            driveSaveInProgress = true;
            driveDirty = false;
            clearDriveSyncTimers();
            try {
                const needsPdf = state.pages.some(page => page?.pdfPageIndex);
                if (needsPdf && !activePdfDocument) {
                    await restorePdfBackgroundsIfNeeded();
                }
                if (needsPdf && !activePdfDocument) {
                    showStatus('Waiting for PDF...', { preserveState: true });
                    driveSaveInProgress = false;
                    scheduleDriveSync();
                    return;
                }
                showStatus('Saving to Drive...', { saving: true });
                const fileId = await ensureDriveFile(options);
                const pdfBlob = await buildPdfBlob();
                await updateDriveFile(fileId, pdfBlob, options);
                const savedAt = typeof state.lastSavedAt === 'number' ? state.lastSavedAt : Date.now();
                showStatus('Saved', { savedAt });
            } catch (err) {
                showStatus('Drive save failed', { error: true });
                driveDirty = true;
                scheduleDriveSync();
            }
            driveSaveInProgress = false;
            if (driveSaveQueued) {
                const queuedForce = driveSaveQueuedForce;
                const queuedKeepalive = driveSaveQueuedKeepalive;
                driveSaveQueued = false;
                driveSaveQueuedForce = false;
                driveSaveQueuedKeepalive = false;
                queueDriveSave(queuedForce, queuedKeepalive ? { keepalive: true } : {});
            }
        }

        // History functions for undo/redo
        function saveToHistory(action) {
            if (state.isReadOnly) return;
            // Remove any future history if we're not at the end
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }

            // Add new action
            state.history.push(action);

            // Limit history size by count
            if (state.history.length > state.maxHistory) {
                state.history.shift();
            } else {
                state.historyIndex++;
            }

            // Also limit by memory usage
            trimHistoryByMemory();

            updateHistoryButtons();
        }

        async function undo() {
            if (state.isReadOnly) return;
            if (state.historyIndex < 0) return;

            const action = state.history[state.historyIndex];
            state.historyIndex--;
            state.activePageIndex = action.pageIndex;
            await ensurePageDataLoaded(action.pageIndex, { keepLoaded: true });
            const loadedPage = state.pages[action.pageIndex];
            if (!isPageLoaded(loadedPage)) {
                updateHistoryButtons();
                return;
            }

            if (action.type === 'add-stroke') {
                // Remove the stroke
                const page = state.pages[action.pageIndex];
                page.strokes.pop();
                redrawPage(action.pageIndex);
            } else if (action.type === 'add-image') {
                const page = state.pages[action.pageIndex];
                if (Array.isArray(page.images)) {
                    page.images.splice(action.index, 1);
                    redrawPage(action.pageIndex);
                }
            } else if (action.type === 'erase-strokes') {
                // Restore erased strokes
                const page = state.pages[action.pageIndex];
                // Restore in reverse order to maintain indices
                for (let i = action.strokes.length - 1; i >= 0; i--) {
                    const item = action.strokes[i];
                    page.strokes.splice(item.index, 0, item.stroke);
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'transform-strokes') {
                const page = state.pages[action.pageIndex];
                for (const item of action.before) {
                    page.strokes[item.index] = cloneStroke(item.stroke);
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'transform-selection') {
                const page = state.pages[action.pageIndex];
                if (action.before?.strokes) {
                    for (const item of action.before.strokes) {
                        page.strokes[item.index] = cloneStroke(item.stroke);
                    }
                }
                if (action.before?.images) {
                    if (!Array.isArray(page.images)) page.images = [];
                    for (const item of action.before.images) {
                        page.images[item.index] = { ...item.image };
                    }
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-area') {
                const page = state.pages[action.pageIndex];
                page.strokes = cloneStrokesArray(action.before);
                redrawPage(action.pageIndex);
            } else if (action.type === 'delete-images') {
                const page = state.pages[action.pageIndex];
                if (!Array.isArray(page.images)) page.images = [];
                action.images.forEach(item => {
                    page.images.splice(item.index, 0, { ...item.image });
                });
                redrawPage(action.pageIndex);
            } else if (action.type === 'delete-selection') {
                const page = state.pages[action.pageIndex];
                if (!page) return;
                if (Array.isArray(action.strokes) && action.strokes.length > 0) {
                    const sorted = [...action.strokes].sort((a, b) => a.index - b.index);
                    sorted.forEach(item => {
                        const insertIndex = Math.min(item.index, page.strokes.length);
                        page.strokes.splice(insertIndex, 0, cloneStroke(item.stroke));
                    });
                }
                if (Array.isArray(action.images) && action.images.length > 0) {
                    if (!Array.isArray(page.images)) page.images = [];
                    const sorted = [...action.images].sort((a, b) => a.index - b.index);
                    sorted.forEach(item => {
                        const insertIndex = Math.min(item.index, page.images.length);
                        page.images.splice(insertIndex, 0, { ...item.image });
                    });
                }
                clearSelection();
                redrawPage(action.pageIndex);
                renderPagesList();
            } else if (action.type === 'duplicate-selection') {
                const page = state.pages[action.pageIndex];
                if (!page) return;
                if (Array.isArray(action.strokes) && action.strokes.length > 0) {
                    const indices = action.strokes.map(item => item.index).sort((a, b) => b - a);
                    indices.forEach(index => {
                        if (index >= 0 && index < page.strokes.length) {
                            page.strokes.splice(index, 1);
                        }
                    });
                }
                if (Array.isArray(action.images) && action.images.length > 0) {
                    if (!Array.isArray(page.images)) page.images = [];
                    const indices = action.images.map(item => item.index).sort((a, b) => b - a);
                    indices.forEach(index => {
                        if (index >= 0 && index < page.images.length) {
                            page.images.splice(index, 1);
                        }
                    });
                }
                clearSelection();
                redrawPage(action.pageIndex);
                renderPagesList();
            }

            updateHistoryButtons();
            scheduleSave(false, action.pageIndex);
            if (!activePageIndices.has(action.pageIndex)) {
                await unloadPageData(action.pageIndex);
            }
        }

        async function redo() {
            if (state.isReadOnly) return;
            if (state.historyIndex >= state.history.length - 1) return;

            state.historyIndex++;
            const action = state.history[state.historyIndex];
            state.activePageIndex = action.pageIndex;
            await ensurePageDataLoaded(action.pageIndex, { keepLoaded: true });
            const loadedPage = state.pages[action.pageIndex];
            if (!isPageLoaded(loadedPage)) {
                updateHistoryButtons();
                return;
            }

            if (action.type === 'add-stroke') {
                // Re-add the stroke
                const page = state.pages[action.pageIndex];
                page.strokes.push(cloneStroke(action.stroke));
                redrawPage(action.pageIndex);
            } else if (action.type === 'add-image') {
                const page = state.pages[action.pageIndex];
                if (!Array.isArray(page.images)) page.images = [];
                const insertIndex = Math.min(action.index, page.images.length);
                page.images.splice(insertIndex, 0, { ...action.image });
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-strokes') {
                // Re-erase the strokes
                const page = state.pages[action.pageIndex];
                // Remove in order (highest index first to maintain indices)
                const sorted = [...action.strokes].sort((a, b) => b.index - a.index);
                for (const item of sorted) {
                    page.strokes.splice(item.index, 1);
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'transform-strokes') {
                const page = state.pages[action.pageIndex];
                for (const item of action.after) {
                    page.strokes[item.index] = cloneStroke(item.stroke);
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'transform-selection') {
                const page = state.pages[action.pageIndex];
                if (action.after?.strokes) {
                    for (const item of action.after.strokes) {
                        page.strokes[item.index] = cloneStroke(item.stroke);
                    }
                }
                if (action.after?.images) {
                    if (!Array.isArray(page.images)) page.images = [];
                    for (const item of action.after.images) {
                        page.images[item.index] = { ...item.image };
                    }
                }
                redrawPage(action.pageIndex);
            } else if (action.type === 'erase-area') {
                const page = state.pages[action.pageIndex];
                page.strokes = cloneStrokesArray(action.after);
                redrawPage(action.pageIndex);
            } else if (action.type === 'delete-images') {
                const page = state.pages[action.pageIndex];
                if (!Array.isArray(page.images)) return;
                const indices = action.images.map(item => item.index).sort((a, b) => b - a);
                indices.forEach(index => {
                    if (index >= 0 && index < page.images.length) {
                        page.images.splice(index, 1);
                    }
                });
                redrawPage(action.pageIndex);
            } else if (action.type === 'delete-selection') {
                const page = state.pages[action.pageIndex];
                if (!page) return;
                if (Array.isArray(action.strokes) && action.strokes.length > 0) {
                    const indices = action.strokes.map(item => item.index).sort((a, b) => b - a);
                    indices.forEach(index => {
                        if (index >= 0 && index < page.strokes.length) {
                            page.strokes.splice(index, 1);
                        }
                    });
                }
                if (Array.isArray(action.images) && action.images.length > 0) {
                    if (!Array.isArray(page.images)) return;
                    const indices = action.images.map(item => item.index).sort((a, b) => b - a);
                    indices.forEach(index => {
                        if (index >= 0 && index < page.images.length) {
                            page.images.splice(index, 1);
                        }
                    });
                }
                clearSelection();
                redrawPage(action.pageIndex);
                renderPagesList();
            } else if (action.type === 'duplicate-selection') {
                const page = state.pages[action.pageIndex];
                if (!page) return;
                if (Array.isArray(action.strokes) && action.strokes.length > 0) {
                    const sorted = [...action.strokes].sort((a, b) => a.index - b.index);
                    sorted.forEach(item => {
                        const insertIndex = Math.min(item.index, page.strokes.length);
                        page.strokes.splice(insertIndex, 0, cloneStroke(item.stroke));
                    });
                }
                if (Array.isArray(action.images) && action.images.length > 0) {
                    if (!Array.isArray(page.images)) page.images = [];
                    const sorted = [...action.images].sort((a, b) => a.index - b.index);
                    sorted.forEach(item => {
                        const insertIndex = Math.min(item.index, page.images.length);
                        page.images.splice(insertIndex, 0, { ...item.image });
                    });
                }
                clearSelection();
                redrawPage(action.pageIndex);
                renderPagesList();
            }

            updateHistoryButtons();
            scheduleSave(false, action.pageIndex);
            if (!activePageIndices.has(action.pageIndex)) {
                await unloadPageData(action.pageIndex);
            }
        }

        function updateHistoryButtons() {
            const undoBtn = document.getElementById('btn-undo');
            const redoBtn = document.getElementById('btn-redo');
            const readOnly = !!state.isReadOnly;
            if (undoBtn) {
                undoBtn.disabled = readOnly || state.historyIndex < 0;
            }
            if (redoBtn) {
                redoBtn.disabled = readOnly || state.historyIndex >= state.history.length - 1;
            }
        }

        function showStatus(text, options = {}) {
            const indicator = document.getElementById('save-indicator');
            if (!indicator) return;
            const timestampEl = document.getElementById('save-timestamp');

            let saving = false;
            let error = false;
            let preserveState = false;
            let savedAt = null;

            if (typeof options === 'boolean') {
                saving = options;
            } else {
                saving = !!options.saving;
                error = !!options.error;
                preserveState = !!options.preserveState;
                savedAt = typeof options.savedAt === 'number' ? options.savedAt : null;
            }

            if (!preserveState) {
                indicator.classList.toggle('saving', saving);
                indicator.classList.toggle('error', error);
                indicator.classList.toggle('saved', !saving && !error);
            }
            indicator.title = text;
            indicator.setAttribute('aria-label', text);
            if (timestampEl) {
            }

            if (savedAt) {
                state.lastSavedAt = savedAt;
            }
            updateSaveTimestamp();
        }

        function showLoading(text) {
            loadingText.textContent = text;
            loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            loadingOverlay.classList.remove('visible');
        }

        function sanitizeFilename(name) {
            const cleaned = name.replace(/[\\/:*?"<>|]+/g, '_').trim();
            return cleaned || 'cuaderno';
        }

        function openExportModal() {
            const modal = document.getElementById('modal-export-pdf');
            const input = document.getElementById('export-filename');
            if (!modal || !input) return;
            input.value = state.exportName || 'cuaderno';
            modal.classList.add('visible');
            requestAnimationFrame(() => {
                input.focus();
                input.select();
            });
        }

        function closeExportModal() {
            const modal = document.getElementById('modal-export-pdf');
            if (!modal) return;
            modal.classList.remove('visible');
        }

        function confirmExportModal() {
            const input = document.getElementById('export-filename');
            if (!input) return;
            let name = input.value.trim();
            if (name.toLowerCase().endsWith('.pdf')) {
                name = name.slice(0, -4);
            }
            name = sanitizeFilename(name);
            if (!state.isReadOnly) {
                state.exportName = name;
                updateDocTitle();
                saveDriveSession();
            }
            closeExportModal();
            exportPDF(`${name}.pdf`);
        }

        function loadImage(src) {
            return new Promise((resolve) => {
                if (!src) {
                    resolve(null);
                    return;
                }
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => resolve(null);
                img.src = src;
            });
        }

        async function drawImagesOnCanvas(ctx, page) {
            if (!page || !Array.isArray(page.images) || page.images.length === 0) return;
            for (const image of page.images) {
                const img = await loadImage(image.src);
                if (!img) continue;
                ctx.save();
                ctx.translate(image.x, image.y);
                ctx.rotate(image.rotation || 0);
                ctx.drawImage(
                    img,
                    -image.width / 2,
                    -image.height / 2,
                    image.width,
                    image.height
                );
                ctx.restore();
            }
        }

        // Import PDF - detect embedded strokes or treat as background
        async function importPDFArrayBuffer(arrayBuffer) {
            if (!arrayBuffer) return;
            showLoading('Analyzing PDF...');

            try {
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;

                resetPdfState();
                activePdfDocument = pdf;
                activePdfPageCount = numPages;
                pdfBackgroundScale = getPdfBackgroundScale(numPages);

                // Try to extract embedded stroke data from PDF metadata
                let embeddedStrokes = null;
                try {
                    const metadata = await pdf.getMetadata();
                    const keywords = metadata?.info?.Keywords || '';

                    if (keywords.startsWith('STROKES_DATA:')) {
                        const encodedData = keywords.substring('STROKES_DATA:'.length);
                        const decodedString = decodeURIComponent(escape(atob(encodedData)));
                        embeddedStrokes = JSON.parse(decodedString);
                        showLoading('PDF with strokes detected...');
                    }
                } catch (metaErr) {
                    console.log('No embedded stroke data found:', metaErr);
                }

                await clearPageStore();
                pageDirty.clear();
                pageAccess.clear();
                pageLoadQueue.clear();
                legacyPagesCache = null;
                imageCache.clear();
                imageCacheUsage.clear();
                state.history = [];
                state.historyIndex = -1;
                updateHistoryButtons();

                const importedPages = [];
                for (let i = 1; i <= numPages; i++) {
                    const pageData = embeddedStrokes ? embeddedStrokes[i - 1] : null;
                    if (pageData) {
                        const hasImagesKey = Object.prototype.hasOwnProperty.call(pageData, 'images');
                        const restoredImages = Array.isArray(pageData.images)
                            ? pageData.images
                            : [];
                        const useLegacyRaster = !hasImagesKey;
                        const restoredStrokes = useLegacyRaster ? [] : (pageData.strokes || []);
                        const backgroundSource = pageData.backgroundSource
                            || (pageData.hasCustomBackground ? 'pdf' : 'template');
                        const needsPdfBackground = useLegacyRaster || backgroundSource !== 'template';
                        const pagePdfIndex = Number.isFinite(pageData.pdfPageIndex) ? pageData.pdfPageIndex : i;

                        if (needsPdfBackground) {
                            importedPages.push({
                                strokes: restoredStrokes,
                                backgroundImage: null,
                                backgroundSource: 'pdf',
                                pdfPageIndex: pagePdfIndex,
                                images: useLegacyRaster ? [] : restoredImages,
                                needsRedraw: true
                            });
                        } else {
                            importedPages.push({
                                strokes: restoredStrokes,
                                backgroundImage: null,
                                backgroundSource: 'template',
                                pdfPageIndex: null,
                                images: restoredImages,
                                needsRedraw: true
                            });
                        }
                    } else {
                        importedPages.push({
                            strokes: [],
                            backgroundImage: null,
                            backgroundSource: 'pdf',
                            pdfPageIndex: i,
                            images: [],
                            needsRedraw: true
                        });
                    }
                }

                await migrateLegacyPayload({ pages: importedPages });
                renderAllPages();
                state.activePageIndex = 0;
                scheduleSave(true);
                updateVisiblePages(true);

                const isNonAppPdf = !embeddedStrokes;

                if (embeddedStrokes) {
                    const totalStrokes = embeddedStrokes.reduce((sum, p) => sum + (p.strokes?.length || 0), 0);
                    showStatus(`PDF imported: ${numPages} pages, ${totalStrokes} strokes restored`, { preserveState: true });
                } else {
                    showStatus(`PDF imported: ${numPages} pages (as background)`, { preserveState: true });
                }

                if (isNonAppPdf) {
                    ensurePageCanvas(0);
                    await renderPdfPageToBackground(0, pdfRenderToken);
                }

                hideLoading();
                centerViewOnTop();

            } catch (err) {
                console.error('Error importing PDF:', err);
                hideLoading();
                showStatus('Error importing PDF', { preserveState: true });
            }
        }

        async function importPDF(e) {
            if (state.isReadOnly) {
                if (pdfInput) pdfInput.value = '';
                return;
            }
            const file = e.target.files[0];
            if (!file) return;
            const arrayBuffer = await file.arrayBuffer();
            await importPDFArrayBuffer(arrayBuffer);
            pdfInput.value = '';
        }

        async function loadPageDataForExport(pageIndex) {
            const page = state.pages[pageIndex];
            if (!page) {
                return {
                    strokes: [],
                    images: [],
                    backgroundImage: null,
                    backgroundSource: 'template',
                    pdfPageIndex: null
                };
            }
            if (isPageLoaded(page)) {
                return page;
            }
            let data = await loadPageFromIndexedDb(pageIndex);
            if (!data && legacyPagesCache && legacyPagesCache[pageIndex]) {
                data = normalizeLegacyPage(legacyPagesCache[pageIndex]);
            }
            const fallback = data || {};
            return {
                ...page,
                ...fallback,
                strokes: Array.isArray(fallback.strokes) ? fallback.strokes : [],
                images: Array.isArray(fallback.images) ? fallback.images : []
            };
        }

        async function buildPdfBlob() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });

            await flushDirtyPages();

            const pageCount = state.pages.length;
            const strokeData = new Array(pageCount);
            const backgroundImages = new Array(pageCount);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = A4_WIDTH * CANVAS_SCALE;
            tempCanvas.height = A4_HEIGHT * CANVAS_SCALE;
            const tempCtx = tempCanvas.getContext('2d');
            const pdfCanvas = document.createElement('canvas');
            const pdfCtx = pdfCanvas.getContext('2d');

            for (let i = 0; i < pageCount; i++) {
                const pageData = await loadPageDataForExport(i);
                const backgroundSource = pageData.backgroundSource
                    || (pageData.pdfPageIndex ? 'pdf' : (pageData.backgroundImage ? 'custom' : 'template'));
                const backgroundImage = backgroundSource === 'pdf' ? null : (pageData.backgroundImage || null);
                backgroundImages[i] = backgroundImage;
                strokeData[i] = {
                    strokes: Array.isArray(pageData.strokes) ? pageData.strokes : [],
                    images: Array.isArray(pageData.images) ? pageData.images : [],
                    hasCustomBackground: backgroundSource === 'pdf' || !!backgroundImage,
                    backgroundSource,
                    pdfPageIndex: Number.isFinite(pageData.pdfPageIndex) ? pageData.pdfPageIndex : null
                };
            }

            // Embed stroke data as PDF metadata (custom property)
            const metadataString = JSON.stringify(strokeData);
            const encodedMetadata = btoa(unescape(encodeURIComponent(metadataString)));
            
            // Add as PDF property
            pdf.setProperties({
                title: 'Cuaderno Digital',
                subject: 'Notas con S-Pen',
                creator: 'Cuaderno Digital App',
                keywords: `STROKES_DATA:${encodedMetadata}`
            });

            for (let i = 0; i < pageCount; i++) {
                if (i > 0) pdf.addPage();

                const page = strokeData[i];
                tempCtx.setTransform(1, 0, 0, 1, 0, 0);
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

                // Draw background
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                const bgImage = backgroundImages[i];
                if (bgImage) {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                            resolve();
                        };
                        img.onerror = resolve;
                        img.src = bgImage;
                    });
                } else if (page.pdfPageIndex && activePdfDocument) {
                    const pdfPage = await activePdfDocument.getPage(page.pdfPageIndex);
                    const baseViewport = pdfPage.getViewport({ scale: 1 });
                    const scale = Math.min(tempCanvas.width / baseViewport.width, tempCanvas.height / baseViewport.height);
                    const viewport = pdfPage.getViewport({ scale });
                    pdfCanvas.width = viewport.width;
                    pdfCanvas.height = viewport.height;
                    await pdfPage.render({ canvasContext: pdfCtx, viewport }).promise;
                    const offsetX = (tempCanvas.width - viewport.width) / 2;
                    const offsetY = (tempCanvas.height - viewport.height) / 2;
                    tempCtx.drawImage(pdfCanvas, offsetX, offsetY, viewport.width, viewport.height);
                    if (pdfPage.cleanup) {
                        pdfPage.cleanup();
                    }
                } else {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                            resolve();
                        };
                        img.onerror = resolve;
                        img.src = SVG_BACKGROUND;
                    });
                }

                // Draw strokes
                tempCtx.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';
                await drawImagesOnCanvas(tempCtx, page);
                for (const stroke of page.strokes) {
                    const minPoints = stroke.tool === 'highlighter' ? 1 : 2;
                    if (!stroke.points || stroke.points.length < minPoints) continue;
                    if (stroke.tool === 'eraser-stroke') continue;

                    drawSmoothStroke(tempCtx, stroke);
                }

                const imgData = tempCanvas.toDataURL('image/jpeg', 0.9);
                pdf.addImage(imgData, 'JPEG', 0, 0, 210, 297);
            }

            return pdf.output('blob');
        }

        // Export PDF with embedded stroke data
        async function exportPDF(fileName) {
            const safeName = fileName || 'cuaderno.pdf';
            showLoading('Generando PDF...');

            try {
                const pdfBlob = await buildPdfBlob();
                const link = document.createElement('a');
                link.href = URL.createObjectURL(pdfBlob);
                link.download = safeName;
                link.click();
                URL.revokeObjectURL(link.href);
                showStatus('PDF exported', { preserveState: true });
            } catch (err) {
                showStatus('PDF export failed', { preserveState: true });
            }

            hideLoading();
        }

        // Start
        init();
    </script>
</body>
</html>
